<!DOCTYPE html>
<html lang="en" dir="auto" data-theme="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Idiots, Idiots Everywhere.jpg | Notes from the digital underground by Lngnmn</title>
<meta name="keywords" content="AI, LLM, bullshit">
<meta name="description" content="Everything is broken and idiots are everywhere. There is a clown which attention whoring, sorry, publicly arguing (and gaining a lot of unwarranted attention) that one shall vapecode in C.
https://news.ycombinator.com/item?id=46207505
Basically, making such a claim is idiotic on so many levels that it is hard to know where to start. Almost the whole of  classic non-bullshit programming language theory research is about how to correctly address C&rsquo;s shortcomings and semantic issues, and how to avoid the inherent in the design of the language (and the ABI) problems.">
<meta name="author" content="lngnmn2@yahoo.com">
<link rel="canonical" href="https://lngnmn2.github.io/articles/idiots-idiots-everywhere/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.a5781257de4197b8e3d54346acdf1dd55a9ba4cb91dcace192fc1baf228c08b5.css" integrity="sha256-pXgSV95Bl7jj1UNGrN8d1VqbpMuR3KzhkvwbryKMCLU=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://lngnmn2.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://lngnmn2.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://lngnmn2.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://lngnmn2.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://lngnmn2.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://lngnmn2.github.io/articles/idiots-idiots-everywhere/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
                color-scheme: dark;
            }

            .list {
                background: var(--theme);
            }

            .toc {
                background: var(--entry);
            }
        }

        @media (prefers-color-scheme: light) {
            .list::-webkit-scrollbar-thumb {
                border-color: var(--code-bg);
            }
        }

    </style>
</noscript>
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.querySelector("html").dataset.theme = 'dark';
    } else if (localStorage.getItem("pref-theme") === "light") {
       document.querySelector("html").dataset.theme = 'light';
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.querySelector("html").dataset.theme = 'dark';
    } else {
        document.querySelector("html").dataset.theme = 'light';
    }

</script><link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Source+Code+Pro:wght@300&display=swap" rel="stylesheet">
<link href="https://fonts.googleapis.com/css2?family=Noto+Sans:wght@300&display=swap" rel="stylesheet">
<link href="https://fonts.googleapis.com/css2?family=Noto+Serif:wght@300&display=swap" rel="stylesheet">
<style>
font-family: 'Noto Serif', serif;
font-family: 'Noto Sans', sans-serif;
font-family: 'Source Code Pro', monospace;
</style>
<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script type="text/javascript" id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script><meta property="og:url" content="https://lngnmn2.github.io/articles/idiots-idiots-everywhere/">
  <meta property="og:site_name" content="Notes from the digital underground by Lngnmn">
  <meta property="og:title" content="Idiots, Idiots Everywhere.jpg">
  <meta property="og:description" content="Everything is broken and idiots are everywhere. There is a clown which attention whoring, sorry, publicly arguing (and gaining a lot of unwarranted attention) that one shall vapecode in C.
https://news.ycombinator.com/item?id=46207505
Basically, making such a claim is idiotic on so many levels that it is hard to know where to start. Almost the whole of classic non-bullshit programming language theory research is about how to correctly address C’s shortcomings and semantic issues, and how to avoid the inherent in the design of the language (and the ABI) problems.">
  <meta property="og:locale" content="en-us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="articles">
    <meta property="article:published_time" content="2025-12-10T00:00:00+05:45">
    <meta property="article:modified_time" content="2025-12-10T10:59:40+05:45">
    <meta property="article:tag" content="AI">
    <meta property="article:tag" content="LLM">
    <meta property="article:tag" content="Bullshit">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Idiots, Idiots Everywhere.jpg">
<meta name="twitter:description" content="Everything is broken and idiots are everywhere. There is a clown which attention whoring, sorry, publicly arguing (and gaining a lot of unwarranted attention) that one shall vapecode in C.
https://news.ycombinator.com/item?id=46207505
Basically, making such a claim is idiotic on so many levels that it is hard to know where to start. Almost the whole of  classic non-bullshit programming language theory research is about how to correctly address C&rsquo;s shortcomings and semantic issues, and how to avoid the inherent in the design of the language (and the ABI) problems.">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Articles",
      "item": "https://lngnmn2.github.io/articles/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Idiots, Idiots Everywhere.jpg",
      "item": "https://lngnmn2.github.io/articles/idiots-idiots-everywhere/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Idiots, Idiots Everywhere.jpg",
  "name": "Idiots, Idiots Everywhere.jpg",
  "description": "Everything is broken and idiots are everywhere. There is a clown which attention whoring, sorry, publicly arguing (and gaining a lot of unwarranted attention) that one shall vapecode in C.\nhttps://news.ycombinator.com/item?id=46207505\nBasically, making such a claim is idiotic on so many levels that it is hard to know where to start. Almost the whole of classic non-bullshit programming language theory research is about how to correctly address C\u0026rsquo;s shortcomings and semantic issues, and how to avoid the inherent in the design of the language (and the ABI) problems.\n",
  "keywords": [
    "AI", "LLM", "bullshit"
  ],
  "articleBody": "Everything is broken and idiots are everywhere. There is a clown which attention whoring, sorry, publicly arguing (and gaining a lot of unwarranted attention) that one shall vapecode in C.\nhttps://news.ycombinator.com/item?id=46207505\nBasically, making such a claim is idiotic on so many levels that it is hard to know where to start. Almost the whole of classic non-bullshit programming language theory research is about how to correctly address C’s shortcomings and semantic issues, and how to avoid the inherent in the design of the language (and the ABI) problems.\nThe real, non-bullshit solution, inspired, of course, on the decades of research in the classic FP realm, is the modern Scala 3 collection library, which allows one program without imperative looping constructs and imperative array indexing, with just proper method’s chaining, which is, of course, type-safe and efficient (due to inlining).\nIn general, one has to program at the highest and the most general and abstract level possible (ideally, in a pure Set notation with some minimal classic mathematical notation to denote relations, and ML/Haskell style function syntax is a good approximation to that ideal), and leave the compiler and the optimizer to do the rest.\nSome way, way smarter and intellectually refined people, with a proper mathematical background (just like being of different spices from these vocal idiots), intuitively realized that the minimal and the most expressive syntax, based on the traditional refined and minimalist mathematical notation, is the right way (for subtle cognitive reasons – it captures no more than necessary and sufficient in the most minimal way), and the focus should be on Algebraic Data Types, not on imperative constructs.\nThis is why and how the , | -\u003e (and () since nesting is an implementation of composition) are enough for everything, and shall be this abstract and this high-level, and the syntax must directly capture are reflect these notations. The ML family, unsurprisingly, got it just right.\nHaving “low-level” types, including generics, at a higher level of domain-specific types and related DSLs (a set of associated operations) is a major design flaw. Any less ignorant person who have seen SNL or Erlang or Haskell will immediately understand why.\nOne more time, just as the Set Theory is enough to express everything in Mathematics, the minimalistic functional programming notation (with ADTs) is enough to express everything in Programming. This is the most important insight, period.\nThere is something to learn from the Group Theory – how to build proper abstract data types and properly generalize over them, and the Category theory – how to properly compose functions and data transformation, knowing all the “arrows” between dots which can possibly be Out There.\nAnd then, when one actually need to go low-level, have a specialized embedded low-level DSL, which is properly embedded into the high-level language, and properly type-checked and optimized by the compiler. You can have all your C-like fucking syntax with the fucking curly braces without polluting the math-like high-level code with it.\nYes, the curly braises has to be reserved only for the traditional C/PHP/Java syntax of a embedded DSL, for a stark remainder, and yes, the traditional imperative block of statements is just {;}. You are doing exactly this already by FFI-ing low-level libraries anyway. Just embed the stuff in and better typecheck.\nOne more time – C was a bunch of clever hacks, not the proper way to program (only idiots want to program in terms of implementation and representation details of everything, at the level slightly higher than assembly, in an inherently imperative way, destructively mutating memory locations). This is like writing mathematics describing the “materials” being used.\nThe proper way to program is to use the highest-level abstractions possible (think of MATLAB/Octave), and leave the rest to the compiler and the optimizer. This has been realized in the fucking 70s, with CLU and ML, and the whole FP research is about this fact.\nHere I feel obliged to remind you of something – the original HN code (back then, I still remember when I untarred the stuff) was some few hundreds of kilobytes for the Arc languages and another few hundreds of KB for news.arc. This is what a high-level programming, unpolluted by low-level types, could accomplish “in practice” (fucking idiots!). Yes, it relied on the high-qualify mzscheme stdlib and runtime, and used pain files (no DBs or ORMs), but the UNIX-kike systems were excellent at optimizing and caching files. And it was good-enough to run the site and to be actually continuously improved.\nThe real “secret” was in that they’ve used the proper abstractions – at the appropriate level, and the language optimized for that very level – the s-expression and files. Not too low, not too abstract, just right, and yes a mature Scheme implementation did all the “heavy lifting”. rtm did this. No one programs like this anymore. No one even knows the hows and whys.\nYes, Rust (and even Ocaml) could be way better designed if they just add a couple of specialized embedded DSLs – one of the types as in Haskell (the type-signatures is a proper DSL of its own, at its own level) and, for low-level programming, a C-like embedded DSL, when one can express low-level memory manipulations. Just “unsafe” is too general, one has to have “colored closures”, of which the type system is aware, and can properly optimize and check them.\nAnd look, the “elite hackers” just began to suspect something\nhttps://news.ycombinator.com/item?id=46152838\nIt turns out, the more constraints on the semantics of a language one has – the better (the principle I have formulated half of the year before this HN post) is just an instance of the same universal principle, which forced to restrict way too general The [original] Lambda Calculus formalism with necessary Simple Types – not everything can be applied to everything else.\nSimilarly, a raw pointer way is too general, even a reference is way too general – not everything can be referenced by without additional (proper) restrictions. The FP ideal, where everything is an immutable binding (both, at the level of code (semantics) and of the data) is too inefficient (for specialized cases), so one there has to be a proper classification (typing) of reference (to imperative memory locations). References has to be “colored” too.\nAnd then the copy and move semantics. If one cannot have immutability, one has to move (by default), it is that simple. Rust did a lot of intuitive insights right (but of course no one bothered to research and make such kind of explicit [properly] theoretical arguments).\nSo, yes, if one has to vapecode, one shall do so in a languages with a well-researched and the most strict semantics (like Haskell, Ocaml, or Scala3 or, while having no better alternative – Rust). The problem is that there is not enough high-quality code in these niche languages, and the amateur crap on github is as bad as a stupid verbiage on 4chan. (The Haskell ecosystem has been plagued by amateur code, while they are trying to code the very same JavaEE but in a different syntax, with more “annoying” restrictions. The same complain is about Rust – “the borrow checker is so annoying and keeps rejecting my brilliant imperative crap”).\nTo summarize. Not in C, obviously. C semantically is not that far from PHP, which is the “golden standard”. Not in C++, because of what it is. In Ocaml or Rust. Not in Haskell (unfortunately), because almost all the code is infested with unnecessary, redundant abstractions and all the dependencies (except the ones used by GHC) are fucking over-abstracted crap (yes, one has to actually learn math before touching Haskell).\nAnd last, but not least, please kindly fuck off, you fucking narcissistic POS HN impostors.\n",
  "wordCount" : "1290",
  "inLanguage": "en",
  "datePublished": "2025-12-10T00:00:00+05:45",
  "dateModified": "2025-12-10T10:59:40+05:45",
  "author":[{
    "@type": "Person",
    "name": "lngnmn2@yahoo.com"
  }],
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://lngnmn2.github.io/articles/idiots-idiots-everywhere/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Notes from the digital underground by Lngnmn",
    "logo": {
      "@type": "ImageObject",
      "url": "https://lngnmn2.github.io/favicon.ico"
    }
  }
}
</script>
</head>
<body id="top">
    <header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://lngnmn2.github.io/" accesskey="h" title="Notes from the digital underground by Lngnmn (Alt + H)">Notes from the digital underground by Lngnmn</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://lngnmn2.github.io/about/" title="About me.">
                    <span>About me.</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title entry-hint-parent">
      Idiots, Idiots Everywhere.jpg
    </h1>
    <div class="post-meta"><span title='2025-12-10 00:00:00 +0545 +0545'>December 10, 2025</span>&nbsp;·&nbsp;<span>lngnmn2@yahoo.com</span>

</div>
  </header> 
  <div class="post-content"><p>Everything is broken and idiots are everywhere. There is a clown which attention whoring, sorry, publicly arguing (and gaining a lot of unwarranted attention) that one shall vapecode in <code>C</code>.</p>
<p><a href="https://news.ycombinator.com/item?id=46207505">https://news.ycombinator.com/item?id=46207505</a></p>
<p>Basically, making such a claim is idiotic on so many levels that it is hard to know where to start. Almost the whole of  <em>classic</em> non-bullshit programming language theory research is about how to correctly address C&rsquo;s shortcomings and <em>semantic</em> issues, and how to avoid the inherent in the design of the language (and the ABI) problems.</p>
<p>The real, non-bullshit solution, inspired, of course, on the decades of research in the classic FP realm, is the modern Scala 3 collection library, which allows one program without imperative looping constructs and imperative array indexing, with just proper method&rsquo;s chaining, which is, of course, type-safe and efficient (due to inlining).</p>
<p>In general, one has to program at the highest and the most general and abstract  level possible (ideally, in a pure Set notation with some minimal classic mathematical notation to denote <em>relations</em>, and ML/Haskell style function syntax is a good approximation to that ideal), and leave the compiler and the optimizer to do the rest.</p>
<p>Some way, way smarter and intellectually refined people, with a proper mathematical background (just like being of different spices from these vocal idiots), intuitively realized that the minimal and the most expressive syntax, based on the  traditional refined and minimalist mathematical notation, is the right way (for subtle cognitive reasons &ndash; it captures no more than necessary and sufficient in the most minimal way), and the focus should be on Algebraic Data Types, not on imperative constructs.</p>
<p>This is why and how the <code>, | -&gt;</code> (and <code>()</code> since <em>nesting is an implementation of composition</em>) are enough for everything, and shall be this abstract and this high-level, and the syntax must directly capture are reflect these notations. The ML family, unsurprisingly, got it just right.</p>
<p>Having &ldquo;low-level&rdquo; types, including generics, at a higher level of domain-specific types and related DSLs (a set of associated operations) is a major design flaw. Any less ignorant person who have seen SNL or Erlang or Haskell will immediately understand why.</p>
<p>One more time, just as the Set Theory is enough to express everything in Mathematics, the minimalistic functional programming notation (with ADTs) is enough to express everything in Programming. This is the most important insight, period.</p>
<p>There is something to learn from the Group Theory &ndash; how to build proper abstract data types and properly generalize over them, and the Category theory &ndash; how to properly compose functions and data transformation, knowing <em>all</em> the <em>&ldquo;arrows&rdquo; between dots</em> which can possibly be Out There.</p>
<p>And then, when one actually need to go <em>low-level</em>, have a specialized embedded low-level DSL, which is properly embedded into the high-level language, and properly type-checked and optimized by the compiler. You can have all your C-like fucking syntax with the <em>fucking curly braces</em> without polluting the math-like high-level code with it.</p>
<p>Yes, the curly braises has to be reserved only for the traditional C/PHP/Java syntax of a embedded DSL, for a stark remainder, and yes, the traditional imperative block <em>of statements</em> is just <code>{;}</code>.  You are doing exactly this already by FFI-ing low-level libraries anyway. Just embed the stuff in and better typecheck.</p>
<p>One more time &ndash; <code>C</code> was a bunch of clever hacks, not the <em>proper way to program</em> (only idiots want to program in terms of implementation and representation details of everything, at the level slightly higher than assembly, in an inherently imperative way, destructively mutating memory locations). This is like writing mathematics describing the &ldquo;materials&rdquo; being used.</p>
<p>The proper way to program is to use the highest-level abstractions possible (think of MATLAB/Octave), and leave the rest to the compiler and the optimizer. This has been realized in the fucking 70s, with CLU and ML, and the whole FP research is about this fact.</p>
<p>Here I feel obliged to  remind you of something &ndash; the original HN code (back then, I still remember when I untarred the stuff) was some few hundreds of kilobytes for the Arc languages and another few hundreds of KB for <code>news.arc</code>. This is what a high-level programming, unpolluted by low-level types, could accomplish &ldquo;in practice&rdquo; (fucking idiots!). Yes, it relied  on the high-qualify <code>mzscheme</code> stdlib and runtime, and used pain <em>files</em> (no DBs or ORMs), but the UNIX-kike systems were excellent at optimizing and caching files. And it was good-enough to run the site and to be actually <em>continuously improved</em>.</p>
<p>The real &ldquo;secret&rdquo; was in that they&rsquo;ve used the proper abstractions &ndash; at the appropriate level, and the language optimized for that very level &ndash; the s-expression and files. Not too low, not too abstract, just right, and yes a mature Scheme implementation did all the &ldquo;heavy lifting&rdquo;. <code>rtm</code> did this. No one programs like this anymore. No one even knows the hows and whys.</p>
<p>Yes, Rust (and even Ocaml) could be <em>way better designed</em> if they just add a couple of specialized embedded DSLs &ndash; one of the types as in Haskell (the type-signatures is a proper DSL of its own, at its own level) and, for low-level programming, a C-like embedded DSL, when one can express low-level memory manipulations. Just &ldquo;unsafe&rdquo; is too general, one has to have &ldquo;colored <em>closures</em>&rdquo;, of which the type system is aware, and can properly optimize and check them.</p>
<p>And look, the &ldquo;elite hackers&rdquo; just began to suspect something</p>
<p><a href="https://news.ycombinator.com/item?id=46152838">https://news.ycombinator.com/item?id=46152838</a></p>
<p>It turns out, the more constraints on the semantics of a language one has &ndash; the better (the principle I have formulated half of the year before this HN post) is just an instance of the same universal principle, which forced to restrict way too general The [original] Lambda Calculus formalism  with necessary Simple Types &ndash; not everything can be applied to everything else.</p>
<p>Similarly, a raw pointer way is too general, even a reference is way too general &ndash; not everything can be referenced by without additional (proper) restrictions.  The FP ideal, where everything is an immutable <em>binding</em> (both, at the level of code (semantics) and of the data) is too inefficient (for specialized cases), so one there has to be a proper classification (typing) of reference (to imperative  memory locations). References has to be &ldquo;colored&rdquo; too.</p>
<p>And then the copy and move semantics. If one cannot have immutability, one has to move (by default), it is that simple. Rust did a lot of intuitive insights right (but of course no one bothered to research and make such kind of explicit [properly] theoretical arguments).</p>
<p>So, yes, if one has to vapecode, one shall do so in a languages with a well-researched and the most strict semantics (like Haskell, Ocaml, or Scala3 or, while having no better alternative &ndash; Rust).  The problem is that there is not enough high-quality code in these niche languages, and the amateur crap on github is as bad as a stupid verbiage on 4chan. (The Haskell ecosystem has been plagued by amateur code, while they are trying to code the very same JavaEE but in a different syntax, with more &ldquo;annoying&rdquo; restrictions. The same complain is about Rust &ndash; &ldquo;<em>the borrow checker is so  annoying</em> and keeps rejecting my brilliant imperative crap&rdquo;).</p>
<p>To summarize. Not in C, obviously. C <em>semantically</em> is not that far from PHP, which is the &ldquo;golden standard&rdquo;.  Not in C++, because of what it is. In Ocaml or Rust. Not in Haskell (unfortunately), because almost all the code is infested with unnecessary, redundant abstractions and all the dependencies (except the ones used by GHC) are fucking over-abstracted crap (yes, one has to actually learn math before touching Haskell).</p>
<p>And last, but not least, please kindly fuck off, you fucking narcissistic POS  HN impostors.</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://lngnmn2.github.io/tags/ai/">AI</a></li>
      <li><a href="https://lngnmn2.github.io/tags/llm/">LLM</a></li>
      <li><a href="https://lngnmn2.github.io/tags/bullshit/">Bullshit</a></li>
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2026 <a href="https://lngnmn2.github.io/">Notes from the digital underground by Lngnmn</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu');
    if (menu) {
        
        const scrollPosition = localStorage.getItem("menu-scroll-position");
        if (scrollPosition) {
            menu.scrollLeft = parseInt(scrollPosition, 10);
        }
        
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        const html = document.querySelector("html");
        if (html.dataset.theme === "dark") {
            html.dataset.theme = 'light';
            localStorage.setItem("pref-theme", 'light');
        } else {
            html.dataset.theme = 'dark';
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
