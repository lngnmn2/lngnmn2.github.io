<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Another top HN post | Notes from the digital underground by Lngnmn</title>
<meta name="keywords" content="ADT">
<meta name="description" content="  The &#34;philosophy&#34; as a form of an abstract bullshitting
  ">
<meta name="author" content="&amp;lt;lngnmn2@yahoo.com&amp;gt;">
<link rel="canonical" href="https://lngnmn2.github.io/articles/philosophy-of-programming/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.d0049500090a8b5b522a30f4bc70f815df41595125d25503dff47281216974cb.css" integrity="sha256-0ASVAAkKi1tSKjD0vHD4Fd9BWVEl0lUD3/RygSFpdMs=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://lngnmn2.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://lngnmn2.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://lngnmn2.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://lngnmn2.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://lngnmn2.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://lngnmn2.github.io/articles/philosophy-of-programming/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Source+Code+Pro:wght@300&display=swap" rel="stylesheet">
<link href="https://fonts.googleapis.com/css2?family=Noto+Sans:wght@300&display=swap" rel="stylesheet">
<link href="https://fonts.googleapis.com/css2?family=Noto+Serif:wght@300&display=swap" rel="stylesheet">
<style>
font-family: 'Noto Serif', serif;
font-family: 'Noto Sans', sans-serif;
font-family: 'Source Code Pro', monospace;
</style>
<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script type="text/javascript" id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script><meta property="og:url" content="https://lngnmn2.github.io/articles/philosophy-of-programming/">
  <meta property="og:site_name" content="Notes from the digital underground by Lngnmn">
  <meta property="og:title" content="Another top HN post">
  <meta property="og:description" content="  The &#34;philosophy&#34; as a form of an abstract bullshitting
  ">
  <meta property="og:locale" content="en-us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="articles">
    <meta property="article:published_time" content="2025-08-31T00:00:00+05:45">
    <meta property="article:modified_time" content="2025-08-31T14:32:40+05:45">
    <meta property="article:tag" content="ADT">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Another top HN post">
<meta name="twitter:description" content="  The &#34;philosophy&#34; as a form of an abstract bullshitting
  ">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Articles",
      "item": "https://lngnmn2.github.io/articles/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Another top HN post",
      "item": "https://lngnmn2.github.io/articles/philosophy-of-programming/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Another top HN post",
  "name": "Another top HN post",
  "description": "  The \"philosophy\" as a form of an abstract bullshitting\n  ",
  "keywords": [
    "ADT"
  ],
  "articleBody": "Look, ma, another top HN post in the “heavily policed safe space for mediocrity” – https://news.ycombinator.com/item?id=45074248. They are babbling about some “philosophy of programming”, at least about how they think it should be.\nWell, even before the Atlas Shrugged there were “two kinds of philosophers” – ones which could see (and explain) things as they [really] are, and those who mastered the art of sophistry and abstract bullshitting, and can explain things as they want them to be. The laterr, by the way, call this ability a “creativity” (the word-marker of midwit), and the whole shitshow – a “philosophy”.\nThe proper philosophy, however, is trying to answer just one question: What Is? and, for each sub-question about this or that particular aspect of “What Is” – Why things are the way they are?\nThere is a fundamental principle which unitedly and justify the whole endeavor: Most of things are the way they are, because this is the only way they can be – a “fixed-point” has been reached by endless evolutionary trials-and-errors which selects the most stable (and most of the time – energy efficient) intermediate forms/ among wast number of possible ones. This is how Nature works (Is), and this is how the things are in the human (social) world as well.\nThis, in turn, captures the abstract (but non-bullshit) notions of perfection (nothing more to take away or optimize) and quality (a measure of how close to perfection a thing is), and of elegance and even of a beauty (which is lack of non-uniformity and ugliness – deformities and asymmetry in general .\nIn Biology, the perfection is the state of being optimal for a given purpose (subject to the “physical” constraints of the environment), and the quality is the degree of closeness to this optimal state. The optimal state is the one which is most stable and most energy efficient for a given purpose. Unsurprisingly, these are also the hallmarks of excellence in human’s engineering and design.\nAnd this, by the way, justifies and explains the “elegance is not optional” [rare, non-bullshit] CS maxim.\nAgain, mere joggling with abstraction and sophisticated handwaving is not a “philosophy”, but sophistry and socially constructed bullshit.\nTo understand the world (and thus to master programming, which is the only /way) one has to master mathematics (which is a study of properly captured, and abstracted out generalized notions, “objects” and their properties ) and biology (which are stable-enough (to reproduce), vastly complex systems which spontaneity emerged from the continuous “shuffling” of the atoms in a particularly consrained physical environment).\nSince the DNA and the composition of 20 base amino acids has been discovered and the underlying principles have been intuitively understood, smart people realized that not all arrangements of atoms (or amino acids) are “equal”. Moreover, some mathematician, but mostly computer scientists intuitively realized that there are “universal” arrangements, such as sequences, trees, DAGs and lookup tables.\nThe early LISP tradition and then the MIT Scheme sheism were the first attempts to capture this intuition and the uniformity of the underlying structures as the essence of programming. LISP culture was focused mostly on the “forms” of the data and on the uniform structure which unduly both the code and data, even to the claim that they are the same forms (just like in biology, enzymes and the structural proteins they made and transform are made of the same chained amino acids).\nThe early FP tradition (ML, Miranda, Haskell) was focused on the mathematical properties of the functions and their composition, and on the “purity” of the functions, and less about the data structures, postulating that “lists” are good-enough for everyting, to the extent to develop a special syntax for constructing manipulating them.\nThe beginning of the non-bullshit “philosophy” of programming is this realization that just a few carefully selected “forms” are “enough for everything”. It is “the same” (in principle) in math, logic, biology and CS.\nWhy is this so? (which is an intermediate non-bullshit philosophy, if you will). Because the “forms” are the “fixed points” of not just the evolutionary process, but of the “captures” of the underlying universal notions of what shaped the Universe itself (and no, it is not “numbers” or even “lines”), which are stable and energy efficient. The “forms” are the “optimal” arrangements of the atoms (or amino acids) for a given purpose, and thus they are the most likely to re-emerge and persist.\nBoth, Nature’s biology and human’s mathematics and CS, are trying to rely on and capture these “forms” and their properties, and to use them to build more complex structures (organisms or programs) which are also stable and “energy efficient”. This is the very beginning of the non-bullshit “philosophy” of programming.\nThere is a lot more to it, of course, but nothing is abstract bullshit or socially accepted handwaving. Everything is grounded in, an can be (and must be) traced back to “What Is” and “Why things are the way they are”.\nAt a higher level, above “the primitives” there are what we call “patterns”, which re-emerge again and again at all levels. It is the intuitive understanding of these recurring patterns which gave rise to the “SICP” sub-culture, being a bit of a premature ejaculation, if you ask me, but in the right direction. The more sane and systematic approach was of Barbara Liskov and her “data abstraction” and “abstract data types”, which are better, proper “captures” of the universal patterns, but the popular culture have chosen the SICP.\nThe universal principles captured so far: “the stable intermediate forms at all levels”, “the hierarchical, layered structure of complexity”, “the necessary (required) one-to-one correspondence between the inherent layered structure of complexity and the layered structure of the code which is trying properly capture and mathematically model it”.\nThis has been intuitively understood and “emerged” in the structure of standard libraries of the classic programming languages, such as early LISPs (even before Common Lisp), SML (even before Ocaml) and R5RS Scheme (which is, again, neglected modules and proper ADTs due to way too much excitement). All the universal data forms (sequences, trees, DAGs, hash tables) are there, and the standard libraries are layered to reflect the inherent layered structure of complexity of the universal problems they are trying to solve. This is, of course, not a random coincidence.\nAnother level up – Abstract Data Types, [proper] Abstraction Barriers and Abstract Interfaces. The underlying universal notions is of “partitioning” and of “nesting” – of cell membranes, “tubes”, whole organs, specialized tissues.\nAt the levels of sub-systems and systems, the universal notions are of “separation of concerns”, “encapsulation”, “modularity”, “hierarchical layering” and necessary “signaling” and communication “emerge”. There are essentially two kinds of signalling – electrical, via “wires”, and chemical, via “structured messages” (or “packets”). The former is fast, but requires a lot of energy and is not very flexible. The latter is slow, but is very energy efficient and very flexible.\nIt is not a random coincidence that Internet is packet-based message-passing. The smartest guys behind Erlang intuitively understood these aspects – a proper isolation (partitioning) and structural, without any hidden imperative state message-passing.\nNotice that even if we are going higher in an abstraction hierarchies, everything can be traced back to What Is, and this is what constitutes a non-bullshit “philosophy” of programming.\nLots of seemingly difficult questions can be answered in this way, without any abstract handwaving and sophistry. Why immutable data is necessary? Because it is the only way to have a stable intermediate form which can be shared without unintended side-effects. Why pure functions are necessary? Because they are the only way to have a stable intermediate form of computation which can be reasoned about mathematically, and thus can be composed into more complex forms.\nWhy “imperative shared state” is must be avoided (and if cannot - clearly separated behind an impenetrable abstraction barrier, like of a Monad)? Because this is the only way to properly capture the inherently stateful nature of the real world, but it must be properly isolated and encapsulated to prevent unintended side-effects.\nWhy “proper, total process isolation” is necessary? Because it is the only way to capture the inherently concurrent nature of the real world, but it must be properly isolated and encapsulated to prevent unintended side-effects.\nThe languages based on discrete mathematics, researched by math majors (and sometimes physicists) have just a few carefully selected “means” to properly capture the complexity of the real world into a layered, partitioned systems, which mimics the underlying structure of complexity, using just a few “universal forms” (sequences, trees, DAGs, hash tables) and a few “universal operations” (composition, recursion, higher-order functions, pattern-matching).\nAt a higher level, where the patterns emerge, the principles outlined by Michael Jacson and Barbara Liskov – abstraction by parameterization, abstraction barriers, abstract data types, separation of concerns, modularity, hierarchical layering, proper signaling and communication – are the “means” to structure the solution.\nParameterization is universal –it is not just functions, but also Algebraic Data Types (ADTs, generic types) and whole modules (functors).\nAbstraction barriers and abstract data types are universal – they are the only way to properly capture the inherently stateful nature of the real world, but they must be implemented (and passed around as) immutable, and thus state-less structured data bindings, to prevent unintended side-effects.\nSeparation of concerns, modularity and hierarchical layering are universal, and re-emerge at all levels of complexity.\nAt the highest and the most abstract level, Algebraic Data Types, and Composable High-level, State-less Abstract Interfaces (Iterators and other declarative abstractions) are the “high-level building blocks”. This is the essence of the proper “philosophy” of programming, and everything else is just a socially constructed bullshit.\nNow a few examples: WhatApp as an Erlang server-side application, built by just a 10 or so smart guys. Clojure, which was bold-enough to actually rely on immutable data structures (and crappy imperative loops). And, especially, Haskell, which is still an executable system of a high-order pure logic (System F Omega), augmented with advanced types and properly captured abstractions built on top of the universal forms and operations.\nEverything can be traced back to “What Is” and “Why things are the way they are”, and nothing here is an abstract handwaving and sophistry.\nAnd, of course, the whole “AI” bullshit (at the level of mere and only syntactic forms, without any underlying understanding whatsoever) is just a desperate attempt to avoid the hard work of properly capturing the complexity of the real world into a layered, partitioned systems, which mimics the underlying structure of complexity, using just a few “universal forms” (sequences, trees, DAGs, hash tables) and a few “universal operations” (composition, recursion, higher-order functions, pattern-matching).\nAnd yes, the “cognitive load” builds up as the direct consequence of, and along with the unnecessary, redundant absrations, mismatching in the one-to-one correspondence betwen the layers and individual concepts of the problem domain and their representation at the same highest possible level of abstraction in the code, and using any form of an stateful imperative crap. This, except the fact that imperative crap cannot cognitively scaled in principle (it will inevitably collapse under its weight, just like any large-enough abstract bullshitting), has been well-understood all the way back in the Golden Age of Programming 1970s , 1980s and the early 1990s).\nYes, it is possible to build a very large stable system, such as Google Chrome in C++ (a whole bullshit ideology being actually implemented in an vastly complex, inherently buggy imperative code), but it requires billions of paid man-hours through decades of effort.\n",
  "wordCount" : "1924",
  "inLanguage": "en",
  "datePublished": "2025-08-31T00:00:00+05:45",
  "dateModified": "2025-08-31T14:32:40+05:45",
  "author":[{
    "@type": "Person",
    "name": "\u0026lt;lngnmn2@yahoo.com\u0026gt;"
  }],
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://lngnmn2.github.io/articles/philosophy-of-programming/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Notes from the digital underground by Lngnmn",
    "logo": {
      "@type": "ImageObject",
      "url": "https://lngnmn2.github.io/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://lngnmn2.github.io/" accesskey="h" title="Notes from the digital underground by Lngnmn (Alt + H)">Notes from the digital underground by Lngnmn</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://lngnmn2.github.io/about/" title="About me.">
                    <span>About me.</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title entry-hint-parent">
      Another top HN post
    </h1>
    <div class="post-description">
        The &#34;philosophy&#34; as a form of an abstract bullshitting
  
    </div>
    <div class="post-meta"><span title='2025-08-31 00:00:00 +0545 +0545'>August 31, 2025</span>&nbsp;·&nbsp;<span>&amp;lt;lngnmn2@yahoo.com&amp;gt;</span>

</div>
  </header> 
  <div class="post-content"><p>Look, ma, another top HN post in the &ldquo;heavily policed safe space for mediocrity&rdquo; &ndash; <a href="https://news.ycombinator.com/item?id=45074248">https://news.ycombinator.com/item?id=45074248</a>. They are babbling about some &ldquo;philosophy of programming&rdquo;, at least about how they think it should be.</p>
<p>Well, even before the <em>Atlas Shrugged</em> there were &ldquo;two kinds of philosophers&rdquo;  &ndash; ones which could <em>see (and explain) things as they [really] are</em>, and those who mastered the art of sophistry and abstract bullshitting, and can <em>explain things as they want them to be</em>. The laterr, by the way, call this ability a &ldquo;creativity&rdquo; (the word-marker of  midwit), and the whole shitshow &ndash; a &ldquo;philosophy&rdquo;.</p>
<p>The proper philosophy, however, is trying to answer just one question: <em>What Is?</em> and, for each sub-question about this or that particular aspect of &ldquo;What Is&rdquo; &ndash;  <em>Why things are the way they are?</em></p>
<p>There is a fundamental principle which unitedly and justify the whole endeavor: <em>Most of things are the way they are, because this is the only way they can be</em> &ndash; a &ldquo;fixed-point&rdquo; has been reached by endless evolutionary trials-and-errors which selects  the most stable (and most of the time &ndash; energy efficient)  intermediate forms/ among wast number of possible ones. This is how Nature works (Is), and this is how the things are in the human (social) world as well.</p>
<p>This, in turn, captures the abstract (but non-bullshit) notions of perfection (nothing more to take away or optimize) and quality (a measure of how close to perfection a thing is), and of <em>elegance</em> and even of a <em>beauty</em> (which is lack of non-uniformity and ugliness &ndash; deformities and asymmetry in general .</p>
<p>In Biology, the perfection is the state of being optimal for a given purpose (subject to the &ldquo;physical&rdquo; constraints of the environment), and the quality is the degree of closeness to this optimal state. The optimal state is the one which is most stable and most energy efficient for a given purpose.  Unsurprisingly, these are also the hallmarks of excellence in human&rsquo;s engineering and design.</p>
<p>And this, by the way, justifies and explains the &ldquo;elegance is not optional&rdquo; [rare, non-bullshit] CS maxim.</p>
<p>Again, mere joggling with abstraction and sophisticated handwaving is not a &ldquo;philosophy&rdquo;, but sophistry and socially constructed bullshit.</p>
<p>To understand the world (and thus to master programming, which is <em>the only /way</em>) one has to master mathematics (which is a study of properly captured, and abstracted out generalized notions, &ldquo;objects&rdquo; and their properties ) and biology (which are stable-enough (to reproduce), vastly complex systems which spontaneity emerged from the continuous &ldquo;shuffling&rdquo; of the atoms in a particularly consrained physical environment).</p>
<p>Since the DNA and the composition of 20 base amino acids has been discovered and the underlying principles have been intuitively understood, smart people realized that not all arrangements of atoms (or amino acids) are &ldquo;equal&rdquo;. Moreover, some mathematician, but mostly computer scientists intuitively realized that there are &ldquo;universal&rdquo; arrangements, such as sequences, trees, DAGs and lookup tables.</p>
<p>The early LISP tradition and then the MIT Scheme sheism were the first attempts to capture this intuition and the uniformity of the underlying structures as the essence of programming. LISP culture was focused mostly on the &ldquo;forms&rdquo; of the data and on the <em>uniform structure</em> which unduly both  the code and data, even to the claim that they are the same forms (just like in biology, enzymes and the structural proteins they made and transform are made of the same <em>chained</em> amino acids).</p>
<p>The early FP tradition (ML, Miranda, Haskell) was focused on the mathematical properties of the functions and their composition, and on the &ldquo;purity&rdquo; of the functions, and less about the data structures, postulating that &ldquo;lists&rdquo; are good-enough for everyting, to the extent to develop  a special syntax for constructing manipulating them.</p>
<p>The beginning of the non-bullshit &ldquo;philosophy&rdquo; of programming is this realization that just a few carefully selected &ldquo;forms&rdquo; are &ldquo;enough for everything&rdquo;. It is &ldquo;the same&rdquo; (in principle) in math, logic, biology and CS.</p>
<p>Why is this so? (which is  an intermediate non-bullshit philosophy, if you will). Because the &ldquo;forms&rdquo; are the &ldquo;fixed points&rdquo; of not just the evolutionary process, but of the &ldquo;captures&rdquo; of the underlying universal notions of what shaped the Universe itself (and no, it is not &ldquo;numbers&rdquo; or even &ldquo;lines&rdquo;), which are stable and energy efficient. The &ldquo;forms&rdquo; are the &ldquo;optimal&rdquo; arrangements of the atoms (or amino acids) for a given purpose, and thus they are the most likely to re-emerge and persist.</p>
<p>Both, Nature&rsquo;s biology and human&rsquo;s mathematics and CS, are trying to rely on and <em>capture</em> these &ldquo;forms&rdquo; and their properties, and to use them to build more complex structures (organisms or programs) which are also stable and &ldquo;energy efficient&rdquo;. This is the very beginning of the non-bullshit &ldquo;philosophy&rdquo; of programming.</p>
<p>There is a lot more to it, of course, but nothing is abstract bullshit or socially accepted handwaving. Everything is grounded in, an can be (and must be) traced back to &ldquo;What Is&rdquo; and &ldquo;Why things are the way they are&rdquo;.</p>
<p>At a higher level, above &ldquo;the primitives&rdquo; there are what we call &ldquo;patterns&rdquo;, which re-emerge again and again at all levels. It is the intuitive understanding of these recurring patterns which gave rise to the &ldquo;SICP&rdquo; sub-culture, being a bit of a premature ejaculation, if you ask me, but in the right direction. The more sane and systematic approach was of Barbara Liskov and her &ldquo;data abstraction&rdquo; and &ldquo;abstract data types&rdquo;, which are better, proper &ldquo;captures&rdquo; of the universal patterns, but the popular culture have chosen the SICP.</p>
<p>The universal principles captured so far: &ldquo;the stable intermediate forms at all levels&rdquo;, &ldquo;the hierarchical, layered structure of complexity&rdquo;,  &ldquo;the necessary (required) one-to-one correspondence between the inherent layered structure  of complexity and the layered structure of the code which is trying properly capture and mathematically model it&rdquo;.</p>
<p>This has been intuitively understood and &ldquo;emerged&rdquo; in the structure of standard libraries of the classic programming languages, such as early LISPs (even before Common Lisp), SML (even before Ocaml) and R5RS Scheme (which is, again, neglected modules and proper ADTs due to way too much excitement). All the universal data forms (sequences, trees, DAGs, hash tables) are there, and the standard libraries are layered to reflect the inherent layered structure of complexity of the universal problems they are trying to solve. This is, of course, not a random coincidence.</p>
<p>Another level up &ndash; Abstract Data Types, [proper] Abstraction Barriers  and Abstract Interfaces. The underlying universal notions is of &ldquo;partitioning&rdquo; and of &ldquo;nesting&rdquo; &ndash; of cell membranes, &ldquo;tubes&rdquo;,  whole organs, specialized tissues.</p>
<p>At the levels of sub-systems and systems, the universal notions are of &ldquo;separation of concerns&rdquo;, &ldquo;encapsulation&rdquo;, &ldquo;modularity&rdquo;, &ldquo;hierarchical layering&rdquo; and necessary &ldquo;signaling&rdquo; and communication &ldquo;emerge&rdquo;. There are essentially two kinds of signalling &ndash; electrical, via &ldquo;wires&rdquo;, and chemical, via &ldquo;structured messages&rdquo; (or &ldquo;packets&rdquo;). The former is fast, but requires a lot of energy and is not very flexible. The latter is slow, but is very energy efficient and very flexible.</p>
<p>It is not a random coincidence that Internet is packet-based message-passing. The smartest guys behind Erlang intuitively understood these aspects &ndash; a proper isolation (partitioning) and structural, without any hidden imperative state message-passing.</p>
<p>Notice that even if we are going higher in an abstraction hierarchies, everything can be traced back to What Is, and <em>this</em> is what constitutes a non-bullshit &ldquo;philosophy&rdquo; of programming.</p>
<p>Lots of seemingly difficult questions can be answered in this way, without any abstract handwaving and sophistry.  Why immutable data is <em>necessary</em>? Because it is the only way to have a stable intermediate form which can be shared without unintended side-effects. Why pure functions are <em>necessary</em>? Because they are the only way to have a stable intermediate form of computation which can be reasoned about mathematically, and thus can be composed into more complex forms.</p>
<p>Why &ldquo;imperative shared state&rdquo; is <em>must be avoided</em> (and if cannot - clearly separated behind an impenetrable abstraction barrier, like of a Monad)? Because this is the only way to <em>properly</em>  capture the inherently stateful nature of the real world, but it must be properly isolated and encapsulated to prevent unintended side-effects.</p>
<p>Why &ldquo;proper, total process isolation&rdquo; is <em>necessary</em>? Because it is the only way to capture the inherently concurrent nature of the real world, but it must be properly isolated and encapsulated to prevent unintended side-effects.</p>
<p>The languages based on discrete mathematics, researched by math majors (and sometimes physicists) have just a few carefully selected &ldquo;means&rdquo; to properly capture the complexity of the real world into a layered, partitioned systems,  which mimics the underlying structure of complexity, using just a few &ldquo;universal forms&rdquo; (sequences, trees, DAGs, hash tables) and a few &ldquo;universal operations&rdquo; (composition, recursion, higher-order functions, pattern-matching).</p>
<p>At a higher level, where the patterns emerge, the principles outlined by Michael Jacson and Barbara Liskov &ndash; abstraction by parameterization, abstraction barriers, abstract data types, separation of concerns, modularity, hierarchical layering, proper signaling and communication &ndash; are the &ldquo;means&rdquo; to structure the solution.</p>
<p>Parameterization is universal &ndash;it is not just functions, but also Algebraic Data  Types (ADTs, generic types) and whole modules (functors).</p>
<p>Abstraction barriers and abstract data types are universal &ndash; they are the only way to properly capture the inherently stateful nature of the real world, but they must be implemented (and passed around as)  immutable, and thus state-less structured data bindings, to prevent unintended side-effects.</p>
<p>Separation of concerns, modularity and hierarchical layering are universal, and re-emerge at all levels of complexity.</p>
<p>At the highest and the most abstract level, Algebraic Data Types, and Composable High-level, State-less Abstract Interfaces (Iterators and other declarative abstractions) are the  &ldquo;high-level building blocks&rdquo;. This is the essence of the proper &ldquo;philosophy&rdquo; of programming, and everything else is just a socially constructed bullshit.</p>
<p>Now a few examples: WhatApp as an Erlang server-side application, built by just a 10 or so smart guys. Clojure, which was bold-enough to actually rely on immutable data structures (and crappy imperative loops).  And, especially, Haskell, which is still an <em>executable system of a high-order pure logic</em> (System F Omega), augmented with advanced types and properly captured abstractions built on top of the universal forms and operations.</p>
<p>Everything can be traced back to &ldquo;What Is&rdquo; and &ldquo;Why things are the way they are&rdquo;, and nothing here is an abstract handwaving and sophistry.</p>
<p>And, of course, the whole &ldquo;AI&rdquo; bullshit (at the level of mere and only syntactic forms, without any underlying understanding whatsoever) is just a desperate attempt to avoid the hard work of properly capturing the complexity of the real world into a layered, partitioned systems,  which mimics the underlying structure of complexity, using just a few &ldquo;universal forms&rdquo; (sequences, trees, DAGs, hash tables) and a few &ldquo;universal operations&rdquo; (composition, recursion, higher-order functions, pattern-matching).</p>
<p>And yes, the &ldquo;cognitive load&rdquo; builds up as the direct consequence of, and  along with the unnecessary, redundant absrations, mismatching in the  one-to-one correspondence betwen the layers and  individual concepts of the problem domain and their representation at <em>the same highest possible level of abstraction</em> in the code, and using any form of an stateful imperative crap. This, except the fact that imperative crap cannot cognitively scaled in principle (it will inevitably collapse under its weight, just like any large-enough abstract bullshitting), has been well-understood all the way back in the Golden Age of Programming 1970s , 1980s and the early 1990s).</p>
<p>Yes, it is possible to build a very large stable system, such as Google Chrome in C++ (a whole bullshit ideology being actually implemented in an vastly complex, inherently buggy imperative code), but it requires billions of paid man-hours through decades of effort.</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://lngnmn2.github.io/tags/adt/">ADT</a></li>
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="https://lngnmn2.github.io/">Notes from the digital underground by Lngnmn</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
