<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Yes, it is time to scream and  panic | Notes from the digital underground by Lngnmn</title>
<meta name="keywords" content="programmign, AI, LLM, coding">
<meta name="description" content="Sometimes not getting what you what is itself a biggest strike of luck.">
<meta name="author" content="&amp;lt;lngnmn2@yahoo.com&amp;gt;">
<link rel="canonical" href="https://lngnmn2.github.io/articles/the-very-serious-post/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.8fe10233a706bc87f2e08b3cf97b8bd4c0a80f10675a143675d59212121037c0.css" integrity="sha256-j&#43;ECM6cGvIfy4Is8&#43;XuL1MCoDxBnWhQ2ddWSEhIQN8A=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://lngnmn2.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://lngnmn2.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://lngnmn2.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://lngnmn2.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://lngnmn2.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://lngnmn2.github.io/articles/the-very-serious-post/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Source+Code+Pro:wght@300&display=swap" rel="stylesheet">
<link href="https://fonts.googleapis.com/css2?family=Noto+Sans:wght@300&display=swap" rel="stylesheet">
<link href="https://fonts.googleapis.com/css2?family=Noto+Serif:wght@300&display=swap" rel="stylesheet">
<style>
font-family: 'Noto Serif', serif;
font-family: 'Noto Sans', sans-serif;
font-family: 'Source Code Pro', monospace;
</style>
<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script type="text/javascript" id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script><meta property="og:url" content="https://lngnmn2.github.io/articles/the-very-serious-post/">
  <meta property="og:site_name" content="Notes from the digital underground by Lngnmn">
  <meta property="og:title" content="Yes, it is time to scream and  panic">
  <meta property="og:description" content="Sometimes not getting what you what is itself a biggest strike of luck.">
  <meta property="og:locale" content="en-us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="articles">
    <meta property="article:published_time" content="2025-06-12T00:00:00+05:45">
    <meta property="article:modified_time" content="2025-06-12T14:15:57+05:45">
    <meta property="article:tag" content="Programmign">
    <meta property="article:tag" content="AI">
    <meta property="article:tag" content="LLM">
    <meta property="article:tag" content="Coding">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Yes, it is time to scream and  panic">
<meta name="twitter:description" content="Sometimes not getting what you what is itself a biggest strike of luck.">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Articles",
      "item": "https://lngnmn2.github.io/articles/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Yes, it is time to scream and  panic",
      "item": "https://lngnmn2.github.io/articles/the-very-serious-post/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Yes, it is time to scream and  panic",
  "name": "Yes, it is time to scream and  panic",
  "description": "Sometimes not getting what you what is itself a biggest strike of luck.",
  "keywords": [
    "programmign", "AI", "LLM", "coding"
  ],
  "articleBody": "There is something to be actually realized as soon as possible (which I recently experienced directly) –the condition-probability-based “glorified autocomplete” could generate some small pieces of code (with intelligent prompting) that simply above (in intrinsic quality) 90% of all the related crap that could be found on Github, which easily extrapolates to 90% of people in existence who identify themselves as “programmers”. Peirod.\nThe code will be better than high-dopamine, “laser-focused” (on Prozac), but not so well-educated on fundamentals zealots could produce. Better than inexperienced in realities of the actual open-source software ecosystems academics could even hope to write, no matter how good their theoretical understanding is. With very specific and properly constrained prompting, which takes into account the major results of the last 50-or-60 years of PL and CS research, especially in the field of math-based Functional Programming and Immutable Data Structures, one can get almost optimal (approaching perfection small pieces of code, provided you understand what theoretical-limited perfection actually looks like in this particular case, and why.\nThe code that just uses well-understood and familiar mathematical concepts is the obvious “case study”. It can spew out stuff which is on-par with Haskell or Ocaml/SML or Scala3 standard libraries, that took decades to evolve from a serious reseach in abstract algebra structures and non-bullshit semantics-based, FP-centered PL theory, along with years-and-years of trials-and-errors at the implementation side. (No webshit or async crap, of course. the garbage in – garbage out principle shines like the moon).\nThis fact renders subpar “programmers”, the ones who lack the necessary deep understanding of what they are doing and why (which goes all the way back, via CS and its underlying mathematics, via the fundamental abstractions, via universal reccuring patterns, back to What Is) which call themselves [correctly] [mere] “coders”. They are already obsolete as “computers” of the ancient past – the people who memorize and apply mathematical formulas to calculate stuff for rich people. Obsolete as “translators” – the people who memorized the rules of two languages and can “interpret” between them using pen and paper, and so on. Film-based photoshops and mechanical topographies also come to mind. It is actually over, no more two more weeks.\nAgain, we do not talk here about webshit or async crap. We are talking about Algebraic Data Types, proper non-leaking ADTs, modern advanced static-typing with proper sum-types, Domain-Driven and Test-Driven development, rigorous formal modeling in pure-functional languages (or the pure subsets of good , math-based languages) and stuff like that, when normies would ask “Where is the code?” Yes, all serious, non bullshit Computer Science itself , indeed, converges to just a few “things” like Algebraic Types, ADTs , Abstraction and Specification (as per Barbara Liskov) and augmented with advanced types The Lambda Calculus, and the algebraic structure which arise [back] from the dots-between-arrows of functional composition. Remember that everything has already been solved the golden age of CS, which culminated, via Scheme, SML, and Miranda, in the Haskell 98 report and the last good things like Clojure or Scala ot Hasell 2010 were just direct consequences – application of the accumulated math-base theoretical knowledge.\nYes, yes. strong claims, so lets unpack a little.\nThere actually exist, such things as an optimal pieces of code – the individual code blocks that approach a limit of perfection – simply because there are such thing as Universe (Objective Reality or What Is). There is literally nothing to remove, simplify or clarify (or otherwise significantly improve) in, say, a pure functionallibrary code which use a generalizes ADT for sequences. Just because a sequence is a properly generalized abstraction from What Is (there is a “reason” why mRNA is a sequence – this is a minimal (not just in terms of “stuff being used”, but “in a universal priniple”), good-enough, and thus “optimal” structure), so the code which has been abstracted over a proper tail-recursive fold (which uses the accumulator pattern) and thus the code pays an inevitable price of an extra reverse (which is also defined in terms of fold), that implicitly uses a Monoidal Functorial abduct algebraic structure of a sequence (again, abstracted out from What Is), which the best guys like Bartosz, have been studied for years and years, cannot be improved any further in principle.\nThe same could be said about pre-sorted or otherwise constrained tree-like structures, tables and some directed acyclic graphs (which, again, are proper captures of some aspects of What Is), which are (for exactly the same reasons) are good-enough for everything (and yes, there is a non-commutative monoidal structure which underly your [GPU-executed] Linear Algebra for AI, and even in the weighted sums, which actually underly all your silly probabilistic models, because the very notion of a weighted sum [of the causal factors] is a universal concept. which, in turn, partially captures the Causality itself).\nThus, a proper fixed-point-like process has converged to a global optimum (at least for sequences) with respect to a “good-enough epsilon” of an implementation constraints. The code retains the fundamental referential transparency property, with all the nice things – direct corollaries from being math or logic –follow. By the way, non-bullshit “math and logic” are also grounded in the very same What Is.\nTo understand and to be able to realize such things people spent decades of studying and reading. To come up with an actual code requires years before one could formulate all the constraints and representation invariant clearly, taking into account the underlying algebraic structure and the facts that there is “nothing more out there” to it. (The fact that one could “construct” way more abstract purely theoretical crap like latices or full Categories is irrelevant, and should point to a the threshold of crossing from abstractions captured from Reality into the realm of a rigorous abstract delirium).\nAnd now such code (for prototyping purposes) can be generated in seconds. Seconds. Orders of magnitude change in “productivity”. Yes, one has to understand some concepts (here, there) before putting them into a prompt as explicit constraints and requirements, but prompts can be just copied, collected from the inputs of other people, who will even pay you from the privilege (hi, big tech) and then sold for profit and reused.\nThe years of education in a proper non-bullshit tech school like MIT (one can study by oneself on their study materials and courses) will not (and never) be wasted, but the 100k of financial debt probably won’t be repaid so easy.\nAmazingly (or rather as an direct corollary or even implication from how it actually works) it cannot fix technical debts, which, again, is just a poilite name for stupid and lame early decisions. So no GPT will fix piles of crap like WinAPI or Ethereum (lmao), but with rapid prototyping (that avoids imperative crap) from the first principles, with focusing on the proper fundamentals of CS (yes, there are such things – principles the principles which connect properly captured abstractions, back to What Is) prototyping of way better things can be done at a tiny fraction of costs and manpower. I shut you not.\nConversely, it cannot just generate any actually novel solutions, like yet another crapto, with the proper algebraic structures to underly the almost optimal chain implementation (it is just trees, not even graphs, with an additional constraint of the consistent nested hashes ), and with the G-Machine (which implements the Haskell evaluation strategy) as its runtime and the smallest possible superset of the some typed lambda calculus, not even required to be as general as the System F Omega (what else could possible be better suited for so called “smart contracts”) – the thing at which Cardano and Charles (with all the hired academic super stars) have spectacularly failed (and things that narcissistic and arrogant, fountaining with bullshit vitaliks could not even begin to understand), simply because there is not enough or no training data for G-Machines and properly constrained trees.\nSo, by now , with this generative technology literally everywhere in a massive bubble, we ought have already been literally flooded with all kinds of actually useful and well-designed, properly implemented software for all domains and problems imaginable , but we aren’t , because there is no demand. The real demand is to keep the old crap work and maybe little changes here and there, no one really wants anything new (due to the bias of complexity and really high costs).\nIf you are “in the IT field” and have any difficulty to comprehend and understand this simple article, which I wrote on a whim in one sitting without any “assistants”, it is time to panic.\n",
  "wordCount" : "1434",
  "inLanguage": "en",
  "datePublished": "2025-06-12T00:00:00+05:45",
  "dateModified": "2025-06-12T14:15:57+05:45",
  "author":[{
    "@type": "Person",
    "name": "\u0026lt;lngnmn2@yahoo.com\u0026gt;"
  }],
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://lngnmn2.github.io/articles/the-very-serious-post/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Notes from the digital underground by Lngnmn",
    "logo": {
      "@type": "ImageObject",
      "url": "https://lngnmn2.github.io/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://lngnmn2.github.io/" accesskey="h" title="Notes from the digital underground by Lngnmn (Alt + H)">Notes from the digital underground by Lngnmn</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://lngnmn2.github.io/about/" title="About me.">
                    <span>About me.</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title entry-hint-parent">
      Yes, it is time to scream and  panic
    </h1>
    <div class="post-description">
      Sometimes not getting what you what is itself a biggest strike of luck.
    </div>
    <div class="post-meta"><span title='2025-06-12 00:00:00 +0545 +0545'>June 12, 2025</span>&nbsp;·&nbsp;&amp;lt;lngnmn2@yahoo.com&amp;gt;

</div>
  </header> 
  <div class="post-content"><p>There is something to be actually realized as soon as possible (which I recently experienced directly) &ndash;the <em>condition-probability-based &ldquo;glorified autocomplete&rdquo;</em> could generate some small pieces of code (with intelligent prompting) that simply above (in intrinsic quality) 90% of all the related crap that could be  found on Github, which easily extrapolates to 90% of people in existence who identify themselves as &ldquo;programmers&rdquo;. Peirod.</p>
<p>The code will be better than high-dopamine, &ldquo;laser-focused&rdquo; (on Prozac), but not so well-educated on fundamentals <em>zealots</em> could produce. Better than inexperienced in realities of the actual open-source software ecosystems academics could even hope to write, no matter how good their theoretical understanding is. With very specific and properly constrained prompting, which takes into account the major results of the last 50-or-60 years of PL and CS research, especially in the field of math-based Functional Programming and Immutable Data Structures, one can get <em>almost optimal (approaching perfection</em> small pieces of code, provided you <em>understand</em> what theoretical-limited perfection actually looks like in this particular case, <em>and why</em>.</p>
<p>The code that just uses well-understood and familiar mathematical concepts is the obvious &ldquo;case study&rdquo;. It can spew out stuff which is on-par with Haskell or Ocaml/SML or Scala3 standard libraries, that took decades to evolve from a serious reseach in abstract algebra structures and non-bullshit semantics-based, FP-centered  PL theory,  along with years-and-years of trials-and-errors at the implementation side. (No webshit or async crap, of course. the garbage in &ndash; garbage out principle shines like the moon).</p>
<p>This fact renders subpar &ldquo;programmers&rdquo;, the ones who lack the <em>necessary</em> deep understanding of what they are doing and <em>why</em> (which goes all the way back, via CS and its underlying mathematics, via the fundamental abstractions, via universal reccuring patterns, back to <em>What Is</em>) which call themselves  [correctly] [mere] &ldquo;coders&rdquo;. They <em>are already</em> obsolete as &ldquo;computers&rdquo;  of the ancient past &ndash; the people who memorize and apply mathematical formulas to calculate stuff for rich people. Obsolete as &ldquo;translators&rdquo; &ndash; the people who memorized the rules of two languages and can &ldquo;interpret&rdquo; between them using pen and paper, and so on. Film-based  photoshops and mechanical topographies also come to mind. It is actually over, no more <em>two more weeks</em>.</p>
<p>Again, we do not talk here about webshit or async crap. We are talking about Algebraic Data Types, proper non-leaking ADTs, modern advanced static-typing with proper sum-types,  Domain-Driven and Test-Driven development, rigorous formal modeling in pure-functional languages (or the pure subsets of good , math-based languages) and stuff like that, when normies would ask &ldquo;Where is the code?&rdquo; Yes, all serious, non bullshit Computer Science <em>itself</em> , indeed, converges to just a few &ldquo;things&rdquo; like Algebraic  Types, ADTs , Abstraction and Specification (as per Barbara Liskov) and augmented with advanced types The Lambda Calculus, and the algebraic structure which arise [back] from the <em>dots-between-arrows</em> of functional composition. Remember that everything  has already been solved the golden age of CS, which culminated, via Scheme, SML, and Miranda, in <em>the  Haskell 98 report</em> and the last good things like <em>Clojure</em> or Scala ot Hasell 2010 were just direct consequences &ndash; application of the accumulated math-base theoretical knowledge.</p>
<p>Yes, yes. strong claims, so lets unpack a little.</p>
<p>There <em>actually exist</em>, such things as an optimal pieces of code &ndash; the individual  code blocks that approach a limit of perfection &ndash; simply because there are such thing as Universe (Objective Reality or <em>What Is</em>).  There is literally nothing to remove, simplify or clarify (or otherwise significantly improve) in, say, a pure functionallibrary code which use a generalizes ADT for sequences. Just because a sequence is a properly generalized abstraction from What Is (there is a &ldquo;reason&rdquo;  why mRNA is a sequence &ndash; this is a minimal (not just in terms of &ldquo;stuff being used&rdquo;, but &ldquo;in a universal priniple&rdquo;), good-enough, and thus  &ldquo;optimal&rdquo; structure), so the code which has been abstracted over a proper tail-recursive <code>fold</code>  (which uses <em>the accumulator pattern</em>)  and thus the code pays an inevitable price of an extra <code>reverse</code> (which is also defined in terms of <code>fold</code>), that implicitly uses a Monoidal Functorial abduct algebraic  structure of  a sequence (again, abstracted out from What Is), which the best guys like Bartosz, have been studied for years and years, <em>cannot be improved any further in principle</em>.</p>
<p>The same could be said about pre-sorted or otherwise constrained tree-like structures, tables and some directed  acyclic graphs (which, again, are proper captures of some aspects of What Is), which are (for exactly the same reasons) are <em>good-enough for everything</em> (and yes, there is a non-commutative monoidal structure which underly your  [GPU-executed] Linear Algebra for AI, and even in the <em>weighted sums</em>, which actually underly all your silly probabilistic models, because the very notion of a <em>weighted sum</em> [of the causal factors] is a universal concept. which, in turn, partially captures  the Causality itself).</p>
<p>Thus, a proper fixed-point-like process has converged to a global optimum (at least for sequences)  with respect to a &ldquo;good-enough epsilon&rdquo;  of an implementation constraints. The code retains the fundamental <em>referential transparency</em> property, with all the nice things  &ndash; direct corollaries from being math or logic &ndash;follow. By the way, non-bullshit &ldquo;math and logic&rdquo; are also grounded in the very same What Is.</p>
<p>To understand  and to be able to realize such things people spent <em>decades</em> of studying and reading. To come up with an actual code requires <em>years</em> before one could formulate all the constraints and representation invariant clearly, taking into account the underlying algebraic structure and the <em>facts</em> that there is &ldquo;nothing more out there&rdquo;  to it. (The fact that one could &ldquo;construct&rdquo; way more abstract purely theoretical crap like latices or full Categories is irrelevant, and should point to a the threshold of crossing from abstractions captured from Reality into the realm of a rigorous abstract delirium).</p>
<p>And now such code (for prototyping purposes) can be generated <em>in seconds</em>. Seconds. Orders of magnitude change in &ldquo;productivity&rdquo;. Yes, one has to understand some  concepts (here, there) before putting them into a prompt as explicit constraints and requirements, but prompts can be just copied, collected from the inputs of other people, who will even pay you from the privilege (hi, big tech) and then sold for profit and reused.</p>
<p>The years of education in a proper non-bullshit tech school like MIT (one can study by oneself on their study materials and courses) will not (and never) be wasted, but the 100k of financial debt probably won&rsquo;t be repaid so easy.</p>
<p>Amazingly (or rather as an direct corollary or even implication from how it actually works) it cannot fix technical debts, which, again, is just a poilite name for stupid and lame early decisions. So no GPT will fix piles of crap like WinAPI or Ethereum (lmao), but with rapid prototyping (that avoids imperative crap) from the first principles, with focusing on the proper fundamentals of CS (yes, there are such things &ndash; principles the principles which connect properly captured abstractions, back to <em>What Is</em>) prototyping of way better things can be done at a tiny fraction of costs and manpower. I shut you not.</p>
<p>Conversely, it cannot just generate any actually novel solutions,  like yet another <em>crapto</em>, with the proper algebraic structures to underly the  almost  optimal chain implementation (it is  just trees, not even graphs, with an additional constraint of the consistent nested hashes ), and with the G-Machine (which implements the Haskell evaluation strategy) as its runtime and the smallest possible <em>superset</em> of the  some typed lambda calculus, not even required to be as general as the  System F Omega (what else could possible be better suited for so called &ldquo;smart contracts&rdquo;) &ndash; the thing at which Cardano and Charles (with all the hired academic super stars) have  spectacularly failed (and things that narcissistic and arrogant, fountaining with bullshit <em>vitaliks</em> could not even begin to understand), simply because there is <em>not enough or no training data</em> for G-Machines and properly constrained trees.</p>
<p>So, by now , with this generative technology literally everywhere in a massive bubble, we ought have already been literally flooded with all kinds of actually useful and well-designed, properly implemented software for all domains and problems imaginable , but we aren&rsquo;t , because there is no demand.  The real demand is to keep the old crap work and maybe little changes here and there, no one really wants anything new (due to the bias of complexity and really high costs).</p>
<p>If you are &ldquo;in the IT field&rdquo;  and have any difficulty to comprehend and understand this simple article, which I wrote on a whim in one sitting without any &ldquo;assistants&rdquo;,  it is time to <em>panic</em>.</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://lngnmn2.github.io/tags/programmign/">Programmign</a></li>
      <li><a href="https://lngnmn2.github.io/tags/ai/">AI</a></li>
      <li><a href="https://lngnmn2.github.io/tags/llm/">LLM</a></li>
      <li><a href="https://lngnmn2.github.io/tags/coding/">Coding</a></li>
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="https://lngnmn2.github.io/">Notes from the digital underground by Lngnmn</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
