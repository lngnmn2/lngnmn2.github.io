<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Concurrency Parallelism | Notes from the digital underground by Lngnmn</title>
<meta name="keywords" content="concurrecy, parallerism">
<meta name="description" content="LOL, lmao even">
<meta name="author" content="&amp;lt;lngnmn2@yahoo.com&amp;gt;">
<link rel="canonical" href="https://lngnmn2.github.io/articles/concurrency-and-parallelism/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.8fe10233a706bc87f2e08b3cf97b8bd4c0a80f10675a143675d59212121037c0.css" integrity="sha256-j&#43;ECM6cGvIfy4Is8&#43;XuL1MCoDxBnWhQ2ddWSEhIQN8A=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://lngnmn2.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://lngnmn2.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://lngnmn2.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://lngnmn2.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://lngnmn2.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://lngnmn2.github.io/articles/concurrency-and-parallelism/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Source+Code+Pro:wght@300&display=swap" rel="stylesheet">
<link href="https://fonts.googleapis.com/css2?family=Noto+Sans:wght@300&display=swap" rel="stylesheet">
<link href="https://fonts.googleapis.com/css2?family=Noto+Serif:wght@300&display=swap" rel="stylesheet">
<style>
font-family: 'Noto Serif', serif;
font-family: 'Noto Sans', sans-serif;
font-family: 'Source Code Pro', monospace;
</style>
<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script type="text/javascript" id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script><meta property="og:url" content="https://lngnmn2.github.io/articles/concurrency-and-parallelism/">
  <meta property="og:site_name" content="Notes from the digital underground by Lngnmn">
  <meta property="og:title" content="Concurrency Parallelism">
  <meta property="og:description" content="LOL, lmao even">
  <meta property="og:locale" content="en-us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="articles">
    <meta property="article:published_time" content="2025-07-19T00:00:00+05:45">
    <meta property="article:modified_time" content="2025-07-19T13:44:30+05:45">
    <meta property="article:tag" content="Concurrecy">
    <meta property="article:tag" content="Parallerism">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Concurrency Parallelism">
<meta name="twitter:description" content="LOL, lmao even">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Articles",
      "item": "https://lngnmn2.github.io/articles/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Concurrency Parallelism",
      "item": "https://lngnmn2.github.io/articles/concurrency-and-parallelism/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Concurrency Parallelism",
  "name": "Concurrency Parallelism",
  "description": "LOL, lmao even",
  "keywords": [
    "concurrecy", "parallerism"
  ],
  "articleBody": "Lets try to solve this too, at least in principle, because why tf not.\nThis is a much easier but conceptually messier and over-burdened with implementation details problem. The partially-understood solutions are all over the place, ranging from Molecular and System biology to abstract Signal and System theories. Telecom, Packet Switches and Computer Hardware guys have their own working solutions.\nWe will look at general universal principles and see what Evolutionary Biology came up with. This will be the best we can hope for (because Evolution already did all the trial-and-errors for us).\nSo, lets try to build it incrementally and bottom-up.\nThe most general concept of imperative programming is an anonymous block of code, (between some start and end delimiters), even more general than some a proc of assembly code.\nSyntactically (and semantically) blocks are “embedded” within imperative looping and conditional statements (FFFUUUUUUU!), this is how general and “universal” they seem to be. So this is where we start.\nBut not all blocks of code are created equal. Some have very different sets of constraints imposed on them, so they must be clearly semantically distinguished (typed), syntactically marked and semantically (again) separated by clear abstraction barriers. The Haskell guys showed the way.\nSo, the obvious solution (if one have studied the findings of the last 60 years of the PL theory development) is “more typing”, more “partitioning” and “more abstraction barriers”, which is, basically, is “more Monads at the Compiler’s Intermediate Representation level”. (some Zig clowns – “we have no closures”, “out async is not concurrency” – have a lot to learn, lmao).\nAt the implementation side we do well-understood and universal “more parameterization”, just like the Haskell guys did with parameterizing a closure with a “dict of methods”, or parameterizing a closure with types for implementing dependent types, what Scala2 general implicits were (they were generalized implicit parameters), which all can be captured to an abstract notion of implicit or explicit contexts (which will go back as far as the universal foundational principle of any human language as an abstract communication system).\nWe already have “evolved” an appropriate meme for this – “What color is your function” This is an intuitive step in the right direction, no matter what uneducated degens on lowIQ tech boards are saying.\nThe “right” memes are crucial. As some French “humanists” of the past century have noticed, human societies (and humanity as a whole) runs on successive waves and tides of mass hysterias and related memes. So does what we call “software engineering and methodology”.\nAs I have written before, we have C as “PHP of the 70s and 80s”, and PHP itself (the Fractal of Bad Design, you know) of the 90s, and related mass hysterias and all their unfortunate but massive outcomes, as obvious examples.\nSo this is the right meme. It is related to the human notion of “color coding”, which will go back to the “a green tomato (not yet ripe) is not the same as a red tomato” (Mother Nature has no clue that we have observed and used colors as a fundamental cue).\nThis is a human-universal cognitive notion, and it is everywhere from “maps” to literally everything else. Color-coding of “types” (different kinds of things) is a human-universal technique.\nA little on more esoteric and even mysterious side – this is related the 4-colour theorem, which is about non-overlapping regions (on a 2D-plane).\nConcurrency is also about non-overlapping “regions” of code (blocks), and parallel is not having a single point in common (no overlap) by definition. The principal conceptual difference is that in “concurrency” the “parallel lines” (of code) are being chopped into chunks, and the runtime tries to not-overlap them.\nBy the way, enforced consistent coloring (color-coding) of different kinds of blocks of code (a red-ish tint of the background for an imperative crap and IO-doing blocks) is a good idea.\nThere are some more facts about this particular Universe. The “waiting” cannot be avoided. Partially filled enzymes are literally “waiting” for all the necessary and sufficient conditions to be meet. So are ordinary people when cooking or building a house. Blocking is okay and even “natural”.\n“Non-blocking I/O” is a conceptual bullshit meme. Just making it “other people’s problem” does not imply that an ordinary sequential code can be somehow meme’d into a parallel one. It will just block in a different place and if required data isn’t available it will just wait.\nThe best we can do are classic “software interrupts”, used as an implicit notification mechanism. Again, these are just different kind of code, with many subtle constraints applied, and such code simply cannot have just any construct you want.\nAnd this is not about “granularity”, it is, indeed, a typing (classification and non-overlapping) problem, very similar to what Rust does with typing reference by classifying (partitioning) them and by adding a concept of a lifetime to each.\nOk, let’s slow down, and build it up.\nI am old enough to remember DOS and “resident programs”, primitive DOS “viruses” in Assembly and their basic building blocks, which were just blocks of assembly code of different kinds.\nAn “interrupt handler” would be just a block of assembly code, with some implicit informally stated restrictions (as rules) placed on them as constraints. You have to be aware what you can and cannot call from such a “handler”, and in general, you want to do as less as possible – just “signal and return”.\nThe fact that at a CPU level, interrupts and their handlers are using different signaling mechanisms, instead of just stack-based procedure calls and returns, correspond to the more general principle of “interruption by a signal”, which is biologically universal.\nWith the async/await syntax, which by the way is a huge meme, we cleverly swept under the rug the fact that the actual signalling is very different, and that the “awaited functions” are not the same as the ones which use ordinary stack-based call-return mechanism.\nThe problem is, of course, that not any kind code can go into such functions. Traditionally, everyone is trying to sweep this fact under the rug too. except mathematicians, who see the necessity of clear partitioning and that this is the only “natural” way.\nSo, instead of What color is your function we always had “what color is your assembly block of code”.\nIn the imperative settings all we need is type-annotations and compiler support (checking, enforcement and type-inference) for blocks of code of different kinds.\nThe list of “kinds” can vary (it will take time to “stabilize”), but basically we all know what they are – “blocking vs. unblocking (in principle)”, “waiting for completion (pending)” (which is a universal notion and cannot be ignored), “sending and receiving” (as in Erlang’s message-passing idioms), and so on.\nWaiting is universal (I am getting pedantic and boring!). Some processes cannot proceed until certain conditions (or thresholds) have been meet. There is a whole class of such processes, which we call traditionally “sequential”.\nWe absolutely do not want “busy-waiting” (and biology has none of those, just as it does not have “counters” or “clocks”), and we want to be “signaled” (notified, or “interrupted”), which is what biology actually does (learned by doing).\nIf we, however, want to be systematic, mathematically rigorous and precise, and provably correct, we have to correctly classify (“color”) the proper lexical closures, based on what they could possibly “do” (what kind of “side-effects” they could in principle have).\nJust as by having pure expressions (as proper closures) we can abstract away from the actual order of evaluation (as in Lazy pure functional languages), we must abstract away from how computations overlap at the runtime, by ensuring that they cannot overlap in principle (similar to what Rust does with non-overlapping lifetimes), and just tossing them into an appropriate “pool” or a “reactor”. We need specialize them too, at least IO vs. never-IO.\nClosures will “naturally” capture all the implementation-details related to “channels”, callbacks (when necessary), etc. This is also well-understood.\nThis is, probably, what Odersky is doing nowadays with his effect-systems on a nice new shiny grant somewhere in Swiss Alps.\nHaskell has all the necessary notions, some of which are turned out to be way to general (yes, again, since the very first untyped Lambda Calculus!), we just need to add “more typing” and “more partitioning”, just enough of it.\nHaskell has “thunks” which are the universal building block of “lazyness”. They are uniform, and this is the point. We have to classify, partition and parameterize them with required “contexts”.\nThere are well-understood whole classes of computations which can be “structured” and “packaged into a Monad” – behind a distinct, impenetrable abstraction barrier, which has implicit serialization (via nesting of “closures” at the implementation level).\nNesting is the only/ way of establishing an particular order of evaluation in a lazy abstract language, such as math or logic, which is not a random coincidence.\nHaving such “monadic interfaces” for different kinds of “thunks” or “proper lexical closures” within the compiler’s IR is the theoretical and practical solution. We “color code” the closures and put them behind a monadic abstraction barrier.\nAt the level of abstract arrows, “lifting” and “composition” a -\u003e m a and m a -\u003e m b -\u003e m c is enough.\nNow, what do we do with signals (“interrupts”) and “interrupt handlers”? Well, we “lift” them into a “pool” of “compiler-guaranteed (verified) non-overlapping computations” and “forget”. There is nothing we can do.\nEach such “specialized closure” has to be parameterized with a “dict” of special “callbacks” (which has to immediately return, everything has to immediately return in a signalling implementation context) it could possibly call.\nImplementation details are much less interesting. There will probably be a queue, and “callbacks” just know where it is and place (“move”) values in it and return. Hardware guys got it all right long ago.\nThe theoretical and practical solution is in proper specialization of classic, general, well-understood even “universal” notions of a non-leaking abstraction, proper, fully self-contained, lexical closure, tagging (as the way of “typing”), as in “tagged unions”, parameterization as the universal way of building abstractions (as per Barbara Liskov), and, yes, Monads, as “lifting + proper Monoidal composition”.\nThis is how “more partitioning” and “more abstraction barriers” can be achieved at the level of a compiler’s IR.\nJust as GHC has a representation of System F Omega as its IR, serious compilers should have it, augmented with systematically partitioned code blocks of different kinds. Which particular kinds – less interesting and has been roughly outlined above.\nThe important part is that there always been blocks of code of different kinds, heavily constrained with a different sets of informal rules.\nThe proper way is to define semantics of such blocks with a mathematical rigor, and the Haskell community has already developed all the necessary building block, both at the conceptual and implementation level.\nAt the level of syntax, the best possible solutions is to have distinct specialized DSLs (syntactic sugars supported by the language), tradtional math-like for pure code, and some imperative ugliness, derived from the C/PHP/C++/Java legacy, intentionally being kept traditionally ugly with all their curly braces as imperative block delimiters.\nAnd this is, basically, it. Good-enough to have the top page of HN or whatever it is (they all the same nowadays). Way better than all these overhyped “zig” posts LOL.\n",
  "wordCount" : "1896",
  "inLanguage": "en",
  "datePublished": "2025-07-19T00:00:00+05:45",
  "dateModified": "2025-07-19T13:44:30+05:45",
  "author":[{
    "@type": "Person",
    "name": "\u0026lt;lngnmn2@yahoo.com\u0026gt;"
  }],
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://lngnmn2.github.io/articles/concurrency-and-parallelism/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Notes from the digital underground by Lngnmn",
    "logo": {
      "@type": "ImageObject",
      "url": "https://lngnmn2.github.io/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://lngnmn2.github.io/" accesskey="h" title="Notes from the digital underground by Lngnmn (Alt + H)">Notes from the digital underground by Lngnmn</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://lngnmn2.github.io/about/" title="About me.">
                    <span>About me.</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title entry-hint-parent">
      Concurrency Parallelism
    </h1>
    <div class="post-description">
      LOL, lmao even
    </div>
    <div class="post-meta"><span title='2025-07-19 00:00:00 +0545 +0545'>July 19, 2025</span>&nbsp;·&nbsp;&amp;lt;lngnmn2@yahoo.com&amp;gt;

</div>
  </header> 
  <div class="post-content"><p>Lets <em>try</em> to solve this too, at least in principle, because why <em>tf</em> not.</p>
<p>This is a much easier but conceptually messier and over-burdened with implementation details problem. The partially-understood solutions are all over the place, ranging from Molecular and System biology to abstract Signal and System theories. Telecom, Packet Switches and Computer Hardware guys have their own working solutions.</p>
<p>We will look at general universal principles and see what Evolutionary Biology came up with. This will be the best we can hope for (because Evolution already did all the trial-and-errors for us).</p>
<p>So, lets try to build it incrementally and bottom-up.</p>
<p>The most general concept of <em>imperative programming</em> is an anonymous block of code, (between some start and end delimiters), even more general than some a <code>proc</code> of assembly code.</p>
<p>Syntactically (and semantically) blocks are &ldquo;embedded&rdquo; within imperative looping and conditional <em>statements</em> (FFFUUUUUUU!), this is how general and &ldquo;universal&rdquo; they seem to be. So this is where we start.</p>
<p>But not all blocks of code are created equal. Some have very different sets of constraints imposed on them, so they <em>must</em> be clearly semantically distinguished (typed), syntactically marked and semantically (again) separated by clear abstraction barriers. The Haskell guys showed the way.</p>
<p>So, the obvious solution (if one have  studied the findings of the last 60 years of the PL theory development) is &ldquo;more typing&rdquo;, more &ldquo;partitioning&rdquo; and &ldquo;more abstraction barriers&rdquo;, which is, basically, is &ldquo;more Monads at the Compiler&rsquo;s Intermediate Representation level&rdquo;. (some <code>Zig</code> clowns &ndash; &ldquo;we have no closures&rdquo;, &ldquo;out async is not concurrency&rdquo; &ndash; have a lot to learn, lmao).</p>
<p>At the implementation side we do well-understood and universal &ldquo;more parameterization&rdquo;, just like the Haskell guys did with parameterizing a closure with a &ldquo;dict of methods&rdquo;, or parameterizing a closure with types for implementing <em>dependent types</em>, what Scala2 general <em>implicits</em> were (they were generalized implicit <em>parameters</em>), which all can be captured to an abstract notion of implicit or explicit <em>contexts</em> (which will go back as far as the universal foundational principle of any human language as an abstract communication system).</p>
<p>We already have &ldquo;evolved&rdquo; an appropriate meme for this &ndash; &ldquo;What color is your function&rdquo; This is an <em>intuitive</em> step in the right direction, no matter what uneducated degens on lowIQ tech boards are saying.</p>
<p>The &ldquo;right&rdquo; memes are crucial. As some French &ldquo;humanists&rdquo; of the past century have noticed, human societies (and humanity as a whole) runs on successive waves and tides of mass hysterias and related memes. So does what we call &ldquo;software engineering and methodology&rdquo;.</p>
<p>As I have written before, we have C as &ldquo;PHP of the 70s and 80s&rdquo;, and PHP itself (<em>the</em> Fractal of Bad Design, you know) of the 90s, and related mass hysterias and all their unfortunate but massive outcomes, as obvious examples.</p>
<p>So this is the right meme. It is related to the human notion of &ldquo;color coding&rdquo;, which will go back to the &ldquo;a green tomato (not yet ripe) is not the same as a red tomato&rdquo; (Mother Nature has no clue that we have observed and used colors as a fundamental cue).</p>
<p>This is a human-universal <em>cognitive</em> notion, and it is everywhere from &ldquo;maps&rdquo; to literally everything else. Color-coding of &ldquo;types&rdquo; (different kinds of things) is a human-universal <em>technique</em>.</p>
<p>A little on more esoteric and even mysterious side &ndash; this is related the 4-colour theorem, which is about <em>non-overlapping regions</em> (on a 2D-plane).</p>
<p>Concurrency is also about <em>non-overlapping</em> &ldquo;regions&rdquo; of code (blocks), and <em>parallel</em> is <em>not having a single point in common</em> (no overlap) by definition. The principal conceptual difference is that in &ldquo;concurrency&rdquo; the &ldquo;parallel lines&rdquo; (of code) are being chopped into chunks, and the runtime tries to not-overlap them.</p>
<p>By the way, enforced consistent coloring (color-coding) of <em>different kinds</em> of blocks of code (a red-ish tint of the background for an imperative crap and IO-doing blocks) is a good idea.</p>
<p>There are some more facts about this particular Universe. The &ldquo;waiting&rdquo; cannot be avoided. Partially filled enzymes are literally &ldquo;waiting&rdquo; for all the necessary and sufficient conditions to be meet. So are ordinary people when cooking or building a house. Blocking is okay and even &ldquo;natural&rdquo;.</p>
<p>&ldquo;Non-blocking I/O&rdquo; is a conceptual bullshit meme. Just making it &ldquo;other people&rsquo;s problem&rdquo; does not imply that an ordinary sequential code can be somehow meme&rsquo;d into a parallel one. It will just block in a different place and if required data isn&rsquo;t available it will just wait.</p>
<p>The best we can do are classic &ldquo;software interrupts&rdquo;, used as an implicit notification mechanism. Again, these are just different kind of code, with many subtle constraints applied, and such code simply cannot have just any construct you want.</p>
<p>And this is not about &ldquo;granularity&rdquo;, it is, indeed, a <em>typing</em> (classification and non-overlapping) problem, very similar to what Rust does with typing reference by classifying (partitioning) them and by adding a concept of a lifetime to each.</p>
<p>Ok, let&rsquo;s slow down, and build it up.</p>
<p>I am old enough to remember DOS and &ldquo;resident programs&rdquo;, primitive DOS  &ldquo;viruses&rdquo; in Assembly and their basic building blocks, which were just blocks of assembly code of different kinds.</p>
<p>An &ldquo;interrupt handler&rdquo; would be just a block of assembly code, with some implicit informally stated restrictions (as rules) placed on them as constraints. You have to be aware what you can and cannot call from such a &ldquo;handler&rdquo;, and in general, you want to do as less as possible &ndash; just &ldquo;signal and return&rdquo;.</p>
<p>The fact that at a CPU level, interrupts and their handlers are using different signaling mechanisms, instead of just stack-based procedure calls and returns, correspond to the more general principle of &ldquo;interruption by a signal&rdquo;, which is biologically universal.</p>
<p>With the <code>async/await</code> syntax, which by the way is a huge meme, we cleverly swept under the rug the fact that the actual signalling is very different, and that the &ldquo;awaited functions&rdquo; are not the same as the ones which use ordinary stack-based call-return mechanism.</p>
<p>The problem is, of course, that not any kind code can go into such functions. Traditionally, everyone is trying to sweep this fact under the rug too. except mathematicians, who see the necessity of clear partitioning and that this is the only &ldquo;natural&rdquo; way.</p>
<p>So, instead of <em>What color is your function</em> we always had &ldquo;what color is your assembly block of code&rdquo;.</p>
<p>In the imperative settings all we need is type-annotations and compiler support (checking, enforcement and type-inference) for <em>blocks of code of different kinds</em>.</p>
<p>The list of &ldquo;kinds&rdquo; can vary (it will take time to &ldquo;stabilize&rdquo;), but basically we all know what they are &ndash; &ldquo;blocking vs. unblocking (in principle)&rdquo;, &ldquo;waiting for completion (pending)&rdquo; (which is a <em>universal notion</em> and cannot be ignored), &ldquo;sending and receiving&rdquo; (as in Erlang&rsquo;s message-passing idioms), and so on.</p>
<p>Waiting is universal (I am getting pedantic and boring!). Some processes cannot proceed until certain conditions (or thresholds) have been meet. There is a whole class of such processes, which we call traditionally &ldquo;sequential&rdquo;.</p>
<p>We absolutely do not want &ldquo;busy-waiting&rdquo; (and biology has none of those, just as it does not have &ldquo;counters&rdquo; or &ldquo;clocks&rdquo;), and we want to be &ldquo;signaled&rdquo; (notified, or &ldquo;interrupted&rdquo;), which is what biology actually does (learned by doing).</p>
<p>If we, however, want to be systematic, mathematically rigorous and precise, and provably correct, we have to correctly classify (&ldquo;color&rdquo;) the <em>proper lexical closures</em>, based on what they could possibly &ldquo;do&rdquo; (what kind of &ldquo;side-effects&rdquo; they could in principle have).</p>
<p>Just as by having pure expressions (as proper closures) we can abstract away from the actual order of evaluation (as in Lazy pure functional languages), we <em>must</em> abstract away from how computations overlap at the runtime, by ensuring that they cannot overlap in principle (similar to what Rust does with non-overlapping lifetimes), and just tossing them into an appropriate &ldquo;pool&rdquo; or a &ldquo;reactor&rdquo;. We need specialize them too, at least IO vs. never-IO.</p>
<p>Closures will &ldquo;naturally&rdquo; capture all the implementation-details related to &ldquo;channels&rdquo;, callbacks (when necessary), etc. This is also well-understood.</p>
<p>This is, probably, what Odersky is doing nowadays with his effect-systems on a nice new shiny grant somewhere in Swiss Alps.</p>
<p>Haskell has all the necessary notions, some of which are turned out to be way to general (yes, again, since the very first untyped Lambda Calculus!), we just need to add &ldquo;more typing&rdquo; and &ldquo;more partitioning&rdquo;, just enough of it.</p>
<p>Haskell has &ldquo;thunks&rdquo; which are the universal building block of &ldquo;lazyness&rdquo;. They are <em>uniform</em>, and this is the point. We have to classify, partition and parameterize them with required &ldquo;contexts&rdquo;.</p>
<p>There are well-understood whole classes of computations which can be &ldquo;structured&rdquo; and &ldquo;packaged into a Monad&rdquo; &ndash; behind a distinct, impenetrable abstraction barrier, which has implicit serialization (via nesting of &ldquo;closures&rdquo; at the implementation level).</p>
<p>Nesting is <em>the</em> only/ way of establishing an particular order of evaluation in a lazy abstract language, such as math or logic, which is not a random coincidence.</p>
<p>Having such &ldquo;monadic interfaces&rdquo; for different kinds of &ldquo;thunks&rdquo; or &ldquo;proper lexical closures&rdquo; within the compiler&rsquo;s IR is the theoretical and practical solution. We &ldquo;color code&rdquo; the <em>closures</em> and put them behind a monadic abstraction barrier.</p>
<p>At the level of abstract arrows, &ldquo;lifting&rdquo; and &ldquo;composition&rdquo; <code>a -&gt; m a</code> and <code>m a -&gt; m b -&gt; m c</code> is enough.</p>
<p>Now, what do we do with signals (&ldquo;interrupts&rdquo;) and &ldquo;interrupt handlers&rdquo;? Well, we &ldquo;lift&rdquo; them into a &ldquo;pool&rdquo; of &ldquo;compiler-guaranteed (verified)  non-overlapping computations&rdquo; and &ldquo;forget&rdquo;. There is nothing we can do.</p>
<p>Each such &ldquo;specialized closure&rdquo; has to be parameterized with a &ldquo;dict&rdquo; of special &ldquo;callbacks&rdquo; (which has to immediately return, everything has to immediately return in a <em>signalling implementation</em> context) it could possibly call.</p>
<p>Implementation details are much less interesting. There will probably be a <code>queue</code>, and &ldquo;callbacks&rdquo; just know where it is and place (&ldquo;move&rdquo;) values in it and return. Hardware guys got it all right long ago.</p>
<p>The theoretical and practical solution is in proper specialization of classic, general, well-understood even &ldquo;universal&rdquo; notions of a non-leaking abstraction, proper, fully self-contained, lexical closure, tagging (as the way of &ldquo;typing&rdquo;), as in &ldquo;tagged unions&rdquo;, parameterization as the universal way of building abstractions (as per Barbara Liskov), and, yes, Monads, as &ldquo;lifting + proper Monoidal composition&rdquo;.</p>
<p>This is how &ldquo;more partitioning&rdquo; and &ldquo;more abstraction barriers&rdquo; can be achieved at the level of a compiler&rsquo;s IR.</p>
<p>Just as GHC has a representation of System F Omega as its IR, serious compilers should have it, augmented with systematically partitioned code blocks of different kinds. Which particular kinds &ndash; less interesting and has been roughly outlined above.</p>
<p>The important part is that there always been blocks of code of different kinds, heavily constrained with a different sets of informal rules.</p>
<p>The proper way is to define semantics of such blocks with a mathematical rigor, and the Haskell community has already developed all the necessary building block, both at the conceptual and implementation level.</p>
<p>At the level of syntax, the best possible solutions is to have distinct specialized DSLs (syntactic sugars supported by the language), tradtional math-like for pure code, and some imperative ugliness, derived from the C/PHP/C++/Java legacy, intentionally being kept traditionally ugly with all their curly braces as imperative block delimiters.</p>
<p>And this is, basically, it. Good-enough to have the top page of HN or whatever it is (they all the same nowadays). <em>Way better</em> than all these overhyped &ldquo;zig&rdquo; posts LOL.</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://lngnmn2.github.io/tags/concurrecy/">Concurrecy</a></li>
      <li><a href="https://lngnmn2.github.io/tags/parallerism/">Parallerism</a></li>
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="https://lngnmn2.github.io/">Notes from the digital underground by Lngnmn</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
