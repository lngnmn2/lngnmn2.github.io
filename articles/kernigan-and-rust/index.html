<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Kernigan and Rust | Notes from the digital underground by Lngnmn</title>
<meta name="keywords" content="ADT">
<meta name="description" content="LOL, LMAO even.">
<meta name="author" content="lngnmn2@yahoo.com">
<link rel="canonical" href="https://lngnmn2.github.io/articles/kernigan-and-rust/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.8fe10233a706bc87f2e08b3cf97b8bd4c0a80f10675a143675d59212121037c0.css" integrity="sha256-j&#43;ECM6cGvIfy4Is8&#43;XuL1MCoDxBnWhQ2ddWSEhIQN8A=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://lngnmn2.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://lngnmn2.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://lngnmn2.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://lngnmn2.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://lngnmn2.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://lngnmn2.github.io/articles/kernigan-and-rust/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Source+Code+Pro:wght@300&display=swap" rel="stylesheet">
<link href="https://fonts.googleapis.com/css2?family=Noto+Sans:wght@300&display=swap" rel="stylesheet">
<link href="https://fonts.googleapis.com/css2?family=Noto+Serif:wght@300&display=swap" rel="stylesheet">
<style>
font-family: 'Noto Serif', serif;
font-family: 'Noto Sans', sans-serif;
font-family: 'Source Code Pro', monospace;
</style>
<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script type="text/javascript" id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script><meta property="og:url" content="https://lngnmn2.github.io/articles/kernigan-and-rust/">
  <meta property="og:site_name" content="Notes from the digital underground by Lngnmn">
  <meta property="og:title" content="Kernigan and Rust">
  <meta property="og:description" content="LOL, LMAO even.">
  <meta property="og:locale" content="en-us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="articles">
    <meta property="article:published_time" content="2025-09-02T00:00:00+05:45">
    <meta property="article:modified_time" content="2025-09-02T09:01:11+05:45">
    <meta property="article:tag" content="ADT">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Kernigan and Rust">
<meta name="twitter:description" content="LOL, LMAO even.">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Articles",
      "item": "https://lngnmn2.github.io/articles/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Kernigan and Rust",
      "item": "https://lngnmn2.github.io/articles/kernigan-and-rust/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Kernigan and Rust",
  "name": "Kernigan and Rust",
  "description": "LOL, LMAO even.",
  "keywords": [
    "ADT"
  ],
  "articleBody": "https://developers.slashdot.org/story/25/08/30/044226/what-happened-when-unix-co-creator-brian-kernighan-tried-rust\nIt is a peculiar experience to know more and have a better understating that the CS celebrity, whose book you have read as a teenager.\nJust like I wrote before, C was a PHP of the 80s, if you will – a bunch of clever hacks (while PHP has nothing clever and was a Fractal Of Bad Design by an unqualified and ignorant amateurs) which allowed one to quickly “get shit done” in the way that wasn’t possible before, which is the reason behind its popularity. It also appeared to be way more “cool”, “practical” and clever than “theoretical” Algol or PL/1.\nWhile some hacks were, indeed, clever (at the time), and the “pragmatic” aspect cannot be denied, the overall design was by no means consistent, systematic or even well-thought, unlike, lets say CLU, or ML, which were “Out There”. The mature LISP implementations were also completely ignored.\nLet’s try to see things as they [really] are.\nC Is an ultimate low-level language, while it is a “high-level” over assembly and machine-level data representations. When one programs in C one is forced to think and model in terms of representations and implementation details, just like in an assembly language. Yes, C generalized a lot – the imperative control flow constructs and the primitive types, notably arrays and machine-level array-based ASCII strings, but all this was, again, in terms of the details of the underlying hardware and data representations.\nThe really big and fundamental idea of truly high-level programming with Abstract Data Types and Data Abstractions (Liskov, CLU) and Abstract Control Flow – composeable abstract interfaces (ML, LISP) were completely ignored.\nThis results in a poor support for abstraction and non-leaking ADTs in C, with focus on how everything maps to an underlying hardware representations (how the crappy enums, instead of proper algebraic sum-types, map to integers, how the structs map to memory layouts, etc).\nThe “pragmatic” C programmers, who are not aware of the proper theoretical FP concepts, derived from advanced abstract algebra – the very way in which these generalized algebraic structures has been captured and defined – are forced to think in terms of these low-level details and representations, which is a leakage of abstraction and a violation of the abstraction principle itself. Just like webshit coders were unaware of what a fucking abomination that PHP 2.0 was.\nAgain, this is not like some option, you know. This is fundamental flaw of the language design – no proper support for proper abstraction, in principle. No way to program in a high-level way, in terms of abstract data types and abstract control flow, even if one wishes to – everything leaks everything else, literally.\nThe last 60 years of programming language semantics research, however, concluded that the only way to properly support abstraction is through a systematic and consistent design of the language semantics, which is what modern languages like ML, Haskell, Scala, Rust, etc do.\nThe most important principle is that one has to think, model and program at the same higher level of abstraction as the concepts of the problem domain, and not in terms of the conceptually irrelevant underlying implementation details and machine representations. Ideally, there must be a one-to-one mapping between the concepts of the problem domain and the data abstractions defined in terms of a programming language semantics. “Data dominates”, you know.\nNot just that, but it was well-understood that the Algebraic Data Types – sum-types, product types and function types is all you need, and that these has to be truly abstract, parameterized and composeable, to be able to model any complex data abstractions in a systematic way. This is what ML, Haskell, Scala, etc do.\nThe last real major innovation was the formulation of Type-classes by Wadler, which is just a very clever formalization of the universal mathematical notion of such that at the level of abstract interfaces – proper bounds on sets of abstract interfaces. Notice that “abstract” here is absolutely necessary. Notice that all the “individual components” of the type-classes formulation are just well-understood rigorous mathematical notions, such as Equality or an Ordering.\nEven without these, the use of just proper Algebraic Data Types alone (and the “new-types”) would lead to an enlightening experience as in “Where Is The Code”, of Scott Wlaschin. This is not something random or arbitrary in it.\nOne more time – all the errors, complexity, verbosity and imperative “unsafety” arise from mixing the irrelevant levels of abstraction – high level concepts of the problem domain, with low-level language and implementation details and representations. This is the source of Java’s retarded verbosity, C’s inherent unsafety, C++’s explosive complexity, etc. Staying abstract and high-level, while maintaining the one-to-one correspondence between the hierarchy of the layers of complexity in the problem domain concepts and the modular, layered stricture of the hierarchy of abstractions in terms of a programming language, at the same level of abstraction, is not optional, but is a fundamental requirement for any non-trivial software system.\nYes, here I am basically paraphrasing the Barbara Liskov’s book, but it does not make these principles less fundamental and less ignored by C designers. Kernigan embarrased himself as an ignorant old fool (ignorant of all the fundamental results of the last 60 years of programming language semantics research).\nThis is not the end of the story. The proper understanding of “what Rust did right” and why it is the right way (and is the only way, which cannot be refuted) is the next level up.\n",
  "wordCount" : "917",
  "inLanguage": "en",
  "datePublished": "2025-09-02T00:00:00+05:45",
  "dateModified": "2025-09-02T09:01:11+05:45",
  "author":[{
    "@type": "Person",
    "name": "lngnmn2@yahoo.com"
  }],
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://lngnmn2.github.io/articles/kernigan-and-rust/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Notes from the digital underground by Lngnmn",
    "logo": {
      "@type": "ImageObject",
      "url": "https://lngnmn2.github.io/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://lngnmn2.github.io/" accesskey="h" title="Notes from the digital underground by Lngnmn (Alt + H)">Notes from the digital underground by Lngnmn</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://lngnmn2.github.io/about/" title="About me.">
                    <span>About me.</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title entry-hint-parent">
      Kernigan and Rust
    </h1>
    <div class="post-description">
      LOL, LMAO even.
    </div>
    <div class="post-meta"><span title='2025-09-02 00:00:00 +0545 +0545'>September 2, 2025</span>&nbsp;·&nbsp;lngnmn2@yahoo.com

</div>
  </header> 
  <div class="post-content"><p><a href="https://developers.slashdot.org/story/25/08/30/044226/what-happened-when-unix-co-creator-brian-kernighan-tried-rust">https://developers.slashdot.org/story/25/08/30/044226/what-happened-when-unix-co-creator-brian-kernighan-tried-rust</a></p>
<p>It is a peculiar experience to know more and have a better understating that the CS celebrity, whose book you have read as a teenager.</p>
<p>Just like I wrote before, C was a PHP of the 80s, if you will &ndash; a bunch of clever hacks (while PHP has nothing clever and was a <em>Fractal Of Bad Design</em> by an unqualified and ignorant amateurs) which allowed one to quickly &ldquo;get shit done&rdquo; in the way that  wasn&rsquo;t possible before, which is the reason behind its popularity. It also appeared to be way more &ldquo;cool&rdquo;, &ldquo;practical&rdquo; and clever than &ldquo;theoretical&rdquo; Algol or PL/1.</p>
<p>While some hacks were, indeed, clever (at the time), and the &ldquo;pragmatic&rdquo; aspect cannot be denied, the overall design was by no means consistent, systematic or even well-thought, unlike, lets say CLU, or ML, which were &ldquo;Out There&rdquo;. The mature LISP implementations were also completely ignored.</p>
<p>Let&rsquo;s try to see things as they [really] are.</p>
<p>C Is an ultimate <em>low-level</em> language, while it is a &ldquo;high-level&rdquo; over assembly and machine-level data representations.  When one programs in C one  is forced to think and model in terms of representations and implementation details, just like in an assembly language. Yes, C generalized a lot &ndash; the imperative control flow constructs and the primitive types, notably arrays and machine-level array-based ASCII strings, but  all this was, again, in terms of the details of the underlying hardware and data representations.</p>
<p>The really <em>big and fundamental idea</em> of truly <em>high-level</em> programming with Abstract Data Types and Data Abstractions (Liskov, CLU) and Abstract Control Flow &ndash; composeable abstract interfaces  (ML, LISP) were completely ignored.</p>
<p>This results in a poor support for abstraction and non-leaking ADTs in C, with focus on how everything maps to an underlying hardware representations (how the crappy enums, instead of proper algebraic sum-types, map to integers, how the structs map to memory layouts, etc).</p>
<p>The &ldquo;pragmatic&rdquo; C programmers, who are not aware of the proper theoretical FP concepts, derived from  advanced abstract algebra &ndash; the very way in which these generalized algebraic structures has been captured and defined &ndash; are forced to think in terms of these low-level details and representations, which is a <em>leakage of abstraction</em> and a <em>violation of the abstraction principle itself</em>.  Just like webshit coders were unaware of what a fucking abomination that PHP 2.0 was.</p>
<p>Again, this is not like some option, you know. This is fundamental flaw of the language design &ndash; no proper support for proper abstraction, in principle. No way to program in a high-level way, in terms of abstract data types and abstract control flow, even if one wishes to &ndash; everything leaks everything else, literally.</p>
<p>The last 60 years of programming language <em>semantics</em> research, however, concluded that the only way to properly support abstraction is through a systematic and consistent design of the language semantics, which is what modern languages like ML, Haskell, Scala, Rust, etc do.</p>
<p>The most important principle is that one has to think, model and program at <em>the same higher level of abstraction</em> as the concepts of the problem domain, and <em>not</em> in terms of the conceptually irrelevant underlying implementation details and machine representations. Ideally, there must be a <em>one-to-one mapping</em> between the concepts of the problem domain and the data abstractions defined in terms of a programming language <em>semantics</em>. &ldquo;Data dominates&rdquo;, you know.</p>
<p>Not just that, but it was well-understood that the Algebraic Data Types &ndash; sum-types, product types and function types <em>is all you need</em>, and that these has to be truly abstract, parameterized and composeable, to be able to model any complex data abstractions in a systematic way. This is what ML, Haskell, Scala, etc do.</p>
<p>The last real major innovation was the formulation of Type-classes by Wadler, which is just a very clever formalization of the universal mathematical notion of <em>such that</em> at the level of <em>abstract interfaces</em> &ndash; proper bounds on sets of abstract interfaces. Notice that &ldquo;abstract&rdquo; here is absolutely necessary. Notice that all the &ldquo;individual components&rdquo; of the type-classes formulation are  just well-understood rigorous mathematical notions, such as Equality or an Ordering.</p>
<p>Even without these, the use of just <em>proper</em> Algebraic Data Types alone (and the &ldquo;new-types&rdquo;) would lead to an enlightening experience as in &ldquo;<em>Where Is The Code</em>&rdquo;, of Scott Wlaschin. This is not something random or arbitrary in it.</p>
<p>One more time &ndash; all the errors, complexity, verbosity and imperative &ldquo;unsafety&rdquo; arise from mixing the irrelevant levels of abstraction &ndash; high level concepts of the problem domain, with low-level language and implementation details and representations. This is the source of Java&rsquo;s retarded verbosity, C&rsquo;s inherent unsafety, C++&rsquo;s  explosive complexity, etc. Staying abstract and high-level, while maintaining the one-to-one correspondence between the hierarchy of the layers of complexity in the  problem domain concepts and the modular, layered stricture of the  hierarchy of abstractions in terms of a programming language, <em>at the same level of abstraction</em>, is not optional, but is a <em>fundamental</em> requirement for any non-trivial software system.</p>
<p>Yes, here I am basically paraphrasing the Barbara Liskov&rsquo;s book, but it does not make these principles less fundamental and less ignored by C designers. Kernigan embarrased himself as an ignorant old fool (ignorant of all the fundamental results of the last 60 years of programming language semantics research).</p>
<p>This is not the end of the story. The proper understanding of &ldquo;what Rust did right&rdquo;  and <em>why it is  the right way</em> (and is the only way, which cannot be refuted) is the next level up.</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://lngnmn2.github.io/tags/adt/">ADT</a></li>
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="https://lngnmn2.github.io/">Notes from the digital underground by Lngnmn</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
