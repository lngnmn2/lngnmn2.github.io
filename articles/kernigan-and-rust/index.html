<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Kernigan and Rust | Notes from the digital underground by Lngnmn</title>
<meta name="keywords" content="ADT">
<meta name="description" content="LOL, LMAO even.">
<meta name="author" content="lngnmn2@yahoo.com">
<link rel="canonical" href="https://lngnmn2.github.io/articles/kernigan-and-rust/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.8fe10233a706bc87f2e08b3cf97b8bd4c0a80f10675a143675d59212121037c0.css" integrity="sha256-j&#43;ECM6cGvIfy4Is8&#43;XuL1MCoDxBnWhQ2ddWSEhIQN8A=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://lngnmn2.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://lngnmn2.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://lngnmn2.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://lngnmn2.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://lngnmn2.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://lngnmn2.github.io/articles/kernigan-and-rust/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Source+Code+Pro:wght@300&display=swap" rel="stylesheet">
<link href="https://fonts.googleapis.com/css2?family=Noto+Sans:wght@300&display=swap" rel="stylesheet">
<link href="https://fonts.googleapis.com/css2?family=Noto+Serif:wght@300&display=swap" rel="stylesheet">
<style>
font-family: 'Noto Serif', serif;
font-family: 'Noto Sans', sans-serif;
font-family: 'Source Code Pro', monospace;
</style>
<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script type="text/javascript" id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script><meta property="og:url" content="https://lngnmn2.github.io/articles/kernigan-and-rust/">
  <meta property="og:site_name" content="Notes from the digital underground by Lngnmn">
  <meta property="og:title" content="Kernigan and Rust">
  <meta property="og:description" content="LOL, LMAO even.">
  <meta property="og:locale" content="en-us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="articles">
    <meta property="article:published_time" content="2025-09-02T00:00:00+05:45">
    <meta property="article:modified_time" content="2025-09-02T10:29:21+05:45">
    <meta property="article:tag" content="ADT">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Kernigan and Rust">
<meta name="twitter:description" content="LOL, LMAO even.">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Articles",
      "item": "https://lngnmn2.github.io/articles/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Kernigan and Rust",
      "item": "https://lngnmn2.github.io/articles/kernigan-and-rust/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Kernigan and Rust",
  "name": "Kernigan and Rust",
  "description": "LOL, LMAO even.",
  "keywords": [
    "ADT"
  ],
  "articleBody": "https://developers.slashdot.org/story/25/08/30/044226/what-happened-when-unix-co-creator-brian-kernighan-tried-rust\nIt is a peculiar experience to know more and have a better understating that the CS celebrity, whose book you have read as a teenager.\nJust like I wrote before, C was a PHP of the 80s, if you will – a bunch of clever hacks (while PHP has nothing clever and was a Fractal Of Bad Design by an unqualified and ignorant amateurs) which allowed one to quickly “get shit done” in the way that wasn’t possible before, which is the reason behind its popularity. It also appeared to be way more “cool”, “practical” and clever than “theoretical” Algol or PL/1.\nWhile some hacks were, indeed, clever (at the time), and the “pragmatic” aspect cannot be denied, the overall design was by no means consistent, systematic or even well-thought, unlike, lets say CLU, or ML, which were “Out There”. The mature LISP implementations were also completely ignored.\nLet’s try to see things as they [really] are.\nC Is an ultimate low-level language, while it is a “high-level” over assembly and machine-level data representations. When one programs in C one is forced to think and model in terms of representations and implementation details, just like in an assembly language. Yes, C generalized a lot – the imperative control flow constructs and the primitive types, notably arrays and machine-level array-based ASCII strings, but all this was, again, in terms of the details of the underlying hardware and data representations.\nThe really big and fundamental idea of truly high-level programming with Abstract Data Types and Data Abstractions (Liskov, CLU) and Abstract Control Flow – composeable abstract interfaces (ML, LISP) were completely ignored.\nThis results in a poor support for abstraction and non-leaking ADTs in C, with focus on how everything maps to an underlying hardware representations (how the crappy enums, instead of proper algebraic sum-types, map to integers, how the structs map to memory layouts, etc).\nThe “pragmatic” C programmers, who are not aware of the proper theoretical FP concepts, derived from advanced abstract algebra – the very way in which these generalized algebraic structures has been captured and defined – are forced to think in terms of these low-level details and representations, which is a leakage of abstraction and a violation of the abstraction principle itself. Just like webshit coders were unaware of what a fucking abomination that PHP 2.0 was.\nAgain, this is not like some option, you know. This is fundamental flaw of the language design – no proper support for proper abstraction, in principle. No way to program in a high-level way, in terms of abstract data types and abstract control flow, even if one wishes to – everything leaks everything else, literally.\nThe last 60 years of programming language semantics research, however, concluded that the only way to properly support abstraction is through a systematic and consistent design of the language semantics, which is what modern languages like ML, Haskell, Scala, Rust, etc do.\nThe most important principle is that one has to think, model and program at the same higher level of abstraction as the concepts of the problem domain, and not in terms of the conceptually irrelevant underlying implementation details and machine representations. Ideally, there must be a one-to-one mapping between the concepts of the problem domain and the data abstractions defined in terms of a programming language semantics. “Data dominates”, you know.\nNot just that, but it was well-understood that the Algebraic Data Types – sum-types, product types and function types is all you need, and that these has to be truly abstract, parameterized and composeable, to be able to model any complex data abstractions in a systematic way. This is what ML, Haskell, Scala, etc do.\nThe last real major innovation was the formulation of Type-classes by Wadler, which is just a very clever formalization of the universal mathematical notion of such that at the level of abstract interfaces – proper bounds on sets of abstract interfaces. Notice that “abstract” here is absolutely necessary. Notice that all the “individual components” of the type-classes formulation are just well-understood rigorous mathematical notions, such as Equality or an Ordering.\nEven without these, the use of just proper Algebraic Data Types alone (and the “new-types”) would lead to an enlightening experience as in “Where Is The Code”, of Scott Wlaschin. This is not something random or arbitrary in it.\nOne more time – all the errors, complexity, verbosity and imperative “unsafety” arise from mixing the irrelevant levels of abstraction – high level concepts of the problem domain, with low-level language and implementation details and representations. This is the source of Java’s retarded verbosity, C’s inherent unsafety, C++’s explosive complexity, etc. Staying abstract and high-level, while maintaining the one-to-one correspondence between the hierarchy of the layers of complexity in the problem domain concepts and the modular, layered stricture of the hierarchy of abstractions in terms of a programming language, at the same level of abstraction, is not optional, but is a fundamental requirement for any non-trivial software system.\nYes, here I am basically paraphrasing the Barbara Liskov’s book, but it does not make these principles less fundamental and less ignored by C designers. Kernigan embarrased himself as an ignorant old fool (ignorant of all the fundamental results of the last 60 years of programming language semantics research).\nThis is not the end of the story. The proper understanding of “what Rust did right” and why it is the right way (and is the only way, which cannot be refuted) is the next level up.\nLets face some reality for a change. Strings are no longer ASCIIZ. Period. The type “char” itself and the assumption that 1 char = 1 byte is no longer valid. This breaks the “C strings” and all the clever imperative looping hacks and indexing tricks around them. It is gone, just accept the reality as it is. The way more complicated proper unicode strings require proper abstraction barriers and proper, non-leaking abstractions (high level libraries based on ADTs) but C lacks the required proper semantics and even necessary typing support – both C and C++ have primitive, ad-hoc unsound type system.\nProcesses are no longer totally isolated. Enforced shared mutability destroys all the naive assumptions about the validity of the data in an imperative memory-locations overwriting (destructively updating) language.\nAny process can be “swapped out” between any two imperative instructions (by the kernel) and god knows what will happen before it resumes, so all the in imperative code flows assumptions are broken – by the time the very next imperative command will be executed the data could be invalidated in many ways.\nAn OS can move your data in memory at a whim, invalidating your addresses and any address arithmetic, but not the offsets, which are the proper notion of a reference within a more realistic and RAII-like restricted memory model.\nAs the direct consequences of the above, all structs with malloc‘ed addresses in them (not the proper “abstract” offsets) are fucked up in principle. It is when, not if potential but inevitable UB.\nIn short, the simplistic “C model” is totally broken, so all its assumptions are no longer valid, and all the clever hacks, like imperative looping and indexing, the char and string “abstractions” are flawed and, indeed, unsafe. It is that simple.\nNotice that imperative and OO-memed C++ cannot solve the “invalidation problem” – unrestricted (by the type system) arbitrary mutations are unsolvable in principle (a well-understood fundamental finding, which goes all the back to Joe Armstrong and Erlang research, and even to the foundations of the classic ML).\nEverything which has been, indeed, very cool and clever in the late 70s, with all the simplistic hardware of the time is no longer relevant or even usable. Just face these facts.\nAs long as the underlying hardware and OS “guarantees” and representations are no longer outstanding, everything collapses and keeping using an inherently, by design low-level language for a high-level ADT-based programming (for which is its not suitable at all and was never designed for) is just plain and dangerous stupidity, fueled by the Sunken Costs Fallacy and simply refusal to see things as they are to avoid the pain of the Cognitive Dissonance (with What Is).\nSo, what Rust did “just right”\nthe move semantics by default (one of its major innovations, which prevent nasty and subtle aliasing bugs which even Java has infested with). formalizing and restricting the semantics of references as only offsets, to cope with possibility of moving the data to a different memory location. establishing a clear distinction at the type-level between mutable reference (modeled as FP ref types) and immutable references (pointers as offsets, not addresses) enforcing the necessary constraint of either at most one mutable reference or any number of read-only “references” at a compile-time (at the AST level) adding traits, which are misunderstood Wadler’s type-classes and building the standard library on top of them (another major innovation – necessary bounds on abstract interfaces). emphasis on using the iterator abstraction (B. Liskov, again) and other standardized method and abstract interface’s chaining or composition. the impl blocks, which are the way of reducing cognitive load by clearly separating the implementation details from (more-or-less) abstract interfaces. The list is by no means exhaustive, but even these alone are the major, fundamental advances from C or C++ or any other Algol-style memory-location based imperative languages. This is what Kernigan missed out and is ignorant of.\nTogether, these complementing each other decisions at the level of the language semantics allows one to define and implement data abstractions out of proper fundamental building blocks (slightly crippled Algebraic Data Types) and to stay high-level, so the one-to-one correspondence betwen the layers of abstractions (and the necessary abstraction barriers) of the domain and code will be established and maintained and the code will be less cluttered with the irrelevant low level implementation and representation details, just as per the fundamental Abstraction Principle of Barbara Liskov. Now you know this too.\n",
  "wordCount" : "1660",
  "inLanguage": "en",
  "datePublished": "2025-09-02T00:00:00+05:45",
  "dateModified": "2025-09-02T10:29:21+05:45",
  "author":[{
    "@type": "Person",
    "name": "lngnmn2@yahoo.com"
  }],
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://lngnmn2.github.io/articles/kernigan-and-rust/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Notes from the digital underground by Lngnmn",
    "logo": {
      "@type": "ImageObject",
      "url": "https://lngnmn2.github.io/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://lngnmn2.github.io/" accesskey="h" title="Notes from the digital underground by Lngnmn (Alt + H)">Notes from the digital underground by Lngnmn</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://lngnmn2.github.io/about/" title="About me.">
                    <span>About me.</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title entry-hint-parent">
      Kernigan and Rust
    </h1>
    <div class="post-description">
      LOL, LMAO even.
    </div>
    <div class="post-meta"><span title='2025-09-02 00:00:00 +0545 +0545'>September 2, 2025</span>&nbsp;·&nbsp;lngnmn2@yahoo.com

</div>
  </header> 
  <div class="post-content"><p><a href="https://developers.slashdot.org/story/25/08/30/044226/what-happened-when-unix-co-creator-brian-kernighan-tried-rust">https://developers.slashdot.org/story/25/08/30/044226/what-happened-when-unix-co-creator-brian-kernighan-tried-rust</a></p>
<p>It is a peculiar experience to know more and have a better understating that the CS celebrity, whose book you have read as a teenager.</p>
<p>Just like I wrote before, C was a PHP of the 80s, if you will &ndash; a bunch of clever hacks (while PHP has nothing clever and was a <em>Fractal Of Bad Design</em> by an unqualified and ignorant amateurs) which allowed one to quickly &ldquo;get shit done&rdquo; in the way that  wasn&rsquo;t possible before, which is the reason behind its popularity. It also appeared to be way more &ldquo;cool&rdquo;, &ldquo;practical&rdquo; and clever than &ldquo;theoretical&rdquo; Algol or PL/1.</p>
<p>While some hacks were, indeed, clever (at the time), and the &ldquo;pragmatic&rdquo; aspect cannot be denied, the overall design was by no means consistent, systematic or even well-thought, unlike, lets say CLU, or ML, which were &ldquo;Out There&rdquo;. The mature LISP implementations were also completely ignored.</p>
<p>Let&rsquo;s try to see things as they [really] are.</p>
<p>C Is an ultimate <em>low-level</em> language, while it is a &ldquo;high-level&rdquo; over assembly and machine-level data representations.  When one programs in C one  is forced to think and model in terms of representations and implementation details, just like in an assembly language. Yes, C generalized a lot &ndash; the imperative control flow constructs and the primitive types, notably arrays and machine-level array-based ASCII strings, but  all this was, again, in terms of the details of the underlying hardware and data representations.</p>
<p>The really <em>big and fundamental idea</em> of truly <em>high-level</em> programming with Abstract Data Types and Data Abstractions (Liskov, CLU) and Abstract Control Flow &ndash; composeable abstract interfaces  (ML, LISP) were completely ignored.</p>
<p>This results in a poor support for abstraction and non-leaking ADTs in C, with focus on how everything maps to an underlying hardware representations (how the crappy enums, instead of proper algebraic sum-types, map to integers, how the structs map to memory layouts, etc).</p>
<p>The &ldquo;pragmatic&rdquo; C programmers, who are not aware of the proper theoretical FP concepts, derived from  advanced abstract algebra &ndash; the very way in which these generalized algebraic structures has been captured and defined &ndash; are forced to think in terms of these low-level details and representations, which is a <em>leakage of abstraction</em> and a <em>violation of the abstraction principle itself</em>.  Just like webshit coders were unaware of what a fucking abomination that PHP 2.0 was.</p>
<p>Again, this is not like some option, you know. This is fundamental flaw of the language design &ndash; no proper support for proper abstraction, in principle. No way to program in a high-level way, in terms of abstract data types and abstract control flow, even if one wishes to &ndash; everything leaks everything else, literally.</p>
<p>The last 60 years of programming language <em>semantics</em> research, however, concluded that the only way to properly support abstraction is through a systematic and consistent design of the language semantics, which is what modern languages like ML, Haskell, Scala, Rust, etc do.</p>
<p>The most important principle is that one has to think, model and program at <em>the same higher level of abstraction</em> as the concepts of the problem domain, and <em>not</em> in terms of the conceptually irrelevant underlying implementation details and machine representations. Ideally, there must be a <em>one-to-one mapping</em> between the concepts of the problem domain and the data abstractions defined in terms of a programming language <em>semantics</em>. &ldquo;Data dominates&rdquo;, you know.</p>
<p>Not just that, but it was well-understood that the Algebraic Data Types &ndash; sum-types, product types and function types <em>is all you need</em>, and that these has to be truly abstract, parameterized and composeable, to be able to model any complex data abstractions in a systematic way. This is what ML, Haskell, Scala, etc do.</p>
<p>The last real major innovation was the formulation of Type-classes by Wadler, which is just a very clever formalization of the universal mathematical notion of <em>such that</em> at the level of <em>abstract interfaces</em> &ndash; proper bounds on sets of abstract interfaces. Notice that &ldquo;abstract&rdquo; here is absolutely necessary. Notice that all the &ldquo;individual components&rdquo; of the type-classes formulation are  just well-understood rigorous mathematical notions, such as Equality or an Ordering.</p>
<p>Even without these, the use of just <em>proper</em> Algebraic Data Types alone (and the &ldquo;new-types&rdquo;) would lead to an enlightening experience as in &ldquo;<em>Where Is The Code</em>&rdquo;, of Scott Wlaschin. This is not something random or arbitrary in it.</p>
<p>One more time &ndash; all the errors, complexity, verbosity and imperative &ldquo;unsafety&rdquo; arise from mixing the irrelevant levels of abstraction &ndash; high level concepts of the problem domain, with low-level language and implementation details and representations. This is the source of Java&rsquo;s retarded verbosity, C&rsquo;s inherent unsafety, C++&rsquo;s  explosive complexity, etc. Staying abstract and high-level, while maintaining the one-to-one correspondence between the hierarchy of the layers of complexity in the  problem domain concepts and the modular, layered stricture of the  hierarchy of abstractions in terms of a programming language, <em>at the same level of abstraction</em>, is not optional, but is a <em>fundamental</em> requirement for any non-trivial software system.</p>
<p>Yes, here I am basically paraphrasing the Barbara Liskov&rsquo;s book, but it does not make these principles less fundamental and less ignored by C designers. Kernigan embarrased himself as an ignorant old fool (ignorant of all the fundamental results of the last 60 years of programming language semantics research).</p>
<p>This is not the end of the story. The proper understanding of &ldquo;what Rust did right&rdquo;  and <em>why it is  the right way</em> (and is the only way, which cannot be refuted) is the next level up.</p>
<p>Lets face some reality for a change. Strings are no longer ASCIIZ. Period. The type &ldquo;char&rdquo; itself and the assumption that 1 char = 1 byte is no longer valid.  This breaks the &ldquo;C strings&rdquo; and all the clever imperative looping hacks and indexing tricks around them. It is gone, just accept the reality as it is. The way more complicated proper unicode strings require proper abstraction barriers and proper, non-leaking abstractions (high level libraries based on ADTs) but C lacks the required proper semantics and even necessary typing support &ndash; both C and C++ have primitive, ad-hoc unsound type system.</p>
<p>Processes are no longer totally isolated. Enforced shared mutability destroys all the naive assumptions about the validity of the data in an imperative memory-locations overwriting (destructively updating) language.</p>
<p>Any process can be &ldquo;swapped out&rdquo; between any two imperative instructions (by the kernel) and god knows what will happen before it resumes, so all the in imperative code flows assumptions are broken &ndash; by the time the very next imperative command will be executed the data could be invalidated in many ways.</p>
<p>An OS can move your data in memory at a whim, invalidating your addresses and any address arithmetic, but <em>not the offsets</em>, which are <em>the proper notion of a reference</em> within a more realistic and RAII-like restricted memory model.</p>
<p>As the direct consequences of the above, all <code>structs</code> with <code>malloc</code>&lsquo;ed <em>addresses</em> in them (not the proper &ldquo;abstract&rdquo; offsets) are fucked up in principle. It is <em>when, not if</em> potential but inevitable UB.</p>
<p>In short, the simplistic &ldquo;C model&rdquo; is totally broken, so all its assumptions are no longer valid, and all the clever hacks, like imperative looping and indexing, the char and string  &ldquo;abstractions&rdquo; are flawed and, indeed, unsafe. It is that simple.</p>
<p>Notice that <em>imperative</em> and OO-memed C++ cannot solve the &ldquo;invalidation problem&rdquo; &ndash; unrestricted (by the type system) arbitrary mutations are unsolvable in principle (a well-understood fundamental finding, which goes all the back to Joe Armstrong and Erlang research, and even to the foundations of the classic ML).</p>
<p>Everything which has been, indeed, very cool and clever in the late 70s, with all the simplistic hardware of the time is no longer relevant or even usable. Just face these facts.</p>
<p>As long as the underlying hardware and OS &ldquo;guarantees&rdquo; and representations are no longer outstanding, everything collapses and keeping using an inherently, by design low-level language for a high-level ADT-based programming (for which is its not suitable at all and was never designed for) is just plain and dangerous stupidity, fueled by the Sunken Costs Fallacy and simply refusal to see things as they are to avoid the pain of the Cognitive Dissonance (with What Is).</p>
<p>So, what Rust did &ldquo;just right&rdquo;</p>
<ul>
<li>the move semantics by default (one of its major innovations, which prevent nasty and subtle aliasing bugs which even Java has infested with).</li>
<li>formalizing and restricting the semantics of references as <em>only offsets</em>, to cope with possibility of moving the data to a different memory location.</li>
<li>establishing a clear distinction at the type-level between mutable reference (modeled as FP ref types) and immutable references (pointers as offsets, <em>not addresses</em>)</li>
<li>enforcing the <em>necessary</em> constraint of either <em>at most one mutable reference</em> or any number of read-only &ldquo;references&rdquo;  at a compile-time (at the AST level)</li>
<li>adding traits, which are misunderstood Wadler&rsquo;s type-classes and building the standard library on top of them (another major innovation &ndash; necessary bounds on abstract interfaces).</li>
<li>emphasis on using the iterator abstraction (B. Liskov, again) and other standardized method and abstract interface&rsquo;s chaining or <em>composition</em>.</li>
<li>the <code>impl</code> blocks, which are the way of reducing cognitive load by clearly separating the implementation details from (more-or-less) abstract interfaces.</li>
</ul>
<p>The list is by no means exhaustive, but even these alone are the major, fundamental advances from C or C++  or any other Algol-style memory-location based imperative languages. This is what Kernigan missed out and is ignorant of.</p>
<p>Together, these complementing each other decisions at the level of the language semantics allows one to define and implement data abstractions out of proper fundamental building blocks (slightly crippled Algebraic Data Types)  and to stay <em>high-level</em>, so the one-to-one correspondence betwen the layers of abstractions (and the necessary abstraction barriers) of the domain and code will be established and maintained and the code will be less cluttered with the irrelevant low level implementation and representation details, just as per the fundamental Abstraction Principle of Barbara Liskov. Now you know this too.</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://lngnmn2.github.io/tags/adt/">ADT</a></li>
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="https://lngnmn2.github.io/">Notes from the digital underground by Lngnmn</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
