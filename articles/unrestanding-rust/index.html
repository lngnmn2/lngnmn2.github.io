<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Understanding Rust | Notes from the digital underground by Lngnmn</title>
<meta name="keywords" content="rust, imperative, borrowing, borrow checker, ownership, ADT">
<meta name="description" content="The Rust programming language has been hyped as a system programming language, which implies that it has to have an explicit &ldquo;access&rdquo; to the hardware-level abstractions, such as the Stack, the Heap and the Procedures, together with the operating system-level abstractions, such as following the particular calling conventions (a set of standardized interfaces) for an &ldquo;arch and OS /duo&rdquo;, and to be &ldquo;aware of&rdquo; the ABIs in general.
Overview Rust is, in principle, an imperative language.">
<meta name="author" content="&lt;lngnmn2@yahoo.com&gt;">
<link rel="canonical" href="https://lngnmn2.github.io/articles/unrestanding-rust/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.5cfc680b1eeaeef9efbced92d46c2a9e876b72ee14fba85846afc4cff9e6e6f8.css" integrity="sha256-XPxoCx7q7vnvvO2S1Gwqnodrcu4U&#43;6hYRq/Ez/nm5vg=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js" integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG&#43;9vmJ0cTS&#43;ovo0FeA="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://lngnmn2.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://lngnmn2.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://lngnmn2.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://lngnmn2.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://lngnmn2.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Source+Code+Pro:wght@300&display=swap" rel="stylesheet">
<link href="https://fonts.googleapis.com/css2?family=Noto+Sans:wght@300&display=swap" rel="stylesheet">
<link href="https://fonts.googleapis.com/css2?family=Noto+Serif:wght@300&display=swap" rel="stylesheet">
<style>
font-family: 'Noto Serif', serif;
font-family: 'Noto Sans', sans-serif;
font-family: 'Source Code Pro', monospace;
</style>
<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script type="text/javascript" id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script><meta property="og:title" content="Understanding Rust" />
<meta property="og:description" content="The Rust programming language has been hyped as a system programming language, which implies that it has to have an explicit &ldquo;access&rdquo; to the hardware-level abstractions, such as the Stack, the Heap and the Procedures, together with the operating system-level abstractions, such as following the particular calling conventions (a set of standardized interfaces) for an &ldquo;arch and OS /duo&rdquo;, and to be &ldquo;aware of&rdquo; the ABIs in general.
Overview Rust is, in principle, an imperative language." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://lngnmn2.github.io/articles/unrestanding-rust/" /><meta property="article:section" content="articles" />
<meta property="article:published_time" content="2023-07-15T00:00:00+05:45" />
<meta property="article:modified_time" content="2023-07-15T19:45:06+05:45" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Understanding Rust"/>
<meta name="twitter:description" content="The Rust programming language has been hyped as a system programming language, which implies that it has to have an explicit &ldquo;access&rdquo; to the hardware-level abstractions, such as the Stack, the Heap and the Procedures, together with the operating system-level abstractions, such as following the particular calling conventions (a set of standardized interfaces) for an &ldquo;arch and OS /duo&rdquo;, and to be &ldquo;aware of&rdquo; the ABIs in general.
Overview Rust is, in principle, an imperative language."/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Articles",
      "item": "https://lngnmn2.github.io/articles/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Understanding Rust",
      "item": "https://lngnmn2.github.io/articles/unrestanding-rust/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Understanding Rust",
  "name": "Understanding Rust",
  "description": "The Rust programming language has been hyped as a system programming language, which implies that it has to have an explicit \u0026ldquo;access\u0026rdquo; to the hardware-level abstractions, such as the Stack, the Heap and the Procedures, together with the operating system-level abstractions, such as following the particular calling conventions (a set of standardized interfaces) for an \u0026ldquo;arch and OS /duo\u0026rdquo;, and to be \u0026ldquo;aware of\u0026rdquo; the ABIs in general.\nOverview Rust is, in principle, an imperative language.",
  "keywords": [
    "rust", "imperative", "borrowing", "borrow checker", "ownership", "ADT"
  ],
  "articleBody": "The Rust programming language has been hyped as a system programming language, which implies that it has to have an explicit “access” to the hardware-level abstractions, such as the Stack, the Heap and the Procedures, together with the operating system-level abstractions, such as following the particular calling conventions (a set of standardized interfaces) for an “arch and OS /duo”, and to be “aware of” the ABIs in general.\nOverview Rust is, in principle, an imperative language. The order of statements matters (a lot, giving the changes of ownership), expressions are just an addition, and there is no (and never will be) referential transparency.\nEveryone who talks about Rust as a “almost a functional language” or a “language much like Standard ML” is an unqualified clueless bullshitter. Imperative code (flows of statements) and the referential transparency property are alternatives - it is either one or another.\nFor an imperative language one has to trace or simulate in ones mind the flow of execution of statements in order to understand the program. Only with this mental tracing one could “see” the current state of the system as a current “snapshot” of all its memory locations, which is what variables are in imperative languages.\nThe concurrent multi-threaded access and destructive mutations together result in a non-determinism, so such a “snapshot” of all the variables cannot be obtained in principle (only a possibly infinite set of all possible such snapshots) .\nIn the classic languages we have immutable bindings and all the “state” is wrapped and “hidden” inside of closures and is still described declaratively (what eventually has to be done with it in all possible cases).\nThe principles The Rust compiler imposes (and reinforces) a strict discipline of what can be done with variables and references, and given that, does the “tracing” for you to make sure that certain conditions (situations) do not arise – it signals an error at a compile time (instead of producing a runtime errors as a result of a runtime checks).\nThe real major innovation is to threat all the references (specialization of pointers, which are just offsets) “explicitly” by restricting and formalizing their possible “behavior”. References became “typed” or lifted into (are recognized by) the type system.\nMaking the imperative notion of an “ownership” – which variable has the data in memory right now (in time) – explicit, and tracked by the compiler, is another innovation.\nIn the Classic languages we have no notion of time, which is, in principle, the right understanding.\nThe rather amateur and awkward notions of “borrows”, “permissions” and “lifetimes” have been introduced to explain and implement the typing rules.\nThe borrows from FP A few fundamental concepts has been borrowed from the Classic World. The refs from Standard ML (where they are part of the core language) and from Haskell, where they are just an Abstract Data Type, defined in the standard library.\nIn these languages the refs first-class values, which themselves are immutable. Semantically they are similar to syntactic closures, which capture (and carry along) all the values of its bindings.\nThe fundamental referential transparency property still holds for refs as immutable bindings, so there is no imperative issues with mutation and (together with) aliasing.\nRefs are passed along explicitly, and being an ADT (or even an instance of a Monad) protect the “state” (actual values) from being leaked (or even observed).\nThe rules Again, since Rust is an imperative language, so the notions of “time” and flow of control are central to simulating and thus understanding of the current state of a program.\nRust formalized and restricts the possible behaviors (in the code) by enforcing the set of informal (but actually implemented inside the compiler) rules.\nVariables are locations in memory (either on the stack or the heap). Variables or function arguments “own” the values in memory. A single owner at any time. Ownership “moves” between owners. References do not “own” the values they refer to. Variables do. Any number of Immutable references to a variable are allowed. At most one Mutable reference to a variable (which owns) at a time. Taking a mutable reference (moment in time) invalidates all the other refs. Change in (moving of an) ownership invalidates prior variables (in time). “Dropping” of the last “owner” returns the ownership to the previous one. Nothing to see there Nothing is “profound” there. It is just a systematic attempt to formalize and restrict the possible behavior of an imperative code, by borrowing some fundamental ideas from the Classic Languages.\nAn advanced imperative language Aside from the restrictions and rules described above, Rust is just an ordinary imperative language, with all the usual imperative issues, just as with an assembly language, which is an “ultimate location-based imperative code”.\nEverything is a location in memory (either on the stack, the heap or in the registers). The content is being “moved” (actually - copied) between locations (which include registers).\nThere is a reason why the most used instructions is called mov. It implicitly signals an invalidation of “the source”, and that “the destination” is now the right (current) location of the content.\nUsing the “old locations” thus is a fundamental imperative problem (among others).\nThe procedures calling issues are still out there\npassing by value (a copy) passing by a reference (a copy of a pointer) returning by a value (a copy) returning a reference (a pointer to a location) The Move semantics by default Rust “moves” the contents of a variable in assignment statements and “passing by value” procedure calls by implicitly invalidating (making inaccessible) the “source” location for any code that follows (in time and in the same scope).\nC and C++ copy contents of variables in assignment and procedure calls. C++ implements the move semantics explicitly via wrapping (std::move).\nThe concepts Less wrong with less bullshit.\nVariable Semantically equivalent to a named memory location (either on the stack or on the heap) with has an implicit address (an offset) and an explicit name (a symbolic reference) associated with it.\nA variable is dropped when the control reaches the end of its scope. For a wrapped types “destructors” are guaranteed to be called.\nThis is similar to RAII (which is a set of rules enforced by the compiler) of C++.\nUnlike C++, however, this is not optional, is implicit and is uniformly enforced by the compiler (for every variable of any type).\nReference A “numeric reference” (an offset in bytes) also known as an address of a location in memory (either on the stack or on the heap) which is being used as a storage of the contents of some variable.\nOwnership Which particular memory location (an imperative variable) currently (right now in time) holds the current (the most recent in time) copy of a contents (the data).\nThis information is systematically being collected, maintained and used by the type system to prevent so-called “undefined behavior” or an “unsafe use” of the older (in time) contents of variables (memory locations).\nMoving of the ownership A variable becomes an “owner” of the contents of the “source” as a result of the imperative assignment operation (from a source to the target), which is technically a copying (without erasing the contents at the source location) but conceptually a “move”, since at a CPU level the mov instruction is used.\nThe abstract “ownership” thus “moves” (inside the compiler) together with the “concrete” contents (between particular memory locations tracked by the compiler).\nA function parameter becomes an owner of the contents when a procedure is being called with passing by value semantics.\nWhen a procedure being called with the passing by a reference semantics (explicitly uses a reference as the types of its argument) the ownership of the contents is does not change.\nBorrowing Taking a reference without taking an “ownership”. The “owner” (the variable) still owns what you “took”.\nThe concept is logically flawed because a reference (a specialization of a pointer) is by defending not the same as the content of a variable (in a particular location in memory). A “reference” is a pointer to (an offset or an address of) that very location.\nThe borrow-checker The part of an implementation of the type system, which checks and reinforces the rules for references, both mutable and immutable (as being implicitly “typed”).\nLifetime The principle: No reference (or a “borrow”) can ever /outlive the “owner”.\nOnce the “owner” goes out of the scope (being dropped) the ownership is “returned” to the previous owner, if any\nOR\nThe contents is deallocated if this was the only “owner”.\nWrapping in ADTs Just like any other languages, Rust uses Abstract Data Types (ADTs, popularized by Barbara Liskov) to wrap and hide the “primitives”, and to provide “richer” abstractions on top of the primitives.\nThe notion of an ADT is more general that any particular programming language, and can be traced back to how mathematicians define their abstractions in terms of a set of all possible operations and an implicit set of relations or “laws” among them).\nThus the notion of an array is not just an offset to a continuous block of memory with syntactic sugar around the offset calculation and dereferencing, but become an ADT, which wraps additional values, such as size and capacity together with an actual pointer into a structured value.\nThese implementation details, however, has been hidden behind an ADT (such as Vec) and only the abstracted out interface has been exported.\nSlices are just an ADT with a corresponding syntactic sugar.\nIn Rust an ADT could be defined as a struct (which is a set of all values with have a particular inner structure) or as a trait (which defines a subset of values that implements a particular set of required interfaces along with implicit “laws” and invariants) or as combinations of traits.\nThe “smart pointers” which “own” the data allocated on the heap are just ADTs.\nEverything “high-level” within Rust is defined as some ADTs, beginning from the most basic Box and Rc types, which serve as the building blocks for Vec and the other collection types.\nThe ADTs and the Duck-Typing are the universal notions of all programming.\nCopying Copy-able ADTs (“values” of which can be copied) have to implement the Copy trait.\n",
  "wordCount" : "1703",
  "inLanguage": "en",
  "datePublished": "2023-07-15T00:00:00+05:45",
  "dateModified": "2023-07-15T19:45:06+05:45",
  "author":[{
    "@type": "Person",
    "name": "\u0026lt;lngnmn2@yahoo.com\u0026gt;"
  }],
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://lngnmn2.github.io/articles/unrestanding-rust/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Notes from the digital underground by Lngnmn",
    "logo": {
      "@type": "ImageObject",
      "url": "https://lngnmn2.github.io/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://lngnmn2.github.io/" accesskey="h" title="Notes from the digital underground by Lngnmn (Alt + H)">Notes from the digital underground by Lngnmn</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://lngnmn2.github.io/about/" title="About me.">
                    <span>About me.</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title">
      Understanding Rust
    </h1>
    <div class="post-meta"><span title='2023-07-15 00:00:00 +0545 +0545'>July 15, 2023</span>&nbsp;·&nbsp;&lt;lngnmn2@yahoo.com&gt;

</div>
  </header> 
  <div class="post-content"><p>The Rust programming language has been <em>hyped</em> as a <em>system programming language</em>,
which implies that it has to have an explicit &ldquo;access&rdquo; to the <em>hardware-level
abstractions</em>, such as the Stack, the Heap and the Procedures, together with the
<em>operating system-level abstractions</em>, such as following the particular <em>calling conventions</em>
(a set of <em>standardized interfaces</em>) for an <em>&ldquo;arch and OS /duo&rdquo;</em>, and to be &ldquo;aware of&rdquo;
the ABIs in general.</p>
<h2 id="overview">Overview<a hidden class="anchor" aria-hidden="true" href="#overview">#</a></h2>
<p>Rust is, in principle, an <em>imperative language</em>. The order of <em>statements</em> matters
(a lot, giving the changes of ownership), <em>expressions</em> are just an addition, and
there is no (and never will be) <em>referential transparency</em>.</p>
<p>Everyone who talks about Rust as a &ldquo;almost a functional language&rdquo; or a &ldquo;language
much like Standard ML&rdquo; is an unqualified clueless bullshitter. Imperative code (flows
of statements) and the referential transparency property are <em>alternatives</em> -
it is <em>either</em> one or another.</p>
<p>For an imperative language one has to <em>trace or simulate in ones mind</em> the flow of
execution of statements in order to understand the program. Only with this mental tracing
one could &ldquo;see&rdquo; the current <em>state</em> of the system as a current &ldquo;snapshot&rdquo; of all
its memory locations, which is what <em>variables</em> are in imperative languages.</p>
<p>The concurrent multi-threaded access and destructive mutations <em>together</em> result
in a <em>non-determinism</em>, so such a &ldquo;snapshot&rdquo; of all the variables <em>cannot be obtained</em> in
principle (only a possibly infinite set of all possible such snapshots) .</p>
<p>In the classic languages we have <em>immutable bindings</em> and all the &ldquo;state&rdquo; is
wrapped and &ldquo;hidden&rdquo; inside of <em>closures</em> and is still <em>described declaratively</em> (what
<em>eventually</em> has to be done with it <em>in all possible cases</em>).</p>
<h2 id="the-principles">The principles<a hidden class="anchor" aria-hidden="true" href="#the-principles">#</a></h2>
<p>The Rust compiler imposes (and reinforces) a strict <em>discipline</em> of what can be
done with <em>variables</em> and <em>references</em>, and given that, does the &ldquo;tracing&rdquo; for you to make
sure that certain conditions (situations) do not arise &ndash; it signals an error at
a compile time (instead of producing a runtime errors as a result of a runtime checks).</p>
<p>The real <em>major innovation</em> is to threat <em>all the references</em> (specialization of
<em>pointers</em>, which are just <em>offsets</em>) &ldquo;explicitly&rdquo; by restricting and <em>formalizing</em>
their possible &ldquo;behavior&rdquo;. References became &ldquo;typed&rdquo; or lifted into (are recognized
by) the type system.</p>
<p>Making the imperative notion of an &ldquo;ownership&rdquo; &ndash; which variable has the data in
memory <em>right now (in time)</em> &ndash; explicit, and tracked by the compiler, is another innovation.</p>
<p>In the Classic languages we have no notion of time, which is, in principle, <em>the
right understanding</em>.</p>
<p>The rather amateur and awkward notions of &ldquo;borrows&rdquo;, &ldquo;permissions&rdquo; and
&ldquo;lifetimes&rdquo; have been introduced to explain and implement the <em>typing rules</em>.</p>
<h2 id="the-borrows-from-fp">The borrows from FP<a hidden class="anchor" aria-hidden="true" href="#the-borrows-from-fp">#</a></h2>
<p>A few fundamental concepts has been <em>borrowed</em> from the Classic World. The <code>refs</code>
from Standard ML (where they are part of the core language) and from Haskell,
where they are just an Abstract Data Type, defined in the standard library.</p>
<p>In these languages the <code>refs</code> first-class values, which themselves are immutable.
Semantically they are similar to syntactic closures, which capture (and carry
along) all the values of its <em>bindings</em>.</p>
<p>The fundamental <em>referential transparency</em> property still holds for <code>refs</code> as
<em>immutable bindings</em>, so there is no imperative issues with mutation and (together
with) aliasing.</p>
<p>Refs are passed along <em>explicitly</em>, and being an ADT (or even an instance of a
Monad) protect the &ldquo;state&rdquo; (actual values) from being <em>leaked</em> (or even observed).</p>
<h2 id="the-rules">The rules<a hidden class="anchor" aria-hidden="true" href="#the-rules">#</a></h2>
<p>Again, since Rust is an imperative language, so the notions of &ldquo;time&rdquo; and flow of
control are central to simulating and thus understanding of the current state of
a program.</p>
<p>Rust formalized and restricts the possible behaviors (in the code) by enforcing
the set of informal (but actually implemented inside the compiler) <em>rules</em>.</p>
<h3 id="variables-are-locations-in-memory--either-on-the-stack-or-the-heap--dot">Variables are locations in memory (either on the stack or the heap).<a hidden class="anchor" aria-hidden="true" href="#variables-are-locations-in-memory--either-on-the-stack-or-the-heap--dot">#</a></h3>
<h3 id="variables-or-function-arguments-own-the-values-in-memory-dot">Variables or function arguments &ldquo;own&rdquo; the values in memory.<a hidden class="anchor" aria-hidden="true" href="#variables-or-function-arguments-own-the-values-in-memory-dot">#</a></h3>
<h3 id="a-single-owner-at-any-time-dot-ownership-moves-between-owners-dot">A single owner at any time. Ownership &ldquo;moves&rdquo; between owners.<a hidden class="anchor" aria-hidden="true" href="#a-single-owner-at-any-time-dot-ownership-moves-between-owners-dot">#</a></h3>
<h3 id="references-do-not-own-the-values-they-refer-to-dot-variables-do-dot">References do not &ldquo;own&rdquo; the values they refer to. Variables do.<a hidden class="anchor" aria-hidden="true" href="#references-do-not-own-the-values-they-refer-to-dot-variables-do-dot">#</a></h3>
<h3 id="any-number-of-immutable-references-to-a-variable-are-allowed-dot">Any number of Immutable references to a variable are allowed.<a hidden class="anchor" aria-hidden="true" href="#any-number-of-immutable-references-to-a-variable-are-allowed-dot">#</a></h3>
<h3 id="at-most-one-mutable-reference-to-a-variable--which-owns--at-a-time-dot">At most one Mutable reference to a variable (which owns) at a time.<a hidden class="anchor" aria-hidden="true" href="#at-most-one-mutable-reference-to-a-variable--which-owns--at-a-time-dot">#</a></h3>
<h3 id="taking-a-mutable-reference--moment-in-time--invalidates-all-the-other-refs-dot">Taking a mutable reference (moment in time) invalidates all the other refs.<a hidden class="anchor" aria-hidden="true" href="#taking-a-mutable-reference--moment-in-time--invalidates-all-the-other-refs-dot">#</a></h3>
<h3 id="change-in--moving-of-an--ownership-invalidates-prior-variables--in-time--dot">Change in (moving of an) ownership invalidates prior variables (in time).<a hidden class="anchor" aria-hidden="true" href="#change-in--moving-of-an--ownership-invalidates-prior-variables--in-time--dot">#</a></h3>
<h3 id="dropping-of-the-last-owner-returns-the-ownership-to-the-previous-one-dot">&ldquo;Dropping&rdquo; of the last &ldquo;owner&rdquo; returns the ownership to the previous one.<a hidden class="anchor" aria-hidden="true" href="#dropping-of-the-last-owner-returns-the-ownership-to-the-previous-one-dot">#</a></h3>
<h2 id="nothing-to-see-there">Nothing to see there<a hidden class="anchor" aria-hidden="true" href="#nothing-to-see-there">#</a></h2>
<p>Nothing is &ldquo;profound&rdquo; there. It is just a systematic attempt to formalize and
restrict the possible behavior of an <em>imperative code</em>, by borrowing some fundamental
ideas  from the Classic Languages.</p>
<h2 id="an-advanced-imperative-language">An advanced imperative language<a hidden class="anchor" aria-hidden="true" href="#an-advanced-imperative-language">#</a></h2>
<p>Aside from the restrictions and rules described above, Rust is just an ordinary
imperative language, with all the usual imperative issues, just as with an assembly
language, which is an &ldquo;ultimate location-based imperative code&rdquo;.</p>
<p>Everything is a location in memory (either on the stack, the heap or in the <em>registers</em>). The
content is being &ldquo;moved&rdquo; (actually - copied) between <em>locations</em> (which include
<em>registers</em>).</p>
<p>There is a reason why the most used instructions is called <code>mov</code>. It implicitly
signals an <em>invalidation</em> of &ldquo;the source&rdquo;, and that &ldquo;the destination&rdquo; is now the <em>right
(current) location</em> of the content.</p>
<p>Using the &ldquo;old locations&rdquo; thus is a fundamental imperative problem (among others).</p>
<p>The procedures calling issues are still out there</p>
<ul>
<li>passing by value (a copy)</li>
<li>passing by a reference (a copy of a pointer)</li>
<li>returning by a value (a copy)</li>
<li>returning a reference (a pointer to a location)</li>
</ul>
<h2 id="the-move-semantics-by-default">The Move semantics by default<a hidden class="anchor" aria-hidden="true" href="#the-move-semantics-by-default">#</a></h2>
<p>Rust &ldquo;moves&rdquo; the contents of a variable in assignment statements and &ldquo;passing by value&rdquo;
procedure calls by implicitly invalidating (making inaccessible) the &ldquo;source&rdquo;
<em>location</em> for any code that follows (in time and in the same scope).</p>
<p>C and C++ copy contents of variables in assignment and procedure calls. C++
implements the move semantics explicitly via wrapping (<code>std::move</code>).</p>
<h2 id="the-concepts">The concepts<a hidden class="anchor" aria-hidden="true" href="#the-concepts">#</a></h2>
<p>Less wrong with less bullshit.</p>
<h3 id="variable">Variable<a hidden class="anchor" aria-hidden="true" href="#variable">#</a></h3>
<p>Semantically equivalent to a <em>named</em> memory location (either on the stack
or on the heap) with has an <em>implicit</em> address (an offset) and an <em>explicit</em> name (a
symbolic reference) associated with it.</p>
<p>A variable is <em>dropped</em> when the control reaches the end of <em>its scope</em>. For a
<em>wrapped types</em> &ldquo;destructors&rdquo; are guaranteed to be called.</p>
<p>This is similar to <code>RAII</code> (which is a set of rules enforced by the compiler) of
C++.</p>
<p>Unlike C++, however, this is <em>not optional</em>, is implicit and is uniformly enforced by the
compiler (for every variable of any type).</p>
<h3 id="reference">Reference<a hidden class="anchor" aria-hidden="true" href="#reference">#</a></h3>
<p>A &ldquo;numeric reference&rdquo; (an offset in <em>bytes</em>) also known as an <em>address</em> of a
location in memory (either on the stack or on the heap) which is being used as a
<em>storage of the contents</em> of some <em>variable</em>.</p>
<h3 id="ownership">Ownership<a hidden class="anchor" aria-hidden="true" href="#ownership">#</a></h3>
<p>Which particular memory location (an <em>imperative variable</em>) currently (right now
<em>in time</em>) holds the current (the most recent in time) copy of a contents (the data).</p>
<p>This information is systematically being collected, maintained and used by the
type system to prevent so-called <em>&ldquo;undefined behavior&rdquo;</em> or an <em>&ldquo;unsafe use&rdquo;</em> of the
older (in time) contents of variables (memory locations).</p>
<h3 id="moving-of-the-ownership">Moving of the ownership<a hidden class="anchor" aria-hidden="true" href="#moving-of-the-ownership">#</a></h3>
<p>A <em>variable</em> becomes an &ldquo;owner&rdquo; of the contents of the &ldquo;source&rdquo; as a result of the
imperative assignment operation (from a source to the target), which is
technically a <em>copying</em> (without erasing the contents at the source location) but
conceptually a &ldquo;move&rdquo;, since at a CPU level the <code>mov</code> instruction is used.</p>
<p>The abstract &ldquo;ownership&rdquo; thus &ldquo;moves&rdquo; (inside the compiler) together with the
&ldquo;concrete&rdquo; contents (between particular memory locations tracked by the compiler).</p>
<p>A function parameter becomes an owner of the contents when a <em>procedure</em> is being
called with <em>passing by value</em> semantics.</p>
<p>When a procedure being called with the <em>passing by a reference</em> semantics
(explicitly uses a reference as the types of its argument) the <em>ownership of the
contents is does not change</em>.</p>
<h3 id="borrowing">Borrowing<a hidden class="anchor" aria-hidden="true" href="#borrowing">#</a></h3>
<p>Taking a <em>reference</em> without taking an &ldquo;ownership&rdquo;. The &ldquo;owner&rdquo; (the variable)
still owns what you &ldquo;took&rdquo;.</p>
<p>The concept is logically flawed because a reference (a specialization of a
<em>pointer</em>) is by defending not the same as the content of a variable (in a
particular location in memory). A &ldquo;reference&rdquo; is a <em>pointer</em> to (an <em>offset</em> or an
<em>address</em> of) that very location.</p>
<h3 id="the-borrow-checker">The borrow-checker<a hidden class="anchor" aria-hidden="true" href="#the-borrow-checker">#</a></h3>
<p>The part of an implementation of the <em>type system</em>, which checks and reinforces
<em>the rules</em> for <em>references</em>, both mutable and immutable (as being implicitly &ldquo;typed&rdquo;).</p>
<h3 id="lifetime">Lifetime<a hidden class="anchor" aria-hidden="true" href="#lifetime">#</a></h3>
<p>The principle: <em>No reference (or a &ldquo;borrow&rdquo;) can ever /outlive the &ldquo;owner&rdquo;</em>.</p>
<p>Once the &ldquo;owner&rdquo; goes out of the scope (being dropped) the ownership is
&ldquo;returned&rdquo; to the previous owner, <em>if any</em></p>
<p>OR</p>
<p>The contents is <em>deallocated</em> if this was the only &ldquo;owner&rdquo;.</p>
<h2 id="wrapping-in-adts">Wrapping in ADTs<a hidden class="anchor" aria-hidden="true" href="#wrapping-in-adts">#</a></h2>
<p>Just like any other languages, Rust uses Abstract Data Types (ADTs, popularized
by Barbara Liskov) to <em>wrap</em> and <em>hide</em> the &ldquo;primitives&rdquo;, and to provide &ldquo;richer&rdquo;
abstractions on top of the primitives.</p>
<p>The notion of an ADT is more general that any particular programming language,
and can be <em>traced back</em> to how mathematicians define their abstractions in terms
of a set of all possible operations and an implicit set of relations or &ldquo;laws&rdquo;
among them).</p>
<p>Thus the notion of an array is not just an offset to a continuous block of
memory with syntactic sugar around the offset calculation and dereferencing, but
become an ADT, which wraps additional values, such as <code>size</code> and <code>capacity</code> together
with an actual <code>pointer</code> into a <em>structured value</em>.</p>
<p>These implementation details, however, has been hidden behind an ADT (such as
<code>Vec</code>) and only the abstracted out interface has been exported.</p>
<p><code>Slices</code> are just an ADT with a corresponding <em>syntactic sugar</em>.</p>
<p>In Rust an ADT could be defined as a <code>struct</code> (which is a set of all values with
have a particular inner structure) or as a <code>trait</code> (which defines a <em>subset</em> of
values that <em>implements</em> a particular set of required interfaces along with
implicit &ldquo;laws&rdquo; and invariants) or as combinations of traits.</p>
<p>The &ldquo;smart pointers&rdquo; which &ldquo;own&rdquo; the data allocated on the heap are just ADTs.</p>
<p>Everything &ldquo;high-level&rdquo; within Rust is defined as some ADTs, beginning from the
most basic <code>Box</code> and <code>Rc</code> types, which serve as the building blocks for <code>Vec</code> and the
other collection types.</p>
<p>The <em>ADTs</em> and the <em>Duck-Typing</em> are the universal notions of all programming.</p>
<h2 id="copying">Copying<a hidden class="anchor" aria-hidden="true" href="#copying">#</a></h2>
<p><em>Copy-able</em> ADTs (&ldquo;values&rdquo; of which can be <em>copied</em>) have to implement the <code>Copy</code> <em>trait</em>.</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://lngnmn2.github.io/tags/rust/">rust</a></li>
      <li><a href="https://lngnmn2.github.io/tags/imperative/">imperative</a></li>
      <li><a href="https://lngnmn2.github.io/tags/borrowing/">borrowing</a></li>
      <li><a href="https://lngnmn2.github.io/tags/borrow-checker/">borrow checker</a></li>
      <li><a href="https://lngnmn2.github.io/tags/ownership/">ownership</a></li>
      <li><a href="https://lngnmn2.github.io/tags/adt/">ADT</a></li>
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2023 <a href="https://lngnmn2.github.io/">Notes from the digital underground by Lngnmn</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
