<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Rust 3000 | Notes from the digital underground by Lngnmn</title>
<meta name="keywords" content="imperative">
<meta name="description" content="There is another shitstorm around Rust &ndash; the just announced meme-effort to verify approximately 7500 unstafe functions in the Rust standard library.
First of all, what a joke! I never thought there are that many of em. It is easily more than the whole SML, Ocaml and Haskell standard libraries combined. Or at least of the same order.
If we want, however, to put memes aside for a while, the way to safety begins with the proper and sound principles, so the &ldquo;unsoundness bugs&rdquo; will never appear again.">
<meta name="author" content="&amp;lt;lngnmn2@yahoo.com&amp;gt;">
<link rel="canonical" href="https://lngnmn2.github.io/articles/rust-3000/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.b609c58d5c11bb90b1a54e04005d74ad1ddf22165eb79f5533967e57df9c3b50.css" integrity="sha256-tgnFjVwRu5CxpU4EAF10rR3fIhZet59VM5Z&#43;V9&#43;cO1A=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://lngnmn2.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://lngnmn2.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://lngnmn2.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://lngnmn2.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://lngnmn2.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://lngnmn2.github.io/articles/rust-3000/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Source+Code+Pro:wght@300&display=swap" rel="stylesheet">
<link href="https://fonts.googleapis.com/css2?family=Noto+Sans:wght@300&display=swap" rel="stylesheet">
<link href="https://fonts.googleapis.com/css2?family=Noto+Serif:wght@300&display=swap" rel="stylesheet">
<style>
font-family: 'Noto Serif', serif;
font-family: 'Noto Sans', sans-serif;
font-family: 'Source Code Pro', monospace;
</style>
<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script type="text/javascript" id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
  

<meta property="og:title" content="Rust 3000" />
<meta property="og:description" content="There is another shitstorm around Rust &ndash; the just announced meme-effort to verify approximately 7500 unstafe functions in the Rust standard library.
First of all, what a joke! I never thought there are that many of em. It is easily more than the whole SML, Ocaml and Haskell standard libraries combined. Or at least of the same order.
If we want, however, to put memes aside for a while, the way to safety begins with the proper and sound principles, so the &ldquo;unsoundness bugs&rdquo; will never appear again." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://lngnmn2.github.io/articles/rust-3000/" /><meta property="article:section" content="articles" />
<meta property="article:published_time" content="2024-11-24T00:00:00+05:45" />
<meta property="article:modified_time" content="2024-11-24T12:38:05+05:45" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Rust 3000"/>
<meta name="twitter:description" content="There is another shitstorm around Rust &ndash; the just announced meme-effort to verify approximately 7500 unstafe functions in the Rust standard library.
First of all, what a joke! I never thought there are that many of em. It is easily more than the whole SML, Ocaml and Haskell standard libraries combined. Or at least of the same order.
If we want, however, to put memes aside for a while, the way to safety begins with the proper and sound principles, so the &ldquo;unsoundness bugs&rdquo; will never appear again."/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Articles",
      "item": "https://lngnmn2.github.io/articles/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Rust 3000",
      "item": "https://lngnmn2.github.io/articles/rust-3000/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Rust 3000",
  "name": "Rust 3000",
  "description": "There is another shitstorm around Rust \u0026ndash; the just announced meme-effort to verify approximately 7500 unstafe functions in the Rust standard library.\nFirst of all, what a joke! I never thought there are that many of em. It is easily more than the whole SML, Ocaml and Haskell standard libraries combined. Or at least of the same order.\nIf we want, however, to put memes aside for a while, the way to safety begins with the proper and sound principles, so the \u0026ldquo;unsoundness bugs\u0026rdquo; will never appear again.",
  "keywords": [
    "imperative"
  ],
  "articleBody": "There is another shitstorm around Rust – the just announced meme-effort to verify approximately 7500 unstafe functions in the Rust standard library.\nFirst of all, what a joke! I never thought there are that many of em. It is easily more than the whole SML, Ocaml and Haskell standard libraries combined. Or at least of the same order.\nIf we want, however, to put memes aside for a while, the way to safety begins with the proper and sound principles, so the “unsoundness bugs” will never appear again.\nThe most fundamental principle is of a physical partition (or of a necessary distance) which usually represent an actual abstraction barrier.\nThe code has to be clearly partitioned at all levels. This is an old idea, and it goes back even to hardware, with the read-only segments, and what not.\nThere is a simple (but well-thought) proposal, lets call it hypothetically, Rust 3000.\nFirst, the most fundamental and the most important semantic notions has to be clearly expressed in code (syntactic forms).\nprocedures has to have its distinct keyword proc. This clearly signals and communicates that this is a procedure, NOT a function. fn is cool but stupid. (and this is the most important) an imperative assignment (to a location in memory) has to have the proper symbol :=. This is a warning signal. functions has to have its distinct keyword func. This is a referential-transparent function, and the compiler has to prove it. We also need to clearly distinguish between pure expressions and imperative statements. Stylistically, using and ! at the end of the commands would be the best. But… The second-best solution is a forced UPERCASE for the imperative crap. This will pay a lot in the long run.\nIn short, what ISN’T a math should never look like a math. Most of the confusion comes from this, and idiotic terminology, which goes all the way back to the C and the 70s, when they call imperative procedures “functions” just for fun.\nAnother great discovery is to capitalize type-names and the corresponding constructors and to use these symbols as “tags” for structural pattern-matching. There is a lot of subtlety why this feels and seems so right. Believe me, this is just the right thing to do (tagging and structural pattern-matching has been discovered by molecular biology itself).\nIf these ideas reminds one of Ada, then yes, these guys thought this out long ago.\nOne more time. The clear semantic distinction at all levels, starting from clear syntax, is the way to non-bullshit soundness.\nAnother idea is that, perhaps, at the intermediate language level, within the compiler, imperative code has to have a distinct monad-like abstraction barrier. The amazing trick which keeps Haskell pure (reverentially transparent) has to be re-used everywhere. MS did a lot of the right things in their F#.\nRight now Rust is a PHP (or Ethereum) – lots of ambitions, virtue-signalling and excitement, but lack of proper education and understanding of the principles.\nMath is a candle (which will help to dispel the darkness of ignorance), as Philip Wadler used to say from the stage so many times. Separating math from an imperative crap (which to some extend all mostly-functional languages did) is the fist required step to a real soundness.\n",
  "wordCount" : "544",
  "inLanguage": "en",
  "datePublished": "2024-11-24T00:00:00+05:45",
  "dateModified": "2024-11-24T12:38:05+05:45",
  "author":[{
    "@type": "Person",
    "name": "\u0026lt;lngnmn2@yahoo.com\u0026gt;"
  }],
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://lngnmn2.github.io/articles/rust-3000/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Notes from the digital underground by Lngnmn",
    "logo": {
      "@type": "ImageObject",
      "url": "https://lngnmn2.github.io/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://lngnmn2.github.io/" accesskey="h" title="Notes from the digital underground by Lngnmn (Alt + H)">Notes from the digital underground by Lngnmn</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://lngnmn2.github.io/about/" title="About me.">
                    <span>About me.</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title entry-hint-parent">
      Rust 3000
    </h1>
    <div class="post-meta"><span title='2024-11-24 00:00:00 +0545 +0545'>November 24, 2024</span>&nbsp;·&nbsp;&amp;lt;lngnmn2@yahoo.com&amp;gt;

</div>
  </header> 
  <div class="post-content"><p>There is another shitstorm around Rust &ndash; the just announced meme-effort to verify approximately <code>7500</code> unstafe functions in the Rust standard library.</p>
<p>First of all, what a joke! I never thought there are that many of em. It is easily more than the whole SML, Ocaml and Haskell standard libraries combined. Or at least of the same order.</p>
<p>If we want, however, to put memes aside for a while, the way to safety begins with the proper and sound principles, so the &ldquo;unsoundness bugs&rdquo; will never appear again.</p>
<p>The most fundamental principle is of a physical partition (or of a necessary distance) which usually represent an actual abstraction barrier.</p>
<p>The code has to be clearly partitioned at all levels. This is an old idea, and it goes back even to hardware, with the read-only segments, and what not.</p>
<p>There is a simple (but well-thought) proposal, lets call it hypothetically, <strong>Rust 3000</strong>.</p>
<p>First, the most fundamental and the most important <em>semantic</em> notions has to be clearly expressed in code (syntactic forms).</p>
<ul>
<li><em>procedures</em> has to have its distinct keyword <code>proc</code>. This clearly signals and communicates that this is a <em>procedure</em>, NOT a function. <code>fn</code> is cool but stupid.</li>
<li>(and this is the most important) an imperative assignment (to a location in memory) has to have <em>the proper symbol</em> <code>:=</code>. This is a warning signal.</li>
<li>functions has to have its distinct keyword <code>func</code>. This is a <em>referential-transparent</em> function, and the compiler has to prove it.</li>
</ul>
<p>We also need to clearly distinguish between <em>pure expressions</em> and <em>imperative statements</em>. Stylistically, using and <code>!</code> at the end of the commands would be the best. But&hellip;
The second-best solution is a forced UPERCASE for the imperative crap. This will pay a lot in the long run.</p>
<p>In short, what ISN&rsquo;T a math should never look like a math. Most of the confusion comes from this, and idiotic terminology, which goes all the way back to the <code>C</code> and the 70s, when they call <em>imperative procedures</em> &ldquo;functions&rdquo; just for fun.</p>
<p>Another great discovery is to capitalize <em>type-names</em> and the corresponding <em>constructors</em> and to use these symbols as &ldquo;tags&rdquo; for structural pattern-matching.  There is <em>a lot</em> of subtlety why this feels and seems  <em>so right</em>. Believe me, this is just the right thing to do (tagging and structural pattern-matching has been discovered by <em>molecular biology itself</em>).</p>
<p>If these ideas reminds one of <em>Ada</em>, then yes, these guys thought this out long ago.</p>
<p>One more time. The clear semantic distinction at all levels, starting from clear syntax, is the way to non-bullshit soundness.</p>
<p>Another idea is that, perhaps, at the intermediate language level, within the compiler, imperative code has to have a distinct <em>monad-like</em> abstraction barrier. The amazing trick which keeps Haskell pure (reverentially transparent) has to be re-used everywhere. MS did a lot of the right things in their <code>F#</code>.</p>
<p>Right now Rust is a PHP (or Ethereum) &ndash; lots of ambitions, virtue-signalling and excitement, but lack of proper education and understanding of the principles.</p>
<p><em>Math is a candle</em> (which will help to dispel the darkness of ignorance), as Philip Wadler used to say from the stage so many times. Separating math from an imperative crap (which to some extend all mostly-functional languages did) is the fist required step to a real soundness.</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://lngnmn2.github.io/tags/imperative/">Imperative</a></li>
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2024 <a href="https://lngnmn2.github.io/">Notes from the digital underground by Lngnmn</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
