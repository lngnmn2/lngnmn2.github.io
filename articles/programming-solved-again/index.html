<!DOCTYPE html>
<html lang="en" dir="auto" data-theme="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Programming solved (again) | Notes from the digital underground by Lngnmn</title>
<meta name="keywords" content="ADT, DSL, esoteric">
<meta name="description" content="Oops, I did it again">
<meta name="author" content="&amp;lt;lngnmn2@yahoo.com&amp;gt;">
<link rel="canonical" href="https://lngnmn2.github.io/articles/programming-solved-again/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.a5781257de4197b8e3d54346acdf1dd55a9ba4cb91dcace192fc1baf228c08b5.css" integrity="sha256-pXgSV95Bl7jj1UNGrN8d1VqbpMuR3KzhkvwbryKMCLU=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://lngnmn2.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://lngnmn2.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://lngnmn2.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://lngnmn2.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://lngnmn2.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://lngnmn2.github.io/articles/programming-solved-again/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
                color-scheme: dark;
            }

            .list {
                background: var(--theme);
            }

            .toc {
                background: var(--entry);
            }
        }

        @media (prefers-color-scheme: light) {
            .list::-webkit-scrollbar-thumb {
                border-color: var(--code-bg);
            }
        }

    </style>
</noscript>
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.querySelector("html").dataset.theme = 'dark';
    } else if (localStorage.getItem("pref-theme") === "light") {
       document.querySelector("html").dataset.theme = 'light';
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.querySelector("html").dataset.theme = 'dark';
    } else {
        document.querySelector("html").dataset.theme = 'light';
    }

</script><link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Source+Code+Pro:wght@300&display=swap" rel="stylesheet">
<link href="https://fonts.googleapis.com/css2?family=Noto+Sans:wght@300&display=swap" rel="stylesheet">
<link href="https://fonts.googleapis.com/css2?family=Noto+Serif:wght@300&display=swap" rel="stylesheet">
<style>
font-family: 'Noto Serif', serif;
font-family: 'Noto Sans', sans-serif;
font-family: 'Source Code Pro', monospace;
</style>
<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script type="text/javascript" id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script><meta property="og:url" content="https://lngnmn2.github.io/articles/programming-solved-again/">
  <meta property="og:site_name" content="Notes from the digital underground by Lngnmn">
  <meta property="og:title" content="Programming solved (again)">
  <meta property="og:description" content="Oops, I did it again">
  <meta property="og:locale" content="en-us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="articles">
    <meta property="article:published_time" content="2025-07-03T00:00:00+05:45">
    <meta property="article:modified_time" content="2025-07-03T12:41:34+05:45">
    <meta property="article:tag" content="ADT">
    <meta property="article:tag" content="DSL">
    <meta property="article:tag" content="Esoteric">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Programming solved (again)">
<meta name="twitter:description" content="Oops, I did it again">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Articles",
      "item": "https://lngnmn2.github.io/articles/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Programming solved (again)",
      "item": "https://lngnmn2.github.io/articles/programming-solved-again/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Programming solved (again)",
  "name": "Programming solved (again)",
  "description": "Oops, I did it again",
  "keywords": [
    "ADT", "DSL", "esoteric"
  ],
  "articleBody": "Lets “solve” programming (once again, LOL), in a couple of pages, simply because why tf not. and to put the LLMs and their shills and worshipers into shame (yes, yes, I know, they do not have any).\nWe will build a simple abstract and general “meta-theory”, which is, like a religion grounded on Buddha’s compassion, provide a foundation of peaceful and cooperating traditions, which guide people in their decision making in a overwhelmingly complex Reality by providing easy to understand and easy to apply “heuristics” or “rules of thumb”.\nThis “meta-theory”, however, is also explanatory and allows to make “testable” informed decisions, just as any truly scientific theory.\nLet’s start from the most wonderful almost metaphysical level of the “underlying structure of the Universe”, and via the recently discovered the Curry-Howard Correspondence and very related Algebraic Data Types go all the down to the boring low-level implementation details (high-level, interface-level programming is sometimes still fun).\nWhen Simon back in the sixties examined the “Architecture of Complexity”, he noticed that a particular recurrent “pattern” – a Layered Hierarchical Structure emerge again and again at all level (of abstraction).\nThis is still true, of course. It implies that the only way to program systems that mimics and represents some aspects of the Real World, is to discover and identify this inherent layered structure in the “domain” and make an one-to-one correspondence between each layer of domain to a layer of corresponding functional DSL in a program, and each distinct concept of the “domain” (at its proper level in an overall hierarchy) to a distinct type which captures and represents named concept at an appropriate level of abstraction, within is own orthogonal, self-contained, lose-coupled module.\nMichael Jackson and Barbara Liskov have taught these universal principles in the 70s (seventies, mfrs!). Simon wrote his paper in the late 60s.\nLet’s observe some more “fine” structure in the overwhelming complexity around us.\nMountain rivers and trees form what we would call Directed Graphs. What we call “derivatives” and “the chain rule” is how much each stream contributes to the overall momentum of a river, with respect of how much water it contributes and how steep it is when it joins the river.\nYes, I am tracing back the most fundamental abstract mathematical concepts all the way back to the aspects of Reality, from which they have been generalized and abstracted out. You, probably, should have such habit too.\nA mountain river is a canonical example of an emergent process caused by nothing but the Causality principle. Every process in the whole Universe is exactly like this, but the river abstraction is much more easy to comprehend.\nA tree is another such process. Trees emerge due to “localized” sub-processes, which “know nothing” about existence of anything beyond their immediate locality. All cell biology, at the levels of tissues, “works” in this way.\nThere are 3 common structural patterns in these process, which can be structurally abstracted as:\na “step” (an arrow between 2 “points”) a “join” (of two “arrows”) a “fork” (of two “arrows”) Notice that all these structures are “directed”. It is said that a “fork” and a “join” are isomorphic to each other, and, it appears that this is the case, except that the “direction of the arrows”, which is a definitive part of these very structures, has been neglected. So, no, not isomorphic.\nIt is also said that they are dual to each other – all we can do is to “reverse the direction of the arrows”. While this is a perfectly valid abstract mathematical operation, which yield a perfectly “valid” transformed abstraction, in Reality (or in this particular Universe) such “transformations” are literally impossible. The direction of the “arrows” cannot be thrown out of the window.\nEverything else can be build out of these three building blocks. Yes, in Reality forks, joins and steps are not necessarily “binary”, not necessarily perfectly symmetric, but that is all to it.\nNow what exactly these abstract structural patterns capture? Well, “steps” and “joins” capture the Causality Itself. “Forks” capture what we call Potentiality – possible outcomes (of processes) or possible “choices” (distinct paths, based on outcomes).\nNotice that “forks” and “joins” are from principally very different, non-overlapping “domains”, which is exactly why “isomorphism” and “duality” is just a nice abstract bullshit.\nThis, and only this, is exactly why there are only 3 Algebraic Data Types – Products, Sums and Mappings. These types are in one-to-one correspondence with the universal building blocks of Reality. This correspondence, of course, has been discovered, not invented.\nThere is another correspondence – the distinct patterns in the Algorithm Charting Techniques of the 70s, which, unsurprisingly are “forks”, “joins”, “steps” and recursion, which must always be though off as a spiral, not a “loop”.\nLets add to this the Lambda Calculus, with its notions of a binding, environment, abstraction and application, which, not accidentally, are in an one-to-one correspondence with the “introduction” and “elimination” rules of Natural Deduction (bindings also have “introduction” and “elimination”).\nNow we have all the necessary and sufficient building blocks to build or “construct” everything commutable (constructible).\nThe only missing block is “lexical” closures. Closures “naturally arise” when we study the bindings within nested frames of environment in the context of actually implementing the Simply Typed Lambda Calculus.\nAt the intuitive level, closures just properly capture “mental concepts” by avoiding any human language-related ambiguity, by “capturing the meaning of each word/term” . A word could have more than one associated meaning (being overloaded), so we have to know (capture) exactly which meaning was used in the definition of a mental concept (which is also a “capture” of some pattern itself).\nThere are also “The Universal Machine” – the Meta-Circular Evaluator of Abelson and Sussman (the Wizards), and the System F Omega as the intermediate language of GHC. These two show that, indeed, this is all we need.\nAt the level of programs there is also lots of structure. The most fundamental aspect is non-leaking Abstract Data Types, the notion popularized by Barbara Liskov (again). Proper ADTs are self-contained and orthogonal to one another, so they allow independent understanding (as sort of semantic closure) and thus independent development (by “other people”), which, in turn, allow different even swapable implementations. The most important underlying principle however, is that it facilitates thinking at an appropriate level of abstraction – at the level of “public” interfaces. It is also implicitly tends to keep abstractions within the bounds of abstraction barriers and to keep abstraction at the same higher-level, without capturing unnecessary and irrelevant implementation details, as in bad C++, where literally everything is an implementation detail.\nAnd this is basically it. This is all you need to program correctly. Specification, Abstraction Algebraic Types,and Modularity, which implies ADTs and modules with narrow, stateless mostly-functional interfaces.\nYes, there are also DDD, TTD and some meaningful parts of Agile. But these all are consequences of the universal principles outlined above.\nDDD is just a methodology of identifying, capturing and establishing that one-to-one correspondence betwen the inherent hierarchical layered structure of [complexity] of the “domain” and the corresponding hierarchical layered structure of lauers of ADTs and layers of DSLs . It does so by capturing the meaning from the “concepts of the mind” (of an “expert”), which are mental closures, into the Algebraic Types and their representations, which are sort of “semantic closures”. The “one-to-one” is the crucial part, otherwise nothing will work as expected.\nTDD is even simpler. There is a wonderful, almost mystical aspect of Algebraic Data Types, which binds and holds everything together. Just as a mountain river or a tree can be build one stream and one branch at a time, any Algebraic Type can be build one data-constructor, one slot or one clause at a time, without breaking anything which is already “Out There”. One can add a new “item” to any Algebraic Type and then proceed to test (first!), and implement it without taking anything else into consideration (less mental strain). This is the essence and the how of the Bottom-Up processes, popularized in Graham’s “On Lisp”. It is not a random coincidence that types are so finely composable, it has something to do with Monoids and nature of addition operation as “putting together”, weighted sums and the Causality Principle itself.\nAnd Agile is just a spiral-shaped, recursive (which they call “iterative”) fixed-point shaped process. It is literally a narrowing spiral which eventually converges on a good-enough “epsilon” . Each “iteration” has to be “complete” (the Always Be Compiled, “never leave the code in an inconsistent state”, and “yay! all tests passed”). Notice how “one clause at a time” is what makes this actually possible. Everything else is just a fancy bullshit.\nSo, next time you want to program just re-read and apply this. Make a petty mathematical theory, defining the entities (using sets) their attributes, and relations among entities (using mappings). Programming is understanding (and necessarily theory-building) after all. You have to make Algebraic Data Types with are in an one-to-one correspondence with the problem domain, to choice the “shape of the data” – the data structures that mimic the inherent structure within the domain, and then, according to the “Data Dominates” maxim, the code “will almost write itself”. Familiar well-understood math will be the “candle” that illuminates evrything.\n",
  "wordCount" : "1551",
  "inLanguage": "en",
  "datePublished": "2025-07-03T00:00:00+05:45",
  "dateModified": "2025-07-03T12:41:34+05:45",
  "author":[{
    "@type": "Person",
    "name": "\u0026lt;lngnmn2@yahoo.com\u0026gt;"
  }],
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://lngnmn2.github.io/articles/programming-solved-again/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Notes from the digital underground by Lngnmn",
    "logo": {
      "@type": "ImageObject",
      "url": "https://lngnmn2.github.io/favicon.ico"
    }
  }
}
</script>
</head>
<body id="top">
    <header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://lngnmn2.github.io/" accesskey="h" title="Notes from the digital underground by Lngnmn (Alt + H)">Notes from the digital underground by Lngnmn</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://lngnmn2.github.io/about/" title="About me.">
                    <span>About me.</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title entry-hint-parent">
      Programming solved (again)
    </h1>
    <div class="post-description">
      Oops, I did it again
    </div>
    <div class="post-meta"><span title='2025-07-03 00:00:00 +0545 +0545'>July 3, 2025</span>&nbsp;·&nbsp;<span>&amp;lt;lngnmn2@yahoo.com&amp;gt;</span>

</div>
  </header> 
  <div class="post-content"><p>Lets &ldquo;solve&rdquo; programming (once again, LOL), in a couple of pages, simply because why <em>tf</em> not. and to put the LLMs and their shills and worshipers into shame (yes, yes, I know, they do not have any).</p>
<p>We will build a simple abstract and general &ldquo;meta-theory&rdquo;, which is, like a religion grounded on Buddha&rsquo;s compassion, provide a foundation of peaceful and cooperating traditions, which guide people in their decision making in a overwhelmingly complex Reality by providing easy to understand and easy to apply &ldquo;heuristics&rdquo; or &ldquo;rules of thumb&rdquo;.</p>
<p>This &ldquo;meta-theory&rdquo;, however, is also explanatory and allows to make &ldquo;testable&rdquo; informed decisions, just as any truly scientific theory.</p>
<p>Let&rsquo;s start from the most wonderful almost metaphysical level of the &ldquo;underlying structure of the Universe&rdquo;, and via the recently discovered the <em>Curry-Howard Correspondence</em> and very related <em>Algebraic Data Types</em> go  all the down to the boring low-level implementation details (high-level, interface-level programming is sometimes still fun).</p>
<p>When Simon back in the sixties examined the &ldquo;Architecture of Complexity&rdquo;, he noticed that a particular recurrent &ldquo;pattern&rdquo; &ndash; a Layered Hierarchical Structure emerge again and again at all level (of abstraction).</p>
<p>This is still true, of course. It implies that the <em>only</em> way to program systems that mimics and represents some aspects of the Real World, is to discover and identify this inherent layered structure in the &ldquo;domain&rdquo; and make an one-to-one correspondence between each layer of domain to a layer of corresponding functional DSL in a program, and each distinct concept of the &ldquo;domain&rdquo; (at its proper level in an overall hierarchy) to a distinct type which captures and represents named concept at an appropriate level of abstraction, within is own orthogonal, self-contained, lose-coupled module.</p>
<p>Michael Jackson and Barbara Liskov have taught these universal principles in the 70s (seventies, mfrs!). Simon wrote his paper in the late 60s.</p>
<p>Let&rsquo;s observe some more &ldquo;fine&rdquo; structure in the overwhelming complexity around us.</p>
<p>Mountain rivers and trees form what we would call Directed Graphs. What we call &ldquo;derivatives&rdquo; and &ldquo;the chain rule&rdquo; is how much each stream contributes to the overall momentum of a river, with respect of how much water it contributes and how steep it is when it joins the river.</p>
<p>Yes, I am tracing back the most fundamental abstract mathematical concepts all the way back to the aspects of Reality, from which they have been generalized and abstracted out. You, probably, should have such habit too.</p>
<p>A mountain river is a canonical example of an emergent process caused by nothing but the Causality principle.  Every process in the whole Universe is exactly like this, but the river abstraction is much more easy to comprehend.</p>
<p>A tree is another such process. Trees emerge due to &ldquo;localized&rdquo; sub-processes, which &ldquo;know nothing&rdquo; about existence of anything beyond their immediate locality. All cell biology, at the levels of tissues, &ldquo;works&rdquo; in this way.</p>
<p>There are 3 common structural patterns in these process, which can be structurally abstracted as:</p>
<ul>
<li>a &ldquo;step&rdquo; (an arrow between 2 &ldquo;points&rdquo;)</li>
<li>a &ldquo;join&rdquo; (of two &ldquo;arrows&rdquo;)</li>
<li>a &ldquo;fork&rdquo; (of two &ldquo;arrows&rdquo;)</li>
</ul>
<p>Notice that all these structures are &ldquo;directed&rdquo;. It is said that a &ldquo;fork&rdquo; and a &ldquo;join&rdquo; are isomorphic to each other, and, it <em>appears</em> that this is the case, except that the &ldquo;direction of the arrows&rdquo;, which is a definitive part of these very structures, has been neglected. So, no, not isomorphic.</p>
<p>It is also said that they are <em>dual</em> to each other &ndash; all we can do is to &ldquo;reverse the direction of the arrows&rdquo;. While this is a perfectly valid abstract mathematical operation, which yield a perfectly &ldquo;valid&rdquo; transformed abstraction, in Reality (or in this particular Universe) such &ldquo;transformations&rdquo; are literally impossible.  The direction of the &ldquo;arrows&rdquo; cannot be thrown out of the window.</p>
<p>Everything else can be build out of these three building blocks. Yes, in Reality forks, joins and steps are not necessarily &ldquo;binary&rdquo;, not necessarily perfectly symmetric, but <em>that is all to it</em>.</p>
<p>Now what exactly these abstract structural patterns capture? Well, &ldquo;steps&rdquo; and &ldquo;joins&rdquo; capture the Causality Itself. &ldquo;Forks&rdquo; capture what we call Potentiality &ndash; possible outcomes (of processes) or possible &ldquo;choices&rdquo; (distinct paths, based on outcomes).</p>
<p>Notice that &ldquo;forks&rdquo; and &ldquo;joins&rdquo; are from principally very different, non-overlapping &ldquo;domains&rdquo;, which is exactly why &ldquo;isomorphism&rdquo; and &ldquo;duality&rdquo; is just a nice abstract bullshit.</p>
<p>This, and only this, is <em>exactly why</em> there are only 3 Algebraic Data Types &ndash; Products, Sums and Mappings. These types are in one-to-one correspondence with the universal building blocks of Reality. This correspondence, of course, has been discovered, not invented.</p>
<p>There is another correspondence &ndash; the distinct patterns in the Algorithm Charting Techniques of the 70s,  which, unsurprisingly are &ldquo;forks&rdquo;, &ldquo;joins&rdquo;, &ldquo;steps&rdquo; and recursion, which must always be though off as a <em>spiral</em>, not a &ldquo;loop&rdquo;.</p>
<p>Lets add to this the Lambda Calculus, with its notions of a <em>binding, environment, abstraction and application</em>, which, not accidentally, are in an one-to-one correspondence with the &ldquo;introduction&rdquo; and &ldquo;elimination&rdquo; rules of Natural Deduction (<em>bindings</em> also have &ldquo;introduction&rdquo; and &ldquo;elimination&rdquo;).</p>
<p>Now we have <em>all</em> the <em>necessary and sufficient</em> building blocks to build or &ldquo;construct&rdquo; <em>everything</em> commutable (constructible).</p>
<p>The only missing block is &ldquo;lexical&rdquo; closures. Closures &ldquo;naturally arise&rdquo; when we study the bindings within nested frames of environment in the context of actually implementing the Simply Typed Lambda Calculus.</p>
<p>At the intuitive level, closures just properly capture &ldquo;mental concepts&rdquo; by avoiding any human language-related ambiguity, by &ldquo;capturing the meaning of each word/term&rdquo; . A word could have more than one associated meaning (being overloaded), so we have to know (capture) exactly which meaning was used in the definition of a mental concept (which is also a &ldquo;capture&rdquo; of some pattern itself).</p>
<p>There are also &ldquo;The Universal Machine&rdquo; &ndash; the Meta-Circular Evaluator of <em>Abelson and Sussman</em> (the Wizards), and the <em>System F Omega</em> as the intermediate language of GHC. These two <em>show</em> that, indeed, this is <em>all we need</em>.</p>
<p>At the level of programs there is also lots of structure. The most fundamental aspect is <em>non-leaking Abstract Data Types</em>, the notion popularized by Barbara Liskov (again). Proper ADTs are self-contained and orthogonal to one another, so they allow independent understanding (as sort of semantic closure) and thus independent development (by &ldquo;other people&rdquo;), which, in turn, allow different even swapable implementations. The most important underlying principle however, is that it facilitates thinking at an appropriate level of abstraction &ndash; at the level of &ldquo;public&rdquo; interfaces. It is also implicitly tends to keep abstractions within the bounds of <em>abstraction barriers</em> and to keep abstraction at the same <em>higher-level</em>, without capturing unnecessary and irrelevant implementation details, as in bad C++, where literally everything is an implementation detail.</p>
<p>And this is basically it. This is <em>all you need</em> to program correctly. Specification, Abstraction Algebraic Types,and Modularity, which implies ADTs and modules with narrow, stateless mostly-functional interfaces.</p>
<p>Yes, there are also DDD, TTD and some meaningful parts of Agile. But these all are consequences of the universal principles outlined above.</p>
<p>DDD is just a methodology of identifying, capturing and establishing that one-to-one correspondence betwen the inherent hierarchical layered structure of [complexity] of the &ldquo;domain&rdquo; and the corresponding hierarchical layered structure of lauers of ADTs and layers of DSLs . It does so by capturing the meaning from the &ldquo;concepts of the mind&rdquo; (of an &ldquo;expert&rdquo;), which are mental closures, into the Algebraic Types and their representations, which are sort of &ldquo;semantic closures&rdquo;. The &ldquo;one-to-one&rdquo; is the crucial part, otherwise nothing will work as expected.</p>
<p>TDD is even simpler. There is a wonderful, almost mystical aspect of Algebraic Data Types, which binds and holds everything together. Just as a mountain river or a tree can be build one stream and one branch at a time, any Algebraic Type can be build one <em>data-constructor</em>, one <em>slot</em> or one  <em>clause</em> at a time, without breaking anything which is already &ldquo;Out There&rdquo;. One can add a new &ldquo;item&rdquo; to any Algebraic Type and then proceed to <em>test</em> (first!), and implement it without taking anything else into consideration (less mental strain). This is the essence and the <em>how</em> of the Bottom-Up processes, popularized in Graham&rsquo;s &ldquo;On Lisp&rdquo;. It is not a random coincidence that types are so finely composable, it has something to do with Monoids and nature of <em>addition</em> operation as &ldquo;putting together&rdquo;, weighted sums and the <em>Causality Principle</em> itself.</p>
<p>And Agile is just a spiral-shaped, recursive (which they call &ldquo;iterative&rdquo;)  <em>fixed-point</em> shaped process. It is literally a narrowing spiral which eventually converges on a good-enough &ldquo;epsilon&rdquo; . Each &ldquo;iteration&rdquo; has to be &ldquo;complete&rdquo; (the Always Be Compiled, &ldquo;never leave the code in an inconsistent state&rdquo;, and &ldquo;yay! all tests passed&rdquo;). Notice how &ldquo;one clause at a time&rdquo; is what makes this actually possible. Everything else is just a fancy bullshit.</p>
<p>So, next time you want to program just re-read and apply this. Make a petty mathematical theory, defining the <em>entities</em> (using sets) their attributes, and <em>relations</em> among entities (using mappings). Programming is understanding (and necessarily theory-building) after all. You have to make <em>Algebraic Data Types</em> with are in an <em>one-to-one correspondence</em> with the problem domain, to choice the &ldquo;shape of the data&rdquo; &ndash; the data structures that mimic the inherent structure within the domain, and then, according to the &ldquo;Data Dominates&rdquo;  maxim, the code &ldquo;will almost write itself&rdquo;. Familiar well-understood math will be the &ldquo;candle&rdquo; that illuminates evrything.</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://lngnmn2.github.io/tags/adt/">ADT</a></li>
      <li><a href="https://lngnmn2.github.io/tags/dsl/">DSL</a></li>
      <li><a href="https://lngnmn2.github.io/tags/esoteric/">Esoteric</a></li>
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2026 <a href="https://lngnmn2.github.io/">Notes from the digital underground by Lngnmn</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu');
    if (menu) {
        
        const scrollPosition = localStorage.getItem("menu-scroll-position");
        if (scrollPosition) {
            menu.scrollLeft = parseInt(scrollPosition, 10);
        }
        
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        const html = document.querySelector("html");
        if (html.dataset.theme === "dark") {
            html.dataset.theme = 'light';
            localStorage.setItem("pref-theme", 'light');
        } else {
            html.dataset.theme = 'dark';
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
