<!DOCTYPE html>
<html lang="en" dir="auto" data-theme="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Eliminating The Impossible | Notes from the digital underground by Lngnmn</title>
<meta name="keywords" content="AI, LLM, bullshit">
<meta name="description" content="AUTHOR: lngnmn2@yahoo.com

&ldquo;How often have I said to you that when you have eliminated the impossible, whatever remains, however improbable, must be the truth?&rdquo;

Sherlock Holmes

So the &ldquo;compiler&rdquo; is there, right on Github  [[https://github.com/anthropics/claudes-c-compiler], and the only interesting question is &ldquo;but how&rdquo;?
Well, maybe we are grossly exaggerating what might be going on under the hood.
There is an enormous, almost unbridgeable gap between a formal view and a statistical view of the world.">
<meta name="author" content="">
<link rel="canonical" href="https://lngnmn2.github.io/articles/eliminating-the-impossible/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.a5781257de4197b8e3d54346acdf1dd55a9ba4cb91dcace192fc1baf228c08b5.css" integrity="sha256-pXgSV95Bl7jj1UNGrN8d1VqbpMuR3KzhkvwbryKMCLU=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://lngnmn2.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://lngnmn2.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://lngnmn2.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://lngnmn2.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://lngnmn2.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://lngnmn2.github.io/articles/eliminating-the-impossible/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
                color-scheme: dark;
            }

            .list {
                background: var(--theme);
            }

            .toc {
                background: var(--entry);
            }
        }

        @media (prefers-color-scheme: light) {
            .list::-webkit-scrollbar-thumb {
                border-color: var(--code-bg);
            }
        }

    </style>
</noscript>
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.querySelector("html").dataset.theme = 'dark';
    } else if (localStorage.getItem("pref-theme") === "light") {
       document.querySelector("html").dataset.theme = 'light';
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.querySelector("html").dataset.theme = 'dark';
    } else {
        document.querySelector("html").dataset.theme = 'light';
    }

</script><link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Source+Code+Pro:wght@300&display=swap" rel="stylesheet">
<link href="https://fonts.googleapis.com/css2?family=Noto+Sans:wght@300&display=swap" rel="stylesheet">
<link href="https://fonts.googleapis.com/css2?family=Noto+Serif:wght@300&display=swap" rel="stylesheet">
<style>
font-family: 'Noto Serif', serif;
font-family: 'Noto Sans', sans-serif;
font-family: 'Source Code Pro', monospace;
</style>
<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script type="text/javascript" id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script><meta property="og:url" content="https://lngnmn2.github.io/articles/eliminating-the-impossible/">
  <meta property="og:site_name" content="Notes from the digital underground by Lngnmn">
  <meta property="og:title" content="Eliminating The Impossible">
  <meta property="og:description" content="AUTHOR: lngnmn2@yahoo.com
“How often have I said to you that when you have eliminated the impossible, whatever remains, however improbable, must be the truth?”
Sherlock Holmes So the “compiler” is there, right on Github [[https://github.com/anthropics/claudes-c-compiler], and the only interesting question is “but how”?
Well, maybe we are grossly exaggerating what might be going on under the hood.
There is an enormous, almost unbridgeable gap between a formal view and a statistical view of the world.">
  <meta property="og:locale" content="en-us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="articles">
    <meta property="article:published_time" content="2026-02-10T00:00:00+05:45">
    <meta property="article:modified_time" content="2026-02-11T11:48:56+05:45">
    <meta property="article:tag" content="AI">
    <meta property="article:tag" content="LLM">
    <meta property="article:tag" content="Bullshit">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Eliminating The Impossible">
<meta name="twitter:description" content="AUTHOR: lngnmn2@yahoo.com

&ldquo;How often have I said to you that when you have eliminated the impossible, whatever remains, however improbable, must be the truth?&rdquo;

Sherlock Holmes

So the &ldquo;compiler&rdquo; is there, right on Github  [[https://github.com/anthropics/claudes-c-compiler], and the only interesting question is &ldquo;but how&rdquo;?
Well, maybe we are grossly exaggerating what might be going on under the hood.
There is an enormous, almost unbridgeable gap between a formal view and a statistical view of the world.">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Articles",
      "item": "https://lngnmn2.github.io/articles/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Eliminating The Impossible",
      "item": "https://lngnmn2.github.io/articles/eliminating-the-impossible/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Eliminating The Impossible",
  "name": "Eliminating The Impossible",
  "description": "AUTHOR: lngnmn2@yahoo.com\n\u0026ldquo;How often have I said to you that when you have eliminated the impossible, whatever remains, however improbable, must be the truth?\u0026rdquo;\nSherlock Holmes So the \u0026ldquo;compiler\u0026rdquo; is there, right on Github [[https://github.com/anthropics/claudes-c-compiler], and the only interesting question is \u0026ldquo;but how\u0026rdquo;?\nWell, maybe we are grossly exaggerating what might be going on under the hood.\nThere is an enormous, almost unbridgeable gap between a formal view and a statistical view of the world.\n",
  "keywords": [
    "AI", "LLM", "bullshit"
  ],
  "articleBody": "AUTHOR: lngnmn2@yahoo.com\n“How often have I said to you that when you have eliminated the impossible, whatever remains, however improbable, must be the truth?”\nSherlock Holmes So the “compiler” is there, right on Github [[https://github.com/anthropics/claudes-c-compiler], and the only interesting question is “but how”?\nWell, maybe we are grossly exaggerating what might be going on under the hood.\nThere is an enormous, almost unbridgeable gap between a formal view and a statistical view of the world.\nSome clowns push the narrative that only statistical view is the Right one, and even that “there is no truth” (bullshit! Truth Is Out There). Others, with a better education, claims that there are lies, gross lies and [inference-based] “statistics” (frequency-based stats are okay).\nConsider variables. Any programming language is a formal mathematical system (a set of objects together with a set of rules and relations). Some languages are defined more rigorously than the others, but every single one is operationally defined by its compiler and its runtime. The classic FP languages of the past were so well-designed, relying on familiar mathematical concepts, that one could even understand (without much guessing) almost everything what is going on under the hood. Nowadays everything is completely fucked up, of course.\nSo, to understand variables we have to “step back” and understand a more general phenomena like spoken human languages (4chan-level linguistics, you know).\nIn general, in any human languages a word (a sequence of sounds) stands for some concepts of the mind (and the things of/in the world through their mental “views” as concepts of the mind). When one said “cat” it is a “cat slot” in the mind of each particular person, not some particular cat out there.\nA “variable”, which is just a symbol (the early LISP people got this absolutely right), is “written (and displayed)” word for a value, which, in turn, is an distinct entity (“a distinct object of some kind”) in the Universe of Discourse.\nAgain, the classic languages got everything right by having the notion of the Environment, which, of course, mimics the logical environment Γ, that holds every single previous result – everything that is [already] known.\nAnd there are additional rules, which were discovered, not invented – the rules of “scope” and the rules of shadowing\", which, unsurprisingly, are universal between math, logic and FP.\nNotice that in a spoken human language the same word refers to the same mental concept most of the time, except when socially constructed abstract concepts and cultural norms introduce contexts, which re-define (shadow) the traditional (previous) meaning.\nNow, how the slop generator deals with all these subtle and complicated rules. It does not.\nThis is why any current LLM (based on the statistical inference of the most-probable next token) is absolutely miserable at math, where the binding of symbols to values are usually immutable, and fresh new bindings are being introduced instead.\nThe problem is that a symbol is a “placeholder”, which introduces an “indirection”. Not just that, but systematically and consistently substituting a particular symbol within a formula (or an expression) to another does not change the meaning of an expression in principle (you shouldn’t’ve skipped your Lambda Calculus class).\nSo, every expression within a formal language has at least three distinct kinds of symbols – the keywords, the names chosen by the public interfaces (APIs), and the names chosen by you for your local variables (bindings).\nFrom the point of view of an LLM, keywords and API interfaces (a “stable” sets of names) do not change, while user-defined variables are just “semantic holes” - x is as good as y, as good as whatEverCrappyCamelCaseItIs. Don’t you see?\nLet’s pause the formal view and switch briefly to the statistical view.\nIf you think how many variables are “out there” (in the training sets), it turns out that just a few (compared to the branching factor after the words “the” or “a”). Yes, because of the previous context, not every noun in the Websters Dictionary have a similar probability of coming after “the”. The same is even more true for the code – the branching factor for a variable name (a user-chosen symbol for a placeholder) is “okay”.\nIn math it is tiny and this fucks up the inference algorithms in principle.\nSo, how? Are they used human “labelers” and pre-processor tools to annotate variables? Probably not. They just feed the training examples verbatim, letting the actual “graph structure” to [topologically] sort it out, which is just a “brute force”, but brute force works surprisingly well.\nHow the consistency is handled? Via the previous context feed back for generation of the next token, so once it was x it will be more probably to remain x, not y.\nAll the other symbols are just “passed through verbatim”, and the slop generators are great at autocompleting them.\nOne more time – it is all a sheer [statistical] brute force. The “intelligence” is only apparent – just a cognitive illusion.\nBy treating every “variable” as a “constant” they “branch out” on every single one of them, but who tf cares, as the money for whole datacenters (to store the always updating representations) come as an avalanche.\nAnd, wallah, just like that, everything is solved. Who tf cares about your formal views, while a whole meme (non-optimizing) C-compilers can be actually generated.\nHow do they map abstract concept from the theoretical academic texts about SSA or an optimal IR? They do not. In the training data some “API names” had the semantic relations to the theoretical concepts in the books, and this is enough to infer the blocks of code.\nHow do they translate between different programming languages? They do not. As long as the syntax in the context so far is consistent, it will “infer” the right next token, again, because the syntax is much much smaller than a spoken language vocabulary for a given topic.\nBy the way,very few people have actually realized that the number of “structural elements” in any computation graph is just 4 – a step (composition), a branch (a conditional) and a join (application) and a recursive call. No LLM captured this fact, which is closely related to (a second derivative of) the Curry-Howard Isomorphism.\nNot just that, but the sum-types (a disjoint union of one or more data-constructors, acting as “type-tags”) and the corresponding exhaustive patter-matching expressions are [structural] duals of each other, and a function on a sum-type can be defined as a set of distinct clauses, each of which is a partial function of its own. Sum-types are branching at the type-level, with a perfect dual at the code (expressions) level.\nBut these higher level abstract structures are still “compositions” of “forks” and “joins”, with some “steps” in between. There is simply nothing more “Out There”.\nRealizing this is the “enlightenment” into a proper programming in any language whatsoever, if you ask me. This is how the formal view wins by a KO.\nBut why, enjoy your generated slop instead.\n",
  "wordCount" : "1163",
  "inLanguage": "en",
  "datePublished": "2026-02-10T00:00:00+05:45",
  "dateModified": "2026-02-11T11:48:56+05:45",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://lngnmn2.github.io/articles/eliminating-the-impossible/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Notes from the digital underground by Lngnmn",
    "logo": {
      "@type": "ImageObject",
      "url": "https://lngnmn2.github.io/favicon.ico"
    }
  }
}
</script>
</head>
<body id="top">
    <header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://lngnmn2.github.io/" accesskey="h" title="Notes from the digital underground by Lngnmn (Alt + H)">Notes from the digital underground by Lngnmn</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://lngnmn2.github.io/about/" title="About me.">
                    <span>About me.</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title entry-hint-parent">
      Eliminating The Impossible
    </h1>
    <div class="post-meta"><span title='2026-02-10 00:00:00 +0545 +0545'>February 10, 2026</span>

</div>
  </header> 
  <div class="post-content"><p>AUTHOR: <a href="mailto:lngnmn2@yahoo.com">lngnmn2@yahoo.com</a></p>
<blockquote>
<p>&ldquo;How often have I said to you that when you have eliminated the impossible, whatever remains, however improbable, must be the truth?&rdquo;</p>
<ul>
<li>Sherlock Holmes</li>
</ul></blockquote>
<p>So the &ldquo;compiler&rdquo; is there, right on Github  [[<a href="https://github.com/anthropics/claudes-c-compiler">https://github.com/anthropics/claudes-c-compiler</a>], and the only <em>interesting</em> question is &ldquo;but how&rdquo;?</p>
<p>Well, maybe we are grossly exaggerating what might be going on under the hood.</p>
<p>There is an enormous, almost unbridgeable gap between a formal view and a statistical view of the world.</p>
<p>Some clowns push the narrative that only statistical view is the Right one, and  even that &ldquo;there is no truth&rdquo; (bullshit! <em>Truth Is Out There</em>). Others, with a better education, claims that there are lies, gross lies and [inference-based] &ldquo;statistics&rdquo; (frequency-based stats are okay).</p>
<p>Consider variables. Any programming language is a formal mathematical system (a set of objects together with a set of rules and relations). Some languages are defined more rigorously than the others, but every single one is <em>operationally defined</em> by its compiler and its runtime. The classic FP languages of the past were so well-designed, relying on familiar mathematical concepts, that one could even understand (without much guessing) almost everything what is going on under the hood. Nowadays everything is completely fucked up, of course.</p>
<p>So, to understand variables we have to &ldquo;step back&rdquo; and understand a more general  phenomena like <em>spoken human languages</em> (4chan-level linguistics, you know).</p>
<p>In general, in any human languages a word (a sequence of sounds) stands for some concepts of the mind (and the things of/in the world <em>through</em> their mental &ldquo;views&rdquo; as concepts of the mind). When one said &ldquo;cat&rdquo; it is a &ldquo;cat slot&rdquo; in the mind of each particular person, not some particular cat out there.</p>
<p>A &ldquo;variable&rdquo;, which is just a <em>symbol</em>  (the early LISP people got this absolutely right), is  &ldquo;written (and displayed)&rdquo; word for a <em>value</em>, which, in turn, is an distinct entity (&ldquo;a distinct object of some kind&rdquo;) in the Universe of Discourse.</p>
<p>Again, the classic languages got everything right by having the notion of the Environment, which, of course, mimics the logical environment Γ, that holds every single previous result &ndash; everything that is [already] known.</p>
<p>And there are additional rules, which were <em>discovered</em>, not invented &ndash; the rules of  &ldquo;scope&rdquo; and the rules of  shadowing&quot;, which, unsurprisingly, are universal between math, logic and FP.</p>
<p>Notice that in a spoken human language the same word refers to the same mental concept <em>most of the time</em>, except when socially constructed abstract concepts  and cultural norms introduce contexts, which re-define (shadow) the traditional (previous) meaning.</p>
<p>Now, how the slop generator deals with all these subtle and complicated rules. It does not.</p>
<p>This is why any current LLM (based on the statistical inference of the most-probable next token) is absolutely miserable at math, where the binding of symbols to values are usually immutable, and fresh new bindings are being introduced instead.</p>
<p>The problem is that a symbol is a &ldquo;placeholder&rdquo;, which introduces an &ldquo;indirection&rdquo;.  Not just that, but systematically and consistently substituting a particular symbol within a formula (or an expression) to another does not change the meaning of an expression in principle (you shouldn&rsquo;t&rsquo;ve skipped your <em>Lambda Calculus</em> class).</p>
<p>So, every expression within a formal language has <em>at least</em> three distinct kinds of symbols &ndash; the keywords, the names chosen by the public interfaces (APIs), and the names chosen by you for your local variables (bindings).</p>
<p>From the point of view of an LLM, keywords and API interfaces (a &ldquo;stable&rdquo; sets of names) do not change, while user-defined variables are just &ldquo;semantic holes&rdquo; - <code>x</code> is as good as <code>y</code>, as good as <code>whatEverCrappyCamelCaseItIs</code>. Don&rsquo;t you see?</p>
<p>Let&rsquo;s pause the formal view and switch briefly to the statistical view.</p>
<p>If you think how many variables are &ldquo;out there&rdquo; (in the training sets), it turns out that just a few (compared to the branching factor after the words &ldquo;the&rdquo; or &ldquo;a&rdquo;). Yes, because of the previous context, not every noun in the Websters Dictionary have a similar probability of coming after &ldquo;the&rdquo;. The same is even more true for the code &ndash; the branching factor for a variable name (a user-chosen symbol for a placeholder) is &ldquo;okay&rdquo;.</p>
<p>In math it is <em>tiny</em> and this fucks up the inference algorithms in principle.</p>
<p>So, how? Are they used human &ldquo;labelers&rdquo; and pre-processor tools to annotate variables? Probably not.  They just feed the training examples verbatim, letting the actual &ldquo;graph structure&rdquo; to [topologically] sort it out, which is just a &ldquo;brute force&rdquo;, but brute force works surprisingly well.</p>
<p>How the <em>consistency</em> is handled? Via the previous context feed back for generation of the next token, so once it was <code>x</code> it will be more probably to remain <code>x</code>, not <code>y</code>.</p>
<p>All the other symbols are just &ldquo;passed through verbatim&rdquo;, and the slop generators are great at <em>autocompleting them</em>.</p>
<p>One more time &ndash; it is all a sheer [statistical] brute force. The &ldquo;intelligence&rdquo; is only apparent &ndash; just a  cognitive illusion.</p>
<p>By treating every &ldquo;variable&rdquo; as a &ldquo;constant&rdquo; they &ldquo;branch out&rdquo; on every single one of them, but who tf cares, as the money for <em>whole datacenters</em> (to store the  <em>always updating</em> representations) come as an avalanche.</p>
<p>And, wallah, just like that, everything is solved. Who tf cares about your formal views, while a whole <em>meme</em> (non-optimizing) C-compilers can be actually generated.</p>
<p>How do they map abstract concept from the theoretical  academic texts about SSA or an optimal IR? They do not. In the training data some &ldquo;API names&rdquo;  had the semantic relations to the theoretical concepts in the books, and <em>this is enough</em> to infer the blocks of code.</p>
<p>How do they translate between different programming languages? They do not. As long as the syntax in the context <em>so far</em> is consistent, it will &ldquo;infer&rdquo; the right next token, again, because the syntax is much much smaller than a spoken language vocabulary for a given topic.</p>
<p>By the way,very few people have actually realized that the number of &ldquo;structural elements&rdquo; in any computation graph is just 4 &ndash; a step (composition), a branch (a conditional) and a join (application) and a recursive call. No LLM captured this fact, which is closely related to (a second derivative of) the Curry-Howard Isomorphism.</p>
<p>Not just that, but the sum-types (a disjoint union of one or more data-constructors, acting as &ldquo;type-tags&rdquo;) and the corresponding exhaustive patter-matching expressions are [structural] duals of each other, and a function on a sum-type can be defined as a set of distinct <em>clauses</em>, each of which is a <em>partial function</em> of its own. Sum-types are branching at the type-level, with a perfect dual at the code (expressions) level.</p>
<p>But these higher level abstract structures are still &ldquo;compositions&rdquo; of &ldquo;forks&rdquo; and &ldquo;joins&rdquo;, with some &ldquo;steps&rdquo; in between. There is simply nothing more &ldquo;Out There&rdquo;.</p>
<p>Realizing this is the &ldquo;enlightenment&rdquo; into a proper programming in any language whatsoever, if you ask me. This is how the formal view wins by a KO.</p>
<p>But why, enjoy your generated slop instead.</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://lngnmn2.github.io/tags/ai/">AI</a></li>
      <li><a href="https://lngnmn2.github.io/tags/llm/">LLM</a></li>
      <li><a href="https://lngnmn2.github.io/tags/bullshit/">Bullshit</a></li>
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2026 <a href="https://lngnmn2.github.io/">Notes from the digital underground by Lngnmn</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu');
    if (menu) {
        
        const scrollPosition = localStorage.getItem("menu-scroll-position");
        if (scrollPosition) {
            menu.scrollLeft = parseInt(scrollPosition, 10);
        }
        
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        const html = document.querySelector("html");
        if (html.dataset.theme === "dark") {
            html.dataset.theme = 'light';
            localStorage.setItem("pref-theme", 'light');
        } else {
            html.dataset.theme = 'dark';
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
