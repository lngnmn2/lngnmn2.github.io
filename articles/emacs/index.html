<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>GNU Emacs | Notes from the digital underground by Lngnmn</title>
<meta name="keywords" content="emacs, imperative, ADT, homoiconicity, embedded, DSL, Monoid">
<meta name="description" content="  The monument and a world-heritage &#34;site&#34;.
  ">
<meta name="author" content="&amp;lt;lngnmn2@yahoo.com&amp;gt;">
<link rel="canonical" href="https://lngnmn2.github.io/articles/emacs/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.d0049500090a8b5b522a30f4bc70f815df41595125d25503dff47281216974cb.css" integrity="sha256-0ASVAAkKi1tSKjD0vHD4Fd9BWVEl0lUD3/RygSFpdMs=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://lngnmn2.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://lngnmn2.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://lngnmn2.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://lngnmn2.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://lngnmn2.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://lngnmn2.github.io/articles/emacs/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Source+Code+Pro:wght@300&display=swap" rel="stylesheet">
<link href="https://fonts.googleapis.com/css2?family=Noto+Sans:wght@300&display=swap" rel="stylesheet">
<link href="https://fonts.googleapis.com/css2?family=Noto+Serif:wght@300&display=swap" rel="stylesheet">
<style>
font-family: 'Noto Serif', serif;
font-family: 'Noto Sans', sans-serif;
font-family: 'Source Code Pro', monospace;
</style>
<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script type="text/javascript" id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script><meta property="og:url" content="https://lngnmn2.github.io/articles/emacs/">
  <meta property="og:site_name" content="Notes from the digital underground by Lngnmn">
  <meta property="og:title" content="GNU Emacs">
  <meta property="og:description" content="  The monument and a world-heritage &#34;site&#34;.
  ">
  <meta property="og:locale" content="en-us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="articles">
    <meta property="article:published_time" content="2023-07-28T00:00:00+05:45">
    <meta property="article:modified_time" content="2023-08-02T12:43:44+05:45">
    <meta property="article:tag" content="Emacs">
    <meta property="article:tag" content="Imperative">
    <meta property="article:tag" content="ADT">
    <meta property="article:tag" content="Homoiconicity">
    <meta property="article:tag" content="Embedded">
    <meta property="article:tag" content="DSL">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="GNU Emacs">
<meta name="twitter:description" content="  The monument and a world-heritage &#34;site&#34;.
  ">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Articles",
      "item": "https://lngnmn2.github.io/articles/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "GNU Emacs",
      "item": "https://lngnmn2.github.io/articles/emacs/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "GNU Emacs",
  "name": "GNU Emacs",
  "description": "  The monument and a world-heritage \"site\".\n  ",
  "keywords": [
    "emacs", "imperative", "ADT", "homoiconicity", "embedded", "DSL", "Monoid"
  ],
  "articleBody": "Emacs is a monument (just like Potala palace in Lhasa) of an old-school software engineering and classic languages – it is, indeed, a world heritage site of the golden age of programming.\nIt also could be compared with the ghat complex of Varanasi, which began no one knows when and is constantly changing since then, being reshaped by the “waves” and “tides” of social dynamics.\nVisiting Emacs is like visiting one of such historic sites, and just like them, it has been re-shaped by the successions of mass-hysteria and zealous over-excitement about bullshit.\nNowadays the current mass hysteria is about threads and some ad-hoc library-based async stuff.\nAdding an ad-hoc concurrency to an imperative language will always be a failure in principle, and the Ocaml guys went through all the pains of designing a principled algebraic effects based runtime for a reason – an imperative code and concurrency simply do not match (thank you, Joe) .\nOne at least could embrace the principled approach of Clojure, and rely on actually immutable and persistent (a balanced tree-based) data structures (straightforwardly shared and garbage-collected). Yes, yes I know.\nAnyway, coming (partially) from MIT CSAIL it has been based on the right priciples and incorporates (realizes and manifests) some “big ideas” and universal notions.\nIt is a set of layered DSLs written in a dynamically typed LISP-2, which is in rurn implemented in (an imperative and unsafe) C, Just like TeX, by the way.\nEmacs is a truly dynamic system (everything could be changed at runtime, even a new procedures could be created) similar to Smalltalk, which is almost an ideal in this respect.\nIt is just a single-executable software Lisp Machine or stripped down the Genera operating system (well, almost), and one can really see and feel it. Here is how.\nIn your Emacs install the showkey package, something like (straight-use-package showkey) in a very modern tooling DSL, for the sake of a quick example. Then run M-x showkey-log-mode, which will create a new frame with a log of all the keys you would press.\nNotice, by pressing literally any keys and combinations you already know, that each one invokes a particular LISP procedure. One more time – every keystroke invokes some procedure with appropriate arguments. It is indeed an intepreter of the “language” (code sequences) that come from the keyboard. So it is a software LISP Machine, indeed.\nThis, by the way, is why and how exactly the keyboard macros (very different feature from the LISP macros) are possible - one records the keystrokes, which have a direct one-to-one correspondence with the “procedures”, which have been bound to them. Just like pressing on piano keys produces corresponding “notes” (tones), pressing on keys in Emacs produces corresponding imperative procedure calls.\nSo, one just records the sequence of the keys, directly translate it into a sequence of procedure calls, give it a name, and then evaluates it at once, or this many times (actually transforming the buffer as it goes).\nThe key to the “a-ha momnet” is that all the “motion keystrokes” also have direct mapping to LISP procedures. To move a cursor is to actually call a procedure (M-f is bound to the forward-word procedure, and so on). There are a few pages (screens) of key-bindings, which can be seen by pressing Ctrl-h b at any time.\nNotice how simple eveything is when you understand the principles and that the principles are just right and application of them is uniform (uniformity is a big deal).\nEmacs is, indeed, an actual manifestation of the power of symbolic manipulation, at both code and data levels – the original principle of homoiconicity (everything is of the same a LIST structure made out of conses, both LISP expressions and the data). This principle gives a subtle Monoid property for all the combinator procedures, which is the actual cause behind the expressiveness of the original LISP.\nThere is a lot going on in this locus of symbolic computation and the layers upon layers of DLSs embedded in LISP. The number of “packages” is already in thousands.\nTo really understand and appreciate what one sees requires a lot of the right knowledge, but then everything is “clicks” and falls into its places.\nIt has been noticed at the times of the early LISPs that linear, tree-like and lookup-table-like data structures are enought for everything. The inspirations came from the recent discovery of the DNA structure and the resulting hype and excitement. It seems that biology also uses (the “blind” process of biological evolution at the level of molecular biology “discovered”) these fundamental “structures”.\nAnd, behold, all these could be made out of CONS’ses, where an associative list (a list of pairs, which are “improper conses”), is a “minimal” and essential lookup table (with a linear time complexity).\nNotice that a “lookup table” as just a sequence of ordered pairs could represent an “environment”, a \" hierarchical namespace\", a module, a whole library of modules. All these and almost everything of this “rectangular shape” is a specialization of a “lookup table abstraction”, or of a function abstraction (on a finite domain).\nYes, it is absolutely OK to bind a procedure (its actual body) to a symbol (which is exactly what the (define square (lambda (x) (* x x))) special form (in Scheme) does. The symbol, in turn, could be a part of (bound in) any LISP data structure whatsoever (due to type-tagging of values and dynamic typing in general). Each value uniformly carries its type-tag, so its type is always known at runtime and no other decorations are necessary.\nSo, by nesting and dynamically binding these “lookup tables”, which could hold any LISP data including procedures to trees and plain old lists, one builds a dynamic environment, which consist of nested individual “frames” (according to agreed upon specifications, rules such as “shadowing” of symbols, and standardized interfaces). Something very similar is happening in modern Python.\nIt can never be over-emphasized, that Lists and other fundamental Abstract Data Types (trees, lookup tables, queues) are enough to implement a universal machine - an intepreter of a language with the Environment Model of evaluation (which as extruded Substitution Model).\nThis result was so excited and fundamental that MIT used to teach most of its CS courses (in Scheme) about these ideas, principles and their actual implementations. They even build a tiny (but done just right) Emacs-like editor, called /Edwin, which is included in the MIT Scheme distribution.\nThe last classic course of this great lineage (the MIT Scheme tradition) is the 2004 6.001 SICP Scheme course by Eric Grimson et all. The last book is Software Design for Flexibility by Sussman, the wizard.\nIn a dynamically but strongly typed language (with runtime checks) all these structured values could not just be arbitrary /nested (due to the fact that everything is an expression and that everything is homoiconous (of the same CONSes), but also created on-demand and modified (re-bound) at runtime.\nThese are the “fundamental building blocks” of Emacs - the fundamental data structures and at a higher level the hierarchical layered DSLs embedded in LISP.\nThe first old implementations were simple-enough to be hacked toghether by just a few people in their spare time (/excactly due to the right principles,fundamentals and “natural” proper design decisions).\nAgian, it is not about the gory details of how exactly it is implemented, but how the architecture, modularity and the embedded language ()for writing DSLs and packages) has been done just right.\nThe implementation side is actually ugly – imperative, mutable, destructively in-place updated and with the “clever” C (that no one really fully understood) under the hood.\nNo serious attempts has been taken to write a Clojure-like immutable and persistent “stdlib” as the shared Basis for all the modules, just as the SML guys did with their Basis Library or the Erlang guys did with their OTP.\nWhat is worse, people do not bother to understand the principles and the proper idioms and write low-effort crap with unnecessary bloated dependecies and inappropriate. They just write as they used in that other language they know, like degens write Haskell as if it is J2EE with monad “wrapers”.\nThe key to write good Emacs Lisp is to understand the DSLs already presented at each level of abstraction, and to use the proper idioms appropriate for each layer. One would be surprised how little code one has to write – almost everything is already in the library. This is why some modules are just a few lines, but just the right ones – as intended.\nThe big, classic ideas, however, cannot be marred by the dirty impure imperative low-effort stuff. The fact that LISP is a “very-high-level” and even “programmable” programming language – one could define one’s own control structures and even special forms (using macros) – outweights all other concerns. Hierarchical layers of embedded DSLs is a “universal architecture”.\nThe causes of the miracle (of classic software engineering) and the greatness of the monument are exactly these listed above, and they have to be realized and fully understood, including the Monoid part (over CONSses).\nFrom the perspective of a merely user of the system (it is by no means an editor, rather it is a single-binary Lisp OS, (just like Chomium nowadays, by the way).\nSo, when you open your Emacs next time just slow down and simply esplore it, wander around and appreciate, as one would in some historic world-heritage site. Most of the details matter and most of the decisions were right. Of course, it is littered with modern junk, with bullshit painted on the walls, etc.\nThere is a lot more to Emacs. Most notably, people like Sacha Chua (google her) and (to lesser extent) Xah Lee. Mike Zamansky is also worth mentioning for his youtube series.\nhttps://www.youtube.com/playlist?list=PL9KxKa8NpFxIcNQa9js7dQQIHc81b0-Xg\nThere are quiet autistic (it is ok, we are the best by far) programmers who slowly and carefully write (or wrote in the past) wonderful packages, some of which are now abandoned (nXHTML, Icicles, vdiff, etc).\nIt seems that Emacs requires (or at least could be easily aligned to) some particular mindset, which can be found at places like MIT CSAIL or Bell Labs or any other quiet place where quiet people slowly and carefully crafting something (almost instinct due to modern management bullshit).\nAnd it is not some modern fancy stuff like Doom Emacs that is worth “worshiping” or at least approach with a religious awe (as one feel inside a great cathedral), but what lead to it, what made it possible, and the principles and big ideas of which Emacs is a manifestation.\nLots of pages has been written about the unique “nature” of Emacs.\nself-documenting (people of the golden age knew and applied the right principles) everything is discoverable (every binding and every command can be discovered) truly extensible (dynamical typed LISP2 with embedded Common Lisp and macros) keyboard macros (it is a software Lisp Machine, after all) Lisp Macros (the way to define your own special forms) Declarative embedded DSLs (what makes Emacs what it is) One could read other guys on the internet about the details and particulars. I am MIT-style principle-loving guy.\nJust one more important thing. Emacs is wast, and one does not have to memorize it all (which is an impossible and ultimately futile task anyway). On the contrary, one has to learn how to discover, master, customize and extend the exact features one needs – this is the true “philosophy” of Emacs.\nTo do that one has to understand what he (or she) is doing (and why). From understanding a workflow naturally emerges, and it has to be described informally or even formalized. From an informal description a cheat-sheet of commands and corresponding key-binding can be distilled.\nWhen one discovers that some keys binding are inconvenient or inconsistent with the traditional conventions, then (and only then) one have to change the binding. Consistency and elegance are not optional.\nOne has strongly resist the stupidity of re-binding all the keys in some non-emacs fashion, and the sheer madness of trying to turn Emacs into Vim. With more than 40 years of continuous refinement, Emacs evolved proper notions of how key bindings shall be organized, and this is about shallow hierarchies (trees) of mnemonic sequences, like C-x p ?. Do not replace an evolved optimum with a low-effort meme-crap.\n",
  "wordCount" : "2060",
  "inLanguage": "en",
  "datePublished": "2023-07-28T00:00:00+05:45",
  "dateModified": "2023-08-02T12:43:44+05:45",
  "author":[{
    "@type": "Person",
    "name": "\u0026lt;lngnmn2@yahoo.com\u0026gt;"
  }],
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://lngnmn2.github.io/articles/emacs/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Notes from the digital underground by Lngnmn",
    "logo": {
      "@type": "ImageObject",
      "url": "https://lngnmn2.github.io/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://lngnmn2.github.io/" accesskey="h" title="Notes from the digital underground by Lngnmn (Alt + H)">Notes from the digital underground by Lngnmn</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://lngnmn2.github.io/about/" title="About me.">
                    <span>About me.</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title entry-hint-parent">
      GNU Emacs
    </h1>
    <div class="post-description">
        The monument and a world-heritage &#34;site&#34;.
  
    </div>
    <div class="post-meta"><span title='2023-07-28 00:00:00 +0545 +0545'>July 28, 2023</span>&nbsp;·&nbsp;<span>&amp;lt;lngnmn2@yahoo.com&amp;gt;</span>

</div>
  </header> 
  <div class="post-content"><p>Emacs is a <em>monument</em> (just like <em>Potala palace in Lhasa</em>) of an old-school software engineering and classic languages &ndash; it is, indeed, a <em>world heritage site</em> of the golden age of programming.</p>
<p>It also could be compared with the <em>ghat</em> complex of Varanasi, which began no one knows when and is constantly changing since then, being reshaped by the &ldquo;waves&rdquo; and &ldquo;tides&rdquo; of social dynamics.</p>
<p>Visiting Emacs is like visiting one of such historic sites, and just like them, it has been re-shaped by the successions of mass-hysteria and zealous over-excitement about bullshit.</p>
<p>Nowadays the current mass hysteria is about threads and some <em>ad-hoc</em> library-based <em>async</em> stuff.</p>
<p>Adding an <em>ad-hoc concurrency</em> to an imperative language will always be a failure in principle, and the Ocaml guys went through all the pains of designing a principled algebraic effects based runtime for a reason &ndash; an imperative code and concurrency simply do not match (thank you, Joe) .</p>
<p>One at least could embrace the principled approach of Clojure, and rely on actually immutable and persistent (a balanced tree-based) data structures (straightforwardly shared and garbage-collected). Yes, yes I know.</p>
<p>Anyway, coming (partially) from <em>MIT CSAIL</em> it has been based on the right priciples and incorporates (realizes and manifests) some &ldquo;big ideas&rdquo; and universal notions.</p>
<p>It is a set of layered DSLs written in a <em>dynamically typed</em> LISP-2, which is in rurn implemented in (an imperative and unsafe) <code>C</code>, Just like TeX, by the way.</p>
<p>Emacs is a truly dynamic system (everything could be changed at runtime, even a new procedures could be created) similar to <em>Smalltalk</em>, which is almost an ideal in this respect.</p>
<p>It is just a single-executable software Lisp Machine or stripped down the Genera operating system (well, almost), and one can really see and <em>feel</em> it. Here is how.</p>
<p>In your Emacs install the <code>showkey</code> package, something like <code>(straight-use-package showkey)</code> in a very modern tooling DSL, for the sake of a quick example. Then run <code>M-x showkey-log-mode</code>, which will create a new frame with a log of all the keys you would press.</p>
<p>Notice, by pressing literally any keys and combinations you already know, that each one invokes a particular LISP <em>procedure</em>. One more time &ndash; every keystroke invokes some procedure with appropriate arguments. It is indeed an <em>intepreter</em> of the &ldquo;language&rdquo; (code sequences) that come from the keyboard. So it <em>is</em> a software LISP Machine, indeed.</p>
<p>This, by the way, is why and how exactly the <em>keyboard macros</em> (very different feature from the <em>LISP macros</em>) are possible - one records the keystrokes, which have a direct <em>one-to-one correspondence</em> with the &ldquo;procedures&rdquo;, which have been bound to them. Just like pressing on piano keys produces corresponding &ldquo;notes&rdquo; (tones), pressing on keys in Emacs produces corresponding <em>imperative procedure calls</em>.</p>
<p>So, one just records the sequence of the keys, directly translate it into a sequence of procedure calls, give it a name, and then evaluates it at once, or this many times (actually transforming the buffer as it goes).</p>
<p>The key to the &ldquo;a-ha momnet&rdquo; is that all the &ldquo;motion keystrokes&rdquo; also have direct mapping to LISP procedures. To move a cursor is to actually call a procedure (<code>M-f</code> is bound to the <code>forward-word</code> procedure, and so on). There are a <em>few pages</em> (screens) of <em>key-bindings</em>, which can be seen by pressing <code>Ctrl-h b</code> at any time.</p>
<p>Notice how simple eveything is when you understand the principles and that the principles are just right and application of them is <em>uniform</em> (uniformity is a big deal).</p>
<p>Emacs is, indeed, an actual manifestation of the power of <em>symbolic manipulation</em>, at both <em>code and data</em> levels &ndash; the original principle of homoiconicity (everything is of the same a LIST structure made out of conses, both LISP expressions and the data). This principle gives a subtle <em>Monoid</em> property for all the combinator procedures, which is the actual cause behind the expressiveness of the original LISP.</p>
<p>There is <em>a lot</em> going on in this <em>locus</em> of symbolic computation and the layers upon layers of DLSs <em>embedded in LISP</em>. The number of &ldquo;packages&rdquo; is already in thousands.</p>
<p>To really understand and appreciate what one sees requires a lot of the right
knowledge, but then everything is &ldquo;clicks&rdquo; and falls into its places.</p>
<p>It has been noticed at the times of the early LISPs that linear,
tree-like and lookup-table-like data structures are enought for
everything. The inspirations came from the recent discovery of the DNA
structure and the resulting hype and excitement. It seems that biology
also uses (the &ldquo;blind&rdquo; process of biological evolution at the level of
molecular biology &ldquo;discovered&rdquo;) these fundamental &ldquo;structures&rdquo;.</p>
<p>And, behold, all these could be made out of <em>CONS&rsquo;ses</em>, where an
<em>associative list</em> (a list of pairs, which are &ldquo;improper conses&rdquo;), is a
&ldquo;minimal&rdquo; and essential <em>lookup table</em> (with a linear time complexity).</p>
<p>Notice that a &ldquo;lookup table&rdquo; as just a sequence of ordered pairs could represent an &ldquo;environment&rdquo;, a &quot; hierarchical namespace&quot;, a module, a whole library of modules. All these and almost everything of this &ldquo;rectangular shape&rdquo; is a specialization of a &ldquo;lookup table abstraction&rdquo;, or of a function abstraction (on a finite domain).</p>
<p>Yes, it is absolutely OK to <em>bind</em> a <em>procedure</em> (its actual body) to a symbol (which is exactly what the <code>(define square (lambda (x) (* x x)))</code> special form (in Scheme) does. The symbol, in turn, could be a part of (bound in) any LISP data structure whatsoever (due to type-tagging of values and dynamic typing in general). Each value <em>uniformly</em> carries its <em>type-tag</em>, so its type is always known <em>at runtime</em> and no other decorations are necessary.</p>
<p>So, by nesting and <em>dynamically binding</em> these &ldquo;lookup tables&rdquo;, which could hold <em>any LISP data</em> including <em>procedures</em> to trees and plain old lists, one builds a dynamic environment, which consist of nested individual &ldquo;frames&rdquo; (according to agreed upon specifications, rules such as &ldquo;shadowing&rdquo; of symbols, and standardized interfaces). Something very similar is happening in modern <em>Python</em>.</p>
<p>It can never be over-emphasized, that Lists and other fundamental
Abstract Data Types (trees, lookup tables, queues) are <em>enough</em> to implement a
<em>universal machine</em> - an <em>intepreter</em> of a language with the <em>Environment
Model of evaluation</em> (which as extruded Substitution Model).</p>
<p>This result was so excited and <em>fundamental</em> that <em>MIT</em> used to teach most
of its CS courses (in Scheme) about these ideas, principles and their
actual implementations. They even build a tiny (but done just right)
Emacs-like editor, called <em>/Edwin</em>, which is included in the MIT Scheme
distribution.</p>
<p>The last classic course of this great lineage (the MIT Scheme tradition)
is the 2004 6.001 SICP Scheme course by <em>Eric Grimson</em> et all. The last
book is <em>Software Design for Flexibility</em> by Sussman, the wizard.</p>
<p>In a dynamically but strongly typed language (with runtime checks) all
these <em>structured values</em> could not just be arbitrary <em>/nested</em> (due to the
fact that everything is an <em>expression</em> and that everything is
<em>homoiconous</em> (of the same CONSes), but also created on-demand and
modified (re-bound) at runtime.</p>
<p>These are the &ldquo;fundamental building blocks&rdquo; of Emacs - the fundamental
data structures and at a higher level the hierarchical layered DSLs embedded in LISP.</p>
<p>The first old implementations were simple-enough to be hacked toghether
by just a few people in their spare time (<em>/excactly</em> due to the right
principles,fundamentals and &ldquo;natural&rdquo; proper design decisions).</p>
<p>Agian, it is not about the gory details of how exactly it is
implemented, but how the architecture, modularity and the embedded language ()for
writing DSLs and packages) has been done just right.</p>
<p>The implementation side is actually ugly &ndash; imperative, mutable,
destructively in-place updated and with the &ldquo;clever&rdquo; <code>C</code> (that no one really
fully understood) under the hood.</p>
<p>No serious attempts has been taken to write a <em>Clojure</em>-like <em>immutable
and persistent</em> &ldquo;stdlib&rdquo; as the shared Basis for all the modules, just as
the SML guys did with their <em>Basis Library</em> or the Erlang guys did with
their OTP.</p>
<p>What is worse, people do not bother to understand the principles and the proper idioms and write low-effort crap with unnecessary bloated dependecies and inappropriate. They just write as they used in that other language they know, like degens write Haskell as if it is J2EE with monad &ldquo;wrapers&rdquo;.</p>
<p>The key to write good Emacs Lisp is to understand the DSLs already presented at each level of abstraction, and to use the <em>proper idioms</em> appropriate for each layer. One would be surprised how <em>little</em> code one has to write &ndash; almost everything is already in the library. This is why some modules are just a few lines, but just the right ones &ndash; as intended.</p>
<p>The big, classic ideas, however, cannot be marred by the dirty impure
imperative low-effort stuff. The fact that LISP is a &ldquo;very-high-level&rdquo; and even
&ldquo;programmable&rdquo; programming language &ndash; one could define one&rsquo;s own <em>control
structures</em> and even <em>special forms</em> (using macros) &ndash; outweights all other
concerns. Hierarchical layers of embedded DSLs is a &ldquo;universal architecture&rdquo;.</p>
<p>The <em>causes</em> of the miracle (of classic software engineering) and the
greatness of the monument are exactly these listed above, and they have
to be realized and fully understood, including the Monoid part (over CONSses).</p>
<p>From the perspective of a merely user of the system (it is by no means
an editor, rather it is a single-binary Lisp OS, (just like Chomium nowadays, by
the way).</p>
<p>So, when you open your Emacs next time just slow down and simply esplore it, wander around and appreciate, as one would in some historic world-heritage site. Most of the details matter and most of the decisions were right. Of course, it is littered with modern junk, with bullshit painted on the walls, etc.</p>
<p>There is <em>a lot</em> more to Emacs. Most notably, people like <em>Sacha Chua</em> (google her) and (to lesser extent) <em>Xah Lee</em>. <em>Mike Zamansky</em>  is also worth mentioning for his youtube series.</p>
<p><a href="https://www.youtube.com/playlist?list=PL9KxKa8NpFxIcNQa9js7dQQIHc81b0-Xg">https://www.youtube.com/playlist?list=PL9KxKa8NpFxIcNQa9js7dQQIHc81b0-Xg</a></p>
<p>There are quiet autistic (it is ok, we are the best by far) programmers who slowly and carefully write (or wrote in the past) wonderful packages, some of which are now abandoned (<code>nXHTML, Icicles</code>, <code>vdiff</code>, etc).</p>
<p>It seems that Emacs requires (or at least could be easily aligned to) some <em>particular mindset</em>, which can be found at places like MIT CSAIL or Bell Labs or any other quiet place where quiet people slowly and carefully crafting something (almost instinct due to modern management bullshit).</p>
<p>And it is not some modern fancy stuff like <code>Doom Emacs</code> that is worth &ldquo;worshiping&rdquo; or at least approach with a <em>religious awe</em> (as one feel inside a great cathedral), but what lead to it, what made it possible, and the principles and big ideas of which Emacs is a manifestation.</p>
<p>Lots of pages has been written about the unique &ldquo;nature&rdquo; of Emacs.</p>
<ul>
<li><em>self-documenting</em> (people of the golden age knew and applied the right principles)</li>
<li>everything is <em>discoverable</em> (every binding and every command can be discovered)</li>
<li>truly <em>extensible</em> (dynamical typed LISP2 with embedded Common Lisp and macros)</li>
<li><em>keyboard macros</em> (it is a software Lisp Machine, after all)</li>
<li><em>Lisp Macros</em> (the way to define your own <em>special forms</em>)</li>
<li><em>Declarative embedded DSLs</em> (what makes Emacs what it is)</li>
</ul>
<p>One could read other guys on the internet about the details and particulars. I am MIT-style principle-loving guy.</p>
<p>Just one more important thing. Emacs is <em>wast</em>, and one does not have to memorize it all (which is an impossible and ultimately futile task anyway). On the contrary, one has to learn how to discover, master, customize and extend the exact features one needs &ndash; this is the true &ldquo;philosophy&rdquo; of Emacs.</p>
<p>To do that one has to understand what he (or she) is doing (and why). From understanding a <em>workflow</em> naturally emerges, and it has to be described informally or even formalized. From an informal description a <em>cheat-sheet</em> of commands and corresponding key-binding can be distilled.</p>
<p>When one discovers that some keys binding are inconvenient or inconsistent with the traditional conventions, then (and only then) one have to change the binding. Consistency and elegance are not optional.</p>
<p>One has strongly resist the stupidity of re-binding all the keys in some non-emacs fashion, and the sheer madness of trying to turn Emacs into Vim. With more than 40 years of continuous refinement, Emacs evolved proper notions of how key bindings shall be organized, and this is about <em>shallow hierarchies (trees) of mnemonic sequences</em>, like <code>C-x p ?</code>. Do not replace an evolved optimum with a low-effort meme-crap.</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://lngnmn2.github.io/tags/emacs/">Emacs</a></li>
      <li><a href="https://lngnmn2.github.io/tags/imperative/">Imperative</a></li>
      <li><a href="https://lngnmn2.github.io/tags/adt/">ADT</a></li>
      <li><a href="https://lngnmn2.github.io/tags/homoiconicity/">Homoiconicity</a></li>
      <li><a href="https://lngnmn2.github.io/tags/embedded/">Embedded</a></li>
      <li><a href="https://lngnmn2.github.io/tags/dsl/">DSL</a></li>
      <li><a href="https://lngnmn2.github.io/tags/monoid/">Monoid</a></li>
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="https://lngnmn2.github.io/">Notes from the digital underground by Lngnmn</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
