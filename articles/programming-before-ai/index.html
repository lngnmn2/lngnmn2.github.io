<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Programming Before AI | Notes from the digital underground by Lngnmn</title>
<meta name="keywords" content="ADT, DSL">
<meta name="description" content="I have to rush to finish my series before AI will completely enshittificate the written knowledge and the classic discipline of programming, which is based on understanding and mathematical rigour.
Yes, I seemingly overuse this word beyond the limits of a good style, but I like it, how it is awkward and ugly and yet perfectly captures what a generative AI is doing to a writtern knowledge itself.
So, let&rsquo;s try to build it all top-down, for a change. Bottom up is probably the better way, but it takes so long time before one begins to see the whole picture, which is, of course, the one and the same mountain (or an elephant) viewed from different angles and perspectives.">
<meta name="author" content="&amp;lt;lngnmn2@yahoo.com&amp;gt;">
<link rel="canonical" href="https://lngnmn2.github.io/articles/programming-before-ai/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.8fe10233a706bc87f2e08b3cf97b8bd4c0a80f10675a143675d59212121037c0.css" integrity="sha256-j&#43;ECM6cGvIfy4Is8&#43;XuL1MCoDxBnWhQ2ddWSEhIQN8A=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://lngnmn2.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://lngnmn2.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://lngnmn2.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://lngnmn2.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://lngnmn2.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://lngnmn2.github.io/articles/programming-before-ai/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Source+Code+Pro:wght@300&display=swap" rel="stylesheet">
<link href="https://fonts.googleapis.com/css2?family=Noto+Sans:wght@300&display=swap" rel="stylesheet">
<link href="https://fonts.googleapis.com/css2?family=Noto+Serif:wght@300&display=swap" rel="stylesheet">
<style>
font-family: 'Noto Serif', serif;
font-family: 'Noto Sans', sans-serif;
font-family: 'Source Code Pro', monospace;
</style>
<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script type="text/javascript" id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script><meta property="og:url" content="https://lngnmn2.github.io/articles/programming-before-ai/">
  <meta property="og:site_name" content="Notes from the digital underground by Lngnmn">
  <meta property="og:title" content="Programming Before AI">
  <meta property="og:description" content="I have to rush to finish my series before AI will completely enshittificate the written knowledge and the classic discipline of programming, which is based on understanding and mathematical rigour.
Yes, I seemingly overuse this word beyond the limits of a good style, but I like it, how it is awkward and ugly and yet perfectly captures what a generative AI is doing to a writtern knowledge itself.
So, let’s try to build it all top-down, for a change. Bottom up is probably the better way, but it takes so long time before one begins to see the whole picture, which is, of course, the one and the same mountain (or an elephant) viewed from different angles and perspectives.">
  <meta property="og:locale" content="en-us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="articles">
    <meta property="article:published_time" content="2025-08-11T00:00:00+05:45">
    <meta property="article:modified_time" content="2025-08-11T15:39:36+05:45">
    <meta property="article:tag" content="ADT">
    <meta property="article:tag" content="DSL">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Programming Before AI">
<meta name="twitter:description" content="I have to rush to finish my series before AI will completely enshittificate the written knowledge and the classic discipline of programming, which is based on understanding and mathematical rigour.
Yes, I seemingly overuse this word beyond the limits of a good style, but I like it, how it is awkward and ugly and yet perfectly captures what a generative AI is doing to a writtern knowledge itself.
So, let&rsquo;s try to build it all top-down, for a change. Bottom up is probably the better way, but it takes so long time before one begins to see the whole picture, which is, of course, the one and the same mountain (or an elephant) viewed from different angles and perspectives.">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Articles",
      "item": "https://lngnmn2.github.io/articles/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Programming Before AI",
      "item": "https://lngnmn2.github.io/articles/programming-before-ai/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Programming Before AI",
  "name": "Programming Before AI",
  "description": "I have to rush to finish my series before AI will completely enshittificate the written knowledge and the classic discipline of programming, which is based on understanding and mathematical rigour.\nYes, I seemingly overuse this word beyond the limits of a good style, but I like it, how it is awkward and ugly and yet perfectly captures what a generative AI is doing to a writtern knowledge itself.\nSo, let\u0026rsquo;s try to build it all top-down, for a change. Bottom up is probably the better way, but it takes so long time before one begins to see the whole picture, which is, of course, the one and the same mountain (or an elephant) viewed from different angles and perspectives.\n",
  "keywords": [
    "ADT", "DSL"
  ],
  "articleBody": "I have to rush to finish my series before AI will completely enshittificate the written knowledge and the classic discipline of programming, which is based on understanding and mathematical rigour.\nYes, I seemingly overuse this word beyond the limits of a good style, but I like it, how it is awkward and ugly and yet perfectly captures what a generative AI is doing to a writtern knowledge itself.\nSo, let’s try to build it all top-down, for a change. Bottom up is probably the better way, but it takes so long time before one begins to see the whole picture, which is, of course, the one and the same mountain (or an elephant) viewed from different angles and perspectives.\nIn the golden age of programming, the ancient sages were discovered the LISP. It has unique properly that its uniform syntactic forms (including the special forms) are represted in terms of the LIST structures (there is a special term for that which I forgot) which means that it is not only a programming language, but also a meta-language for (and of) itself, which intuitively, connects it to molecular biology, where somehow similar, everything is “defined” in terms of just 20 aminoacids.\nBut this is not the only non-coincidental connection. The uniform prefix-notation used in LISP structurally corresponds to an AST, which is not merely a tree, but an acyclic graph of a program, which has all the universal “primitive” structural patterns or “properties” – a “step”, a “fork”, and a “join” (yes, yes, a composition, a conditional and a curried application). There is also recursion, which has a “higher-level” spiral-like complex shape.\nIt turns out, that these “structural elements” are enough for everything – the same underlying “building blocks” which are used to express profs in logic, expressions in functional programming, and even any algorithm using the structural algorithm charting techniques of the 70s (and electrical schematics in the EE field).\nThe question is “why?” Why these “primitive” structures are enough for everything? Why they are universal?\nWell, it has something to do with the proper (and the only) philosophy, which has the only one question to consider – “What Is?”. Most of degens when they hear the world “philosophy” think about some abstract and useless “metaphysical” bullshit and hand-waving, but the real philosophy is about the “reality” and “What Is”, which is not a subjective opinion, but an objective fact, which sometimes can be expressed in terms of the “universal” language of mathematics, and sometimes can only be grasped as an intuitive (but not wrong) understanding, which is what we are doing here.\nThere are some universal fundamental notions, which has been captured in an unambiguous human language and studied in what we call “logic”. There is something called Modus Ponens, which is a universal rule of inference that, among other things, intuitively captured universal the notion of an “necessary and sufficient condition”, which underlay everything, not just biology of Life Itself, but the “chemistry\"and “physics” as its “runtime”.\nAgain, no one knew anything about physics, chemistry and biology (which turn out to be layere DSLs on top of each other), back then, and the only tools they had were observations, capturing of commonalities and similar appearances, generalization, abstraction and intuition.\nSomehow unsurprisingly, the simple typed lambda calculus, which is enough (“necessary and sufficient”) to compute any commutable function, are based on the captured and generalized notions of an “abstraction” and “application” (and “bindings” and nested “scopes”).\nDo you know that every single enzyme produced by all biology is for its “use”. So are every single abstraction (in terms of the lambda calculus) has been introduced for its eventual application. Unsurprisingly, there is something called Gentzen’s Introduction and Elimination Rules (of Natural Deduction), which accidentally captured the proper generalizations of the above. It seems to be a yet another universal principle (at least in Biology), that something “produced” is for being eventually “used” (eliminated or “consumed”).\nThis, abstract notion (that the logical rules come in pairs), of course, goes way deeper. Every valid rule captures some aspect of What Is, and since it actually Is, it can be used somehow, just like a proper definitions can be used within a proof. If you want to dive into metaphysics, which I don’t, think that for every “plus” there is a corresponding “minus”, otherwise the dichotomy simply would not exist.\nMolecular biology has something very similar – an enzyme, which is a particular structure (a particularly “folded” into a unique “shape” or a “form” sequence of amino acids), which perform a certain “functions” when all the necessary and sufficient conditions are met. Not dissimilar to sequences of LISP structures (CONSes) which from particular lambda expressions, parameterized by the “arguments”.\nAnd composition of these lambda expressions form distinct “pathways”, something quite similar to biological “pathways”, which control everything in the “higher-level” systems biology (this is not just an empty analogy – the pathways use a form of “structural message passing”, and the “messages” are just particular molecular structures produced by enzymes, when the necessary conditions are meet, and the conditions, in turn, can be the presence of another molecular structure in some of its particular “slot”, so the “chaining” (of reactions) occurs).\nYes, this “crazy back-and-forth” is intentional. Yes, nothing here is incidental or arbitrary. What the different “blind philosophers” have been captured are the one and the same elephant.\nThe abstract algebra that we are trying to discover, which underlay logic, mathematical proofs, functional programming, sequential presses, and even partially captures the Causality itself, and its “dual” Potentiality, is one and the same (just because the universe is the one and the same unfolding process, and thus contradictions cannot exist in principle). This is what it is all about.\nAgain, this isn’t just an analogy; it’s a deep structural equivalence at the level of “structural primitives”, which we all know intuitively, but never really thought about it in a systematic way.\nThe logical connectives, the algebraic data types, the structural elements of a directed acyclic graph, are the one and the same “primitive patterns”, which emerge again and again at all the different levels of any properly captured abstraction, which is natural, if you thing for it for a second.\nThese simple “forks” and “joins” can be combined (composed) at all levels, to form more complex layered structures, creating a hierarchy of languages and abstractions. And this is why Layered DSLs is such a universal idea.\nA more abstract data types forms the basis of a higher-level DSL over the basic “graph structures”. The “abstraction barrier” is the boundary between these layers—the functional interface of a module, for instance, hides the specific implementation (the concrete DAG structure) from the user, exposing only the types (the propositions). This modularity is a direct consequence of the isomorphism, allowing for clean, stateless interfaces.\nAbstraction, Modularity Abstract Data Types – all the way back to Barbara Liskov, the 70s, 80s, and the early 90s – the golden age of programming, of ML, Scheme and CLU, – the intuitive knowedge.\nThe ADTs correspond to the universal notion of the existential qualifier (there exist an … /such that) – hiding a concrete type behind an abstract interface, an abstraction barrier, exposing only some property (which can be captured by a predicate – such that).\nThe universal qualifier (forall … the property holds) corresponds to parametric polymorphism (of some functions) and to generics. Again, nothing is arbitrary or accidental.\nThere is much more. Nesting of Sets and composition of Functions (which is also nesting) form on the same universal patterns, at the most abstract level, which has been noticed by some Category Theorists, etc, etc.\nOkay. The Curry-Howard Isomorphism reveals that logic, mathematics, and functional programming share the same underlying “primitive” abstract structures, even further reducible to “forks” (branching, possibility) and “joins” (convergence, causality) in a directed acyclic graph, (while evaluation is defined as a graph-reduction process based on substitution of an expression for the value it denotes). These structures underpin algebraic data types, proofs, and programs, forming a hierarchy of modular, stateless “universal” abstractions.\nThese (and only these) shall be the basic building locks of our programs if we want them to be correct, manageable an short. Most of the bloat of modern programming is the direct consequence of unnecessary, redundant “intermediate” abstractions, which mismatch the actual structure of complexity of the domain, and appear at a wrong level of abstraction (usually too low) and unnecessary, redundant error-prone conversions back and forth. between them.\nThe math-majors who designed the ML family of languages understood this intuitively, and designed the languages appropriately. For instance, for any “introduction” of a proper sum-type (a tagged disjoint union) there are at least one corresponding “elimination” using structural pattern-matching (on the tags), so no “case” can be left out or forgot in principle. Options (Maybe) and Results are just proper specialization (of the universal notion of an algebraic sum-type).\nCurrying and partial application is just another instance. We define a curried lambda abstraction as a “join”, and it acts as one when eventually being applied – composed to another such lambda abstraction.\nEverything is an expression, which denote a value of a particular type (no statements or commands) is another universal principle from mathematics and logic. Immutability of both variable bindings and data bindings lead to the referential transparency and (as a direct consequence) to persistent, “immutable” data structures.\nClassic Functional Programming is a well-developed and well-understood subject, so I won’t state all the principles right there (I already did so many times).\nLets try see why it is the only right way/ to program, as opposed to coding, like in webshit or some other imperative crap generated by an AI.\nLets start from the Category Theory! Who wouldn’t like to be Bartosz, slowly methodically explaining the inhabitants of the higher realms of abstraction to idiots.\nFunctors map between layers of abstraction (e.g., from one DSL to another). Monads as higher-level abstractions (an ADT) over “forks” and “joins” of a DAG. Composition is not arbitrary, and it has its “laws” (rules), which has to be preserved. The most intersting and useful part of the Category Theory is not the categories themselves, but from what and how they have been built (constructed). There are, unsurprisingly, some informally defined “Abstract Data Types”, defined in terms of “abstract mathematical interfaces (sets of function’s type-signatures)”, such as Monoid and Functor.\nThe DAG structure corresponds to a category itself, where nodes are “objects” and edges are “morphisms”. “Forks” and “joins” are specific morphisms – coproducts (sums) and products – that define the overall structure of the category.\nForks (sum types, disjunctions) capture possibility: a system can take one of several paths (e.g., Left or Right in ~Either). Joins (function types, conjunctions) capture causality: a system requires all inputs to produce an output (e.g., a curried function application). These are the smallest pieces of the DAG, forming the building blocks of all logical and computational structures. Higher-level abstractions (e.g., lists, trees, monads) are compositions of “forks” and “joins” (on a DAG), organized hierarchically.\nAt a higher level (above the DAG) the Algebraic Data Types form a hierarchy of abstractions, where higher-level types are built from lower-level ones, creating modular, composable systems.\nWhy wouldn’t they also define the structure of our proframs? They do in the better, well-designed languages, in which has the proper support of the algebraic data types – tagged disjoint unions and universal structural pattern-mathing on tags, along with curried functions and the universal partial application. The products (the record or “struct” types) are not such a big deal. All the subtleties are within the data-constructors for a sum-type (a co-product), which corresponds to a “tag” within a type (which, by the way, is just a set of values all possible values), and a “natural” parameterization of these, being a pure functions.\nType-classes and “traits” come as a straightforward (the notion of “such that”) level of abstraction over types.\nSo, how do we actually program, given all this “abstract BS”? This, actually, is the easiest questions – we program with the proper algebraic data types inside abstract data types. End of the story.\npackage the concepts from the “problem domain” into a self-contained orthogonal, lose-coupled modules, one at a time. export the simplest, minimal high-level stateless abstract interfaces from such each module (proper non-leaking abstractions) use distinct layers of such abstractions, separated by clear abstraction boundaries (stateless high-level interfaces) these layers has to be in an one-to-one correspondence with the structure of the problem, otherwise it all will be wrong and flawed. make sure that the two hierarchies (of the problem and of the program) match perfectly (1-to-1) at all levels of abstraction. develop several layers of REPL-friendly functional DSLs, which only use abstractions one level below it – enforce the abstraction barriers go “mostly functional” and always return a new value from a function (unless this is 10000x10000 matrix or something) use the “functional idioms” and the advanced typing support which underlay these idioms. avoid any hidden “encapsulated in objects” mutable state as a plague. Use ref types if you must have some state. statefull OOP is flawed in principle. use “plain” structured data values, like these “in-wire representations”. Remember that biology “works” because every molecule is identical. use iterators over collections and chaining of operators (methods) instead of imperative looping construts over indices. make user-defined types collection-like, by implementing standardized interfaces (traits, typeclasses). make your collections immutable (as in Scala or Clojure) and thus your data strcutres persistent use the Option (Maybe) and Result types consistently everywhere (no nulls in principle, no “forgot” checks) avoid “naked” primitive type values – always use a “new type” wrappers with bounds checking use “smart constrictors” to make an illegal state unrepresentable (yes, yes, this very meme) use type-classes (or traits) to even further constrain too general types. The more constraints – the better. use the pure subsets of a language (even of Rust) to maintain the referential transparency of your code. avoid muts in Rust in princilple, use “moving pipelines” (which “consume”) instead. use wrapper “new types” to extend or further restrict the other types by implementing some “missed” traits. use the standard mathematical notions packaged as type-classes or traits (Eq, Ord. Functor, Monoid). They underlay everything. ",
  "wordCount" : "2379",
  "inLanguage": "en",
  "datePublished": "2025-08-11T00:00:00+05:45",
  "dateModified": "2025-08-11T15:39:36+05:45",
  "author":[{
    "@type": "Person",
    "name": "\u0026lt;lngnmn2@yahoo.com\u0026gt;"
  }],
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://lngnmn2.github.io/articles/programming-before-ai/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Notes from the digital underground by Lngnmn",
    "logo": {
      "@type": "ImageObject",
      "url": "https://lngnmn2.github.io/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://lngnmn2.github.io/" accesskey="h" title="Notes from the digital underground by Lngnmn (Alt + H)">Notes from the digital underground by Lngnmn</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://lngnmn2.github.io/about/" title="About me.">
                    <span>About me.</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title entry-hint-parent">
      Programming Before AI
    </h1>
    <div class="post-meta"><span title='2025-08-11 00:00:00 +0545 +0545'>August 11, 2025</span>&nbsp;·&nbsp;&amp;lt;lngnmn2@yahoo.com&amp;gt;

</div>
  </header> 
  <div class="post-content"><p>I have to rush to finish my series before AI will completely enshittificate the written knowledge and the classic discipline of programming, which is based on understanding and mathematical rigour.</p>
<p>Yes, I seemingly overuse this word beyond the limits of a good style, but I like it, how it is awkward and ugly and yet perfectly captures what a generative AI is doing to a writtern knowledge itself.</p>
<p>So, let&rsquo;s try to build it all top-down, for a change. Bottom up is probably the better way, but it takes so long time before one begins to see the whole picture, which is, of course, the one and the same mountain (or an elephant) viewed from different angles and perspectives.</p>
<p>In the golden age of programming, the ancient sages were discovered the LISP. It has unique properly that its uniform syntactic forms (including the <em>special forms</em>) are represted in terms of the LIST structures (there is a special term for that which I forgot) which means that it is not only a programming language, but also a <em>meta-language</em> for (and of) itself, which <em>intuitively</em>, connects it to molecular biology, where somehow similar, everything is &ldquo;defined&rdquo; in terms of just 20 aminoacids.</p>
<p>But this is not the only non-coincidental connection. The uniform <em>prefix</em>-notation used in LISP structurally corresponds to an AST, which is not merely a tree, but an <em>acyclic graph</em> of a program, which has all the universal &ldquo;primitive&rdquo; structural patterns or &ldquo;properties&rdquo; &ndash; a &ldquo;step&rdquo;, a &ldquo;fork&rdquo;, and a &ldquo;join&rdquo; (yes, yes, a composition, a conditional and a curried application). There is also <em>recursion</em>, which has a &ldquo;higher-level&rdquo; spiral-like complex shape.</p>
<p>It turns out, that these &ldquo;structural elements&rdquo; are <em>enough for everything</em> &ndash; the same underlying &ldquo;building blocks&rdquo; which are used to express profs in logic, expressions in functional programming, and even any algorithm using the structural algorithm charting techniques of the 70s (and electrical schematics in the EE field).</p>
<p>The question is &ldquo;why?&rdquo; Why these &ldquo;primitive&rdquo; structures are enough for everything? Why they are universal?</p>
<p>Well, it has something to do with the proper (and the only) philosophy, which has the only one question to consider &ndash; &ldquo;What Is?&rdquo;.  Most of degens when they hear the world &ldquo;philosophy&rdquo; think about some abstract and useless &ldquo;metaphysical&rdquo; bullshit and hand-waving, but the real philosophy is about the &ldquo;reality&rdquo; and &ldquo;What Is&rdquo;, which is not a subjective opinion, but an objective fact, which <em>sometimes</em> can be expressed in terms of the &ldquo;universal&rdquo; language of mathematics, and sometimes can only be grasped as an <em>intuitive (but not wrong) understanding</em>, which is what we are doing here.</p>
<p>There are some universal fundamental notions, which has been captured in an unambiguous human language and studied in what we call &ldquo;logic&rdquo;. There is something called Modus Ponens, which is a universal rule of inference that, among other things, intuitively captured universal the notion of an &ldquo;necessary and sufficient condition&rdquo;, which underlay <em>everything</em>, not just biology of Life Itself, but the &ldquo;chemistry&quot;and &ldquo;physics&rdquo; as its &ldquo;runtime&rdquo;.</p>
<p>Again, no one knew anything about physics, chemistry and biology (which turn out to be layere DSLs on top of each other),  back then, and the only tools they had were observations, capturing of commonalities and similar appearances,  generalization, abstraction and intuition.</p>
<p>Somehow unsurprisingly, the simple typed lambda calculus, which is enough (&ldquo;necessary and sufficient&rdquo;) to compute any commutable function, are based on the captured and generalized notions of an &ldquo;abstraction&rdquo; and &ldquo;application&rdquo; (and &ldquo;bindings&rdquo; and nested &ldquo;scopes&rdquo;).</p>
<p>Do you know that every single enzyme produced by all biology is for its &ldquo;use&rdquo;. So are every single abstraction (in terms of the lambda calculus) has been introduced for its eventual application. Unsurprisingly, there is something called Gentzen&rsquo;s Introduction and Elimination Rules (of Natural Deduction), which accidentally captured the proper generalizations of the above. It seems to be a yet another universal principle (at least in Biology), that something &ldquo;produced&rdquo; is for being eventually &ldquo;used&rdquo; (eliminated or &ldquo;consumed&rdquo;).</p>
<p>This, abstract notion (that the logical rules come in <em>pairs</em>),  of course, goes way deeper. Every valid rule <em>captures some aspect</em> of <em>What Is</em>, and since it actually <em>Is</em>, it can be <em>used</em> somehow, just like a proper definitions can be used within a proof. If you want to dive into metaphysics, which I don&rsquo;t, think that for every &ldquo;plus&rdquo; there is a corresponding &ldquo;minus&rdquo;, otherwise the dichotomy simply would not exist.</p>
<p>Molecular biology has something very similar &ndash; an enzyme, which is a particular structure (a particularly &ldquo;folded&rdquo; into a unique &ldquo;shape&rdquo; or a &ldquo;form&rdquo; sequence of amino acids), which perform a certain &ldquo;functions&rdquo; when all the necessary and sufficient conditions are met. Not dissimilar to sequences of LISP structures (CONSes) which from particular lambda expressions, parameterized by the &ldquo;arguments&rdquo;.</p>
<p>And composition of these lambda expressions form distinct &ldquo;pathways&rdquo;, something quite similar to biological &ldquo;pathways&rdquo;, which control everything in the &ldquo;higher-level&rdquo; <em>systems  biology</em> (this is not just an empty analogy &ndash; the pathways use a form of &ldquo;structural message passing&rdquo;, and the &ldquo;messages&rdquo; are just particular molecular structures produced by enzymes, when the necessary conditions are meet, and the conditions, in turn, can be the presence of another molecular structure in some of its  particular &ldquo;slot&rdquo;, so the &ldquo;chaining&rdquo; (of reactions) occurs).</p>
<p>Yes, this &ldquo;crazy back-and-forth&rdquo; is intentional. Yes, nothing here is incidental or arbitrary. What the different &ldquo;blind philosophers&rdquo; have been captured are the one and the  same elephant.</p>
<p>The <em>abstract algebra</em> that we are trying to discover,  which underlay logic, mathematical proofs, functional programming, sequential presses, and even partially captures the Causality itself, and its &ldquo;dual&rdquo; Potentiality,  is one and the same (just because the universe is the one and the same unfolding process, and thus contradictions cannot exist in principle). This is what it is all about.</p>
<p>Again, this isn&rsquo;t just an analogy; it&rsquo;s a deep structural equivalence at the level of &ldquo;structural primitives&rdquo;, which we all know intuitively, but never really thought about it in a systematic way.</p>
<p>The logical connectives, the algebraic data types, the structural elements of a directed acyclic graph, are the one and the same &ldquo;primitive patterns&rdquo;, which emerge again and again at all the different levels of <em>any properly captured  abstraction</em>, which is <em>natural</em>, if you thing for it for a second.</p>
<p>These simple &ldquo;forks&rdquo; and &ldquo;joins&rdquo; can be combined (composed) at all levels, to form more complex layered structures, creating a hierarchy of languages and abstractions. And this is why Layered DSLs is such a universal idea.</p>
<p>A more abstract data types forms the basis of a higher-level DSL over the basic &ldquo;graph structures&rdquo;. The &ldquo;abstraction barrier&rdquo; is the boundary between these layers—the functional interface of a module, for instance, hides the specific implementation (the concrete DAG structure) from the user, exposing only the types (the propositions). This modularity is a direct consequence of the isomorphism, allowing for clean, stateless interfaces.</p>
<p>Abstraction, Modularity Abstract Data Types &ndash; all the way back to Barbara Liskov, the 70s, 80s, and the early 90s &ndash;  the golden age of programming, of ML, Scheme and CLU, &ndash; the <em>intuitive</em> knowedge.</p>
<p>The ADTs correspond to the universal notion of the <em>existential qualifier</em> (<em>there exist an &hellip; /such that</em>) &ndash; hiding a concrete type behind <em>an abstract interface</em>, an abstraction barrier, exposing only some <em>property</em> (which can be captured by a predicate &ndash; <em>such that</em>).</p>
<p>The <em>universal qualifier</em> (<em>forall &hellip; the property holds</em>) corresponds to parametric polymorphism (of some functions) and to generics. Again, nothing is arbitrary or accidental.</p>
<p>There is much more. Nesting of Sets and composition of Functions (which is also <em>nesting</em>) form on the same universal patterns, at the most abstract level, which has been noticed by some Category Theorists, etc, etc.</p>
<p>Okay. The Curry-Howard Isomorphism reveals that logic, mathematics, and functional programming share the same underlying &ldquo;primitive&rdquo; abstract structures, even further reducible to &ldquo;forks&rdquo; (branching, possibility) and &ldquo;joins&rdquo; (convergence, causality) in a directed acyclic graph, (while evaluation is defined as a <em>graph-reduction</em> process based on substitution of an expression for the value it denotes). These structures underpin algebraic data types, proofs, and programs, forming a hierarchy of modular, stateless &ldquo;universal&rdquo; abstractions.</p>
<p>These (and only these) shall be the basic building locks of our programs if we want them to be correct, manageable an <em>short</em>. Most of the bloat of modern programming is the direct consequence of unnecessary, redundant &ldquo;intermediate&rdquo; abstractions, which mismatch the actual structure of complexity of the domain, and appear at a wrong level of abstraction (usually <em>too low</em>) and unnecessary, redundant error-prone conversions back and forth. between them.</p>
<p>The math-majors who designed the ML family of languages understood this intuitively, and designed the languages appropriately. For instance, for any &ldquo;introduction&rdquo; of a proper sum-type (a tagged disjoint union) there are at least one corresponding &ldquo;elimination&rdquo; using structural pattern-matching (on the tags), so no &ldquo;case&rdquo; can be left out or forgot <em>in principle</em>. Options (Maybe) and Results are just proper specialization (of the universal notion of an algebraic sum-type).</p>
<p>Currying and partial application is just another instance. We define a curried lambda abstraction as a &ldquo;join&rdquo;, and it acts as one when eventually being applied &ndash; composed to another such lambda abstraction.</p>
<p>Everything is an expression, which denote a value of a particular type (no statements or commands) is another universal principle from mathematics and logic. Immutability of both variable bindings and data bindings lead to the referential transparency and (as a direct consequence) to persistent, &ldquo;immutable&rdquo; data structures.</p>
<p>Classic Functional Programming is a well-developed and well-understood subject, so I won&rsquo;t state all the principles right there (I already did so many times).</p>
<p>Lets try see <em>why</em> it is <em>the only right way/</em> to program, as opposed to coding, like in webshit or some other imperative crap generated by an AI.</p>
<p>Lets start from the Category Theory! Who wouldn&rsquo;t like to be Bartosz, slowly methodically explaining the inhabitants of the higher realms of abstraction  to idiots.</p>
<ul>
<li><em>Functors</em> map between <em>layers of abstraction</em> (e.g., <em>from one DSL to another</em>).</li>
<li><em>Monads</em> as higher-level abstractions (an ADT) over &ldquo;forks&rdquo; and &ldquo;joins&rdquo; of a DAG.</li>
<li>Composition is not arbitrary, and it has its &ldquo;laws&rdquo; (rules), which has to be preserved.</li>
</ul>
<p>The most intersting and useful part of the Category Theory is not the categories themselves, but <em>from what</em> and <em>how</em> they have been built (constructed). There are, unsurprisingly, some informally defined &ldquo;Abstract Data Types&rdquo;, <em>defined in terms of &ldquo;abstract mathematical interfaces (sets of function&rsquo;s type-signatures)&rdquo;</em>, such as Monoid and Functor.</p>
<p>The DAG structure corresponds to a category itself, where nodes are &ldquo;objects&rdquo; and edges are &ldquo;morphisms&rdquo;. &ldquo;Forks&rdquo; and &ldquo;joins&rdquo; are specific morphisms &ndash; coproducts (sums) and products &ndash; that define the overall structure of the category.</p>
<ul>
<li>Forks (sum types, disjunctions) capture possibility: a system can take one of several paths (e.g., <code>Left</code> or <code>Right in ~Either</code>).</li>
<li>Joins (function types, conjunctions) capture causality: a system requires <em>all inputs</em> to produce an output (e.g., a curried function application).</li>
</ul>
<p>These are the smallest pieces of the DAG, forming the building blocks of <em>all</em> logical and computational structures. Higher-level abstractions (e.g., lists, trees, monads) are <em>compositions</em> of &ldquo;forks&rdquo; and &ldquo;joins&rdquo; (on a DAG), <em>organized hierarchically</em>.</p>
<p>At a higher level (above the DAG) the Algebraic Data Types form a hierarchy of abstractions, where <em>higher-level types are built from lower-level ones</em>, creating modular, composable systems.</p>
<p>Why wouldn&rsquo;t they also define the structure of our proframs? They do in the better, well-designed languages, in which has the proper support of the algebraic data types &ndash; tagged disjoint unions and universal <em>structural pattern-mathing</em> on tags, along with curried functions  and the universal <em>partial application</em>. The products (the record or &ldquo;struct&rdquo; types) are not such a big deal. All the subtleties are within the <em>data-constructors</em> for a sum-type  (a co-product), which corresponds to a &ldquo;tag&rdquo; within a type (which, by the way, is just a set of values all possible values), and a &ldquo;natural&rdquo; parameterization of these, being a pure functions.</p>
<p>Type-classes and &ldquo;traits&rdquo; come as a straightforward (the notion of &ldquo;such that&rdquo;) level of abstraction <em>over types</em>.</p>
<p>So, how do we actually program, given all this &ldquo;abstract BS&rdquo;? This, actually, is the easiest questions &ndash; we program with the proper algebraic data types inside abstract data types. End of the story.</p>
<ul>
<li>package the concepts from the &ldquo;problem domain&rdquo; into a self-contained orthogonal, lose-coupled modules, one at a time.</li>
<li>export the simplest, minimal high-level stateless abstract interfaces from such each module (proper non-leaking abstractions)</li>
<li>use distinct layers of such abstractions, separated by clear abstraction boundaries (stateless high-level interfaces)</li>
<li>these layers has to be in an one-to-one correspondence with the structure of the problem, otherwise it all will be wrong and flawed.</li>
<li>make sure that the two hierarchies (of the problem and of the program) match perfectly (1-to-1) at all levels of abstraction.</li>
<li>develop several layers of REPL-friendly functional DSLs, which only use abstractions one level below it &ndash; enforce the abstraction barriers</li>
<li>go &ldquo;mostly functional&rdquo; and always return a new value from a function (unless this is 10000x10000 matrix or something)</li>
<li>use the &ldquo;functional idioms&rdquo; and the advanced typing support which underlay these idioms.</li>
<li>avoid any hidden &ldquo;encapsulated in objects&rdquo; mutable  state as a plague. Use <code>ref</code> types if you must  have some state. statefull OOP is flawed in principle.</li>
<li>use &ldquo;plain&rdquo; structured data values, like these &ldquo;in-wire representations&rdquo;. Remember that biology &ldquo;works&rdquo; because every molecule is identical.</li>
<li>use iterators over collections and chaining of operators (methods) instead of imperative looping construts over indices.</li>
<li>make user-defined types collection-like, by implementing standardized  interfaces (traits, typeclasses).</li>
<li>make your collections immutable (as in Scala or Clojure) and thus your data strcutres persistent</li>
<li>use the Option (Maybe) and Result types consistently everywhere (no nulls in principle, no &ldquo;forgot&rdquo; checks)</li>
<li>avoid &ldquo;naked&rdquo; primitive type values &ndash; always use a &ldquo;new type&rdquo; wrappers with bounds checking</li>
<li>use &ldquo;smart constrictors&rdquo; to make an illegal state unrepresentable (yes, yes, this very meme)</li>
<li>use type-classes (or traits) to even further constrain too general types. The more constraints &ndash; the better.</li>
<li>use the pure subsets of a language (even of Rust) to maintain the referential transparency of your  code.</li>
<li>avoid muts in Rust in princilple, use &ldquo;moving pipelines&rdquo; (which &ldquo;consume&rdquo;) instead.</li>
<li>use wrapper &ldquo;new types&rdquo; to extend or further restrict the other types by implementing some &ldquo;missed&rdquo; traits.</li>
<li>use the standard mathematical notions packaged as type-classes or traits (Eq, Ord. Functor, Monoid). They underlay everything.</li>
</ul>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://lngnmn2.github.io/tags/adt/">ADT</a></li>
      <li><a href="https://lngnmn2.github.io/tags/dsl/">DSL</a></li>
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="https://lngnmn2.github.io/">Notes from the digital underground by Lngnmn</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
