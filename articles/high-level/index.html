<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>High Level | Notes from the digital underground by Lngnmn</title>
<meta name="keywords" content="ADT, homoiconicity, DSL">
<meta name="description" content="I finally found a well-written no-bullshit book about CS. It says, among other things:
There is no need to define a representation of the values False and True in terms of values of some other type.
Conceptually, values of type Bool are simply (denoted by) the expressions False and True.
Of course, the computer’s internal representation of Bool and all other data is in terms of bits, but we don’t need to know any of the details of how that works to write programs.">
<meta name="author" content="&amp;lt;lngnmn2@yahoo.com&amp;gt;">
<link rel="canonical" href="https://lngnmn2.github.io/articles/high-level/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.45e028aa8ce0961349adf411b013ee39406be2c0bc80d4ea3fc04555f7f4611a.css" integrity="sha256-ReAoqozglhNJrfQRsBPuOUBr4sC8gNTqP8BFVff0YRo=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://lngnmn2.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://lngnmn2.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://lngnmn2.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://lngnmn2.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://lngnmn2.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://lngnmn2.github.io/articles/high-level/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Source+Code+Pro:wght@300&display=swap" rel="stylesheet">
<link href="https://fonts.googleapis.com/css2?family=Noto+Sans:wght@300&display=swap" rel="stylesheet">
<link href="https://fonts.googleapis.com/css2?family=Noto+Serif:wght@300&display=swap" rel="stylesheet">
<style>
font-family: 'Noto Serif', serif;
font-family: 'Noto Sans', sans-serif;
font-family: 'Source Code Pro', monospace;
</style>
<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script type="text/javascript" id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
  

<meta property="og:url" content="https://lngnmn2.github.io/articles/high-level/">
  <meta property="og:site_name" content="Notes from the digital underground by Lngnmn">
  <meta property="og:title" content="High Level">
  <meta property="og:description" content="I finally found a well-written no-bullshit book about CS. It says, among other things:
There is no need to define a representation of the values False and True in terms of values of some other type.
Conceptually, values of type Bool are simply (denoted by) the expressions False and True.
Of course, the computer’s internal representation of Bool and all other data is in terms of bits, but we don’t need to know any of the details of how that works to write programs.">
  <meta property="og:locale" content="en-us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="articles">
    <meta property="article:published_time" content="2023-10-05T00:00:00+05:45">
    <meta property="article:modified_time" content="2023-10-05T17:03:30+05:45">
    <meta property="article:tag" content="ADT">
    <meta property="article:tag" content="Homoiconicity">
    <meta property="article:tag" content="DSL">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="High Level">
<meta name="twitter:description" content="I finally found a well-written no-bullshit book about CS. It says, among other things:
There is no need to define a representation of the values False and True in terms of values of some other type.
Conceptually, values of type Bool are simply (denoted by) the expressions False and True.
Of course, the computer’s internal representation of Bool and all other data is in terms of bits, but we don’t need to know any of the details of how that works to write programs.">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Articles",
      "item": "https://lngnmn2.github.io/articles/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "High Level",
      "item": "https://lngnmn2.github.io/articles/high-level/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "High Level",
  "name": "High Level",
  "description": "I finally found a well-written no-bullshit book about CS. It says, among other things:\nThere is no need to define a representation of the values False and True in terms of values of some other type.\nConceptually, values of type Bool are simply (denoted by) the expressions False and True.\nOf course, the computer’s internal representation of Bool and all other data is in terms of bits, but we don’t need to know any of the details of how that works to write programs.",
  "keywords": [
    "ADT", "homoiconicity", "DSL"
  ],
  "articleBody": "I finally found a well-written no-bullshit book about CS. It says, among other things:\nThere is no need to define a representation of the values False and True in terms of values of some other type.\nConceptually, values of type Bool are simply (denoted by) the expressions False and True.\nOf course, the computer’s internal representation of Bool and all other data is in terms of bits, but we don’t need to know any of the details of how that works to write programs.\nYeah, this is the main principle behind “high-level” languages - we don’t have to think about any actual machine representations (even do not have to think about representations and implementations of proper ADTs and DSLs). They are “below the level of abstraction” (this is already a meme).\nIt “naturally follows” then, that good high-level languages are just systems of mathematics and logic, subject to the constraints of a machine representations, just like SML, Miranda, Haskell or Ocaml.\nThe first such language was, of course, LISP. Paul Graham wrote his modern classic “On Lisp” which tells you all the whys. R5RS Scheme made it almost perfect. Ironically, modern Python became what Common Lisp supposed to be, still being inferior to it, but this is another story. The main principle is to stay high-level, or, paraphrasing Graham – “to grow your own embedded DSL to match the conceptual level of a problem”. The LISP tradition was sort of an Upanishadic one – they have grasped the reality.\nJust like one uses Lists (with built-in syntactic sugar in Haskell) without thinking beyond the concept and its abstract properties (as being a sequence), one should do the same with all other ADTs, especially one’s own. They has to be proper non-leaking abstractions.\nOne can tell that a language is bad (really) when one has to stumble upon a low-level (representation-level) constructs and syntax (which has to be clearly and completely separated out by the abstract data types).\nEven references could be made as a proper ADT.\nThis is why Java and C++ are so bad - we always have to deal with the “machine types” and aspects of an imperative machine code at a higher level of abstraction. Add to this unnecessary stupid verbosity and the need to write a lot of boilerplate (which is a mix of low level constructs and used-defined types), and wallah.\nThere are even worse languages, which breaks universal mathematical and logical assumptions (PHP and Javascript) because the “designers” of these languages were not just unqualified, but lacked the basic education. We do not talk about these languages here, just like fine people do not talk about anal porn.\n(Just google “The Fractal of Bad Design” and “FTW, Javascript”).\nYes, it is possible to write proper high-level ADTs and classes in C++, even redefining (overloading) the common operators, but very few people do this because so much understanding and discipline is required.\nGood languages, like Scala 3, rise the level of abstraction. The classic languages of the ML family, which were designed as the basis for theorem provers, are implementations of mathematics and systems of logic.\nThere, literally, thousands of years of rigorous thinking and corresponding traditions and even culture has been properly “codified” and “implemented” in these classic languages.\nThis is how one actually climbs on shoulders of the Titans.\nThe “lesson” is, as usual, that All We Need is Lambda (augmented with Algebraic Types, Type-Classes or Traits and Extension Methods).\nAnd that the types are properly defines as Sets of operations on values (together with relations, invariants and “laws” among them), just as Sets themselves has been defined by mathematicians.\n",
  "wordCount" : "607",
  "inLanguage": "en",
  "datePublished": "2023-10-05T00:00:00+05:45",
  "dateModified": "2023-10-05T17:03:30+05:45",
  "author":[{
    "@type": "Person",
    "name": "\u0026lt;lngnmn2@yahoo.com\u0026gt;"
  }],
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://lngnmn2.github.io/articles/high-level/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Notes from the digital underground by Lngnmn",
    "logo": {
      "@type": "ImageObject",
      "url": "https://lngnmn2.github.io/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://lngnmn2.github.io/" accesskey="h" title="Notes from the digital underground by Lngnmn (Alt + H)">Notes from the digital underground by Lngnmn</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://lngnmn2.github.io/about/" title="About me.">
                    <span>About me.</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title entry-hint-parent">
      High Level
    </h1>
    <div class="post-meta"><span title='2023-10-05 00:00:00 +0545 +0545'>October 5, 2023</span>&nbsp;·&nbsp;&amp;lt;lngnmn2@yahoo.com&amp;gt;

</div>
  </header> 
  <div class="post-content"><p>I finally found a well-written no-bullshit book about CS. It says, among other things:</p>
<p>There is no need to define a representation of the values <code>False</code> and <code>True</code> in terms of values of some other type.</p>
<p>Conceptually, values of type <code>Bool</code> are simply (denoted by) the expressions <code>False</code> and <code>True</code>.</p>
<p>Of course, the computer’s internal <em>representation</em> of <code>Bool</code> and all other data is in terms of bits, but <strong>we don’t need to know any of the details of how that works to write programs</strong>.</p>
<p>Yeah, <em>this</em> is the main principle behind &ldquo;high-level&rdquo; languages - we don&rsquo;t have to think about any actual <em>machine</em> representations (even do not have to think about <em>representations</em> and <em>implementations</em> of proper ADTs and DSLs). They are &ldquo;below the level of abstraction&rdquo; (this is already a meme).</p>
<p>It &ldquo;naturally follows&rdquo; then, that good high-level languages <em>are</em> just systems of mathematics and logic, subject to the constraints of a machine representations, just like SML, Miranda, Haskell or Ocaml.</p>
<p>The <em>first</em> such language was, of course, LISP. Paul Graham wrote his <em>modern classic</em> &ldquo;On Lisp&rdquo; which tells you all the <em>whys</em>. R5RS Scheme made it almost perfect. Ironically, modern Python became what Common Lisp supposed to be, still being inferior to it, but this is another story. The main principle is to stay <em>high-level</em>, or, paraphrasing Graham &ndash; &ldquo;to grow your own embedded DSL to match the conceptual level of a problem&rdquo;. The LISP tradition was sort of an Upanishadic one &ndash; they have grasped the reality.</p>
<p>Just like one uses <code>Lists</code> (with built-in <em>syntactic sugar</em> in Haskell) without thinking beyond the concept and its abstract properties (as being a <em>sequence</em>), one should do the same with all other ADTs, especially one&rsquo;s own. They has to be proper <em>non-leaking abstractions</em>.</p>
<p>One can tell that a language is bad (really) when one has to stumble upon a low-level (representation-level) constructs and syntax (which has to be clearly and <em>completely separated out</em> by the <em>abstract data types</em>).</p>
<p>Even <em>references</em> could be made as a proper ADT.</p>
<p>This is why Java and C++ are so bad - we always have to deal with the &ldquo;machine types&rdquo; and aspects of an imperative machine code at a higher level of abstraction. Add to this unnecessary stupid verbosity and the need to write a lot of boilerplate (which is a mix of low level constructs and used-defined types), and wallah.</p>
<p>There are even worse languages, which breaks universal mathematical
and logical assumptions (PHP and Javascript) because the &ldquo;designers&rdquo; of these languages were not just unqualified, but lacked the basic education. We do not talk about these languages here, just like fine people do not talk about anal porn.</p>
<p>(Just google &ldquo;The Fractal of Bad Design&rdquo; and &ldquo;FTW, Javascript&rdquo;).</p>
<p>Yes, it is possible to write proper high-level ADTs and classes in C++, even redefining (overloading) the common operators, but very few people do this because so much understanding and discipline is
required.</p>
<p>Good languages, like Scala 3, rise the level of abstraction. The
classic languages of the ML family, which were designed as the
basis for <em>theorem provers</em>, are implementations of mathematics and
systems of logic.</p>
<p>There, literally, thousands of years of rigorous thinking and
corresponding <em>traditions</em> and even culture has been properly &ldquo;codified&rdquo; and &ldquo;implemented&rdquo; in these classic languages.</p>
<p>This is how one <em>actually</em> climbs on shoulders of the Titans.</p>
<p>The &ldquo;lesson&rdquo; is, as usual, that <em>All We Need is Lambda</em> (augmented with <em>Algebraic Types, Type-Classes</em> or <em>Traits and Extension Methods</em>).</p>
<p>And that the types are properly defines as <em>Sets of operations</em> on
values (together with relations, invariants and &ldquo;laws&rdquo; among them), just as Sets themselves has been defined by mathematicians.</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://lngnmn2.github.io/tags/adt/">ADT</a></li>
      <li><a href="https://lngnmn2.github.io/tags/homoiconicity/">Homoiconicity</a></li>
      <li><a href="https://lngnmn2.github.io/tags/dsl/">DSL</a></li>
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="https://lngnmn2.github.io/">Notes from the digital underground by Lngnmn</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
