<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>A puke from too many bullshit YouTube videos. | Notes from the digital underground by Lngnmn</title>
<meta name="keywords" content="ADT">
<meta name="description" content="Recently I have poisoned myself by watching some talking heads on YouTube. The topic was &ldquo;something something structural system design&rdquo;.
There is a &ldquo;correspondence&rdquo; (not a true isomorphism, but still) between the structural patterns in molecular and cell biology and patterns in a pure functional code &ndash; an augmented Lambda Calculus.
Both &ldquo;systems&rdquo; are heavily constrained by the execution environment (molecular structures of cell biology is the code and the data, the Universe (in a particular locality) is the runtime).">
<meta name="author" content="&amp;lt;lngnmn2@yahoo.com&amp;gt;">
<link rel="canonical" href="https://lngnmn2.github.io/articles/before-breakfast/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.d6fcd20a4fb86efa4dfac8ec95da60244cc8871042183da1ef28e3a762ad79c8.css" integrity="sha256-1vzSCk&#43;4bvpN&#43;sjsldpgJEzIhxBCGD2h7yjjp2Ktecg=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://lngnmn2.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://lngnmn2.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://lngnmn2.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://lngnmn2.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://lngnmn2.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://lngnmn2.github.io/articles/before-breakfast/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Source+Code+Pro:wght@300&display=swap" rel="stylesheet">
<link href="https://fonts.googleapis.com/css2?family=Noto+Sans:wght@300&display=swap" rel="stylesheet">
<link href="https://fonts.googleapis.com/css2?family=Noto+Serif:wght@300&display=swap" rel="stylesheet">
<style>
font-family: 'Noto Serif', serif;
font-family: 'Noto Sans', sans-serif;
font-family: 'Source Code Pro', monospace;
</style>
<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script type="text/javascript" id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
  

<meta property="og:url" content="https://lngnmn2.github.io/articles/before-breakfast/">
  <meta property="og:site_name" content="Notes from the digital underground by Lngnmn">
  <meta property="og:title" content="A puke from too many bullshit YouTube videos.">
  <meta property="og:description" content="Recently I have poisoned myself by watching some talking heads on YouTube. The topic was “something something structural system design”.
There is a “correspondence” (not a true isomorphism, but still) between the structural patterns in molecular and cell biology and patterns in a pure functional code – an augmented Lambda Calculus.
Both “systems” are heavily constrained by the execution environment (molecular structures of cell biology is the code and the data, the Universe (in a particular locality) is the runtime).">
  <meta property="og:locale" content="en-us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="articles">
    <meta property="article:published_time" content="2024-06-19T00:00:00+05:45">
    <meta property="article:modified_time" content="2024-06-19T10:24:40+05:45">
    <meta property="article:tag" content="ADT">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="A puke from too many bullshit YouTube videos.">
<meta name="twitter:description" content="Recently I have poisoned myself by watching some talking heads on YouTube. The topic was &ldquo;something something structural system design&rdquo;.
There is a &ldquo;correspondence&rdquo; (not a true isomorphism, but still) between the structural patterns in molecular and cell biology and patterns in a pure functional code &ndash; an augmented Lambda Calculus.
Both &ldquo;systems&rdquo; are heavily constrained by the execution environment (molecular structures of cell biology is the code and the data, the Universe (in a particular locality) is the runtime).">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Articles",
      "item": "https://lngnmn2.github.io/articles/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "A puke from too many bullshit YouTube videos.",
      "item": "https://lngnmn2.github.io/articles/before-breakfast/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "A puke from too many bullshit YouTube videos.",
  "name": "A puke from too many bullshit YouTube videos.",
  "description": "Recently I have poisoned myself by watching some talking heads on YouTube. The topic was \u0026ldquo;something something structural system design\u0026rdquo;.\nThere is a \u0026ldquo;correspondence\u0026rdquo; (not a true isomorphism, but still) between the structural patterns in molecular and cell biology and patterns in a pure functional code \u0026ndash; an augmented Lambda Calculus.\nBoth \u0026ldquo;systems\u0026rdquo; are heavily constrained by the execution environment (molecular structures of cell biology is the code and the data, the Universe (in a particular locality) is the runtime).",
  "keywords": [
    "ADT"
  ],
  "articleBody": "Recently I have poisoned myself by watching some talking heads on YouTube. The topic was “something something structural system design”.\nThere is a “correspondence” (not a true isomorphism, but still) between the structural patterns in molecular and cell biology and patterns in a pure functional code – an augmented Lambda Calculus.\nBoth “systems” are heavily constrained by the execution environment (molecular structures of cell biology is the code and the data, the Universe (in a particular locality) is the runtime).\nLots of the “ancient tradition” programmers (in the 70s) have similar obvious intuitions. Here is how to see this “correspondence” more clearly.\nThe async cancer The reason I mentioned it here is that it lead to a profound insight (or rather a late discovery).\nThe problem with async is that idiots put it literally everywhere, while the actual use-cases are very limited and always specialized. Yes, this generalizes to the statement that async, in principle, is not general-enough and should never be thought as “the right way to program”.\nLets “unpack” (it is so funny to mock some narcissistic degens). There is only one “kind” of “activities” which are suitable for async – it is when you wait for something completely decoupled (independent) from what you do.\nThe best example is an ordering of a delivery of some food. Once order has been placed, one could (continue to) do whetever one wants (except, perhaps, going out for a long time). This is the principal point – there is no coupling between (expected arrival of) food and what one could do.\nThe example of the another kind of activities is when one is about to hit some nails and is waiting for a hammer to be delivered. Contrary to what “popular bullhitters (writers)” would say, there is nothing much to do, so one is essentially ruining an idle loop, waiting for an async task to be completed, which semantically is not different from just “blocking” on it.\nThis is a crucial distinction – when a function cannot do anything meaningful before an async operation is completed, it should not be used.\nThis rule is similar to the rule about exceptions (which is a weak form of async) – if you would catch it in the same block of code, do not throw it at all, just use an option type.\nThese are not some “opinions” – these are rules to reduce (to not to introduce) an unnecessary and redundant complexity, which is the main principle of non-bullshit prigramming.\nOne more observation. The classic use case for async has been outlined in “classic” Chess Grossmaster architectural pattern, popularized back then by the nginx authors.\nYes, when you have “actually nothing to do” before this opponent “completes”, you may “play with another opponents”. This implies some queue (of opponents) and just processing the next “item” in it, unless it is empty. If all the “opponents” are “not completed”, you have to “do nothing” anyway.\nUnlike human chess players, a procedure (or a block of code) usually has noting to do until the data it would use is “incomplete”. This means very scope and “granularity” at the level of code. There is no “grossmaster” in here, except for a rare exception, when one explicitly implements processing of “scheduled” (expected) events or tasks.\nOne more time, you almost never actually need any asynchrony, because the actual nature of the most computations are synchronous and blocking.\nThis reflects the generalized notion that a process busy-waits (if not blocks) on an empty channel (queue, whatever).\nThe specialization of the fundamental notion of an “empty” as of “not being available yet” is still fundamental – one cannot avoid it or pretend that it isn’t Out There. Busy-waiting (do-nothing loop) instead of “honest” blocking is much worse, due to all the added unnecessary complexity.\nThe async monad The guys at Microsoft Research (I guess) discovered (not invented) the way to put a necessary (required) proper abstraction barrier (a Monad type) between two fundamentally different kinds of code – pure functions and async “tasks”.\nThere is a subtle but crucial point about the pure-functional code and of using Monads with it.\nAny pure functional code is by definition (in principle) declarative – it only defines (declares, literally describes) what has to (ought to) be done (eventually) without the ability (again, in principle) to “actually see” any value. All one could “program” is what has to be done when the value (or more generally - a pattern) is this, and what has to be done (eventually), when a pattern is that. Very few people realize this.\nThis is how the functional programming paradigm is different from an imperative one, including OOP. Again, this is not just some “popular books” bullshit, this is an actual fact.\nSo, we could define an async tasks using the same language, but actually run them (eventually) only behind an impenetrable, “one-way” (in principle) abstraction barrier, which is actually necessary and required due to the “mechanics” of how the code will actually be interpreted (executed).\nThis is just an explicit abstraction barrier in place of an implicit one – exactly as between ordinary imperative procedural code and the interrupt-handlers, which is, technically, the same assembly (machine code) procedures. The actual abstraction barrier is implemented (and enforced) at the machine level.\nThe point is that it is necessary and required, and better to be explicit than implicit.\nThis principle, of necessary separation (partition) between different kinds of code, in turn, leads to the discovery of an “architectural pattern” of “putting an impure code to the outer edges”, which is, of course, corresponds (analogous) to the cell-membranes of biological systems. The “pumps” and “gates” on a membrane are, indeed, exported public interfaces.\nThis is not some abstract bullshit, this is a “correspondence”, similar in its nature to the Curry-Howard one. It captures the universal notions of nesting and “abstraction by parameterization” (cell membranes, individual enzymes) and “partial application”.\nthe right way Again, because this is hard to grasp, but is absolutely crucial to realize – there are always different (specialized) kinds of code, and they must be clearly separated (partitioned). This is a universal principle and “architectural pattern”.\nThe Monad type-class, with its “lifting”, (or Functor) aspect, establishes an “one-way” abstraction barrier, each concrete instance (of the type-class) being itself an ADT.\nThis is the proper way to separate the async code, because it is by definition (and implementation) is the code of a different kind.\nNo “frameworks” are required, just a type-discipline. In the actually pure language like Haskell there is simply no other way due to the function composition (via nesting) aspect of monadic values.\nThere are just declarative composition (nesting) of “maps” (over “lifted” behind the particular abstraction barrier values).\nAnd this is a discovered Universal pattern, which corresponds (not an true isomorphism, but still) to the “structural patterns” discovered and used by a cell biology.\nWhen do we actually need all this? When the code is necessary of a different kind (IO, async, at least) an explicit and actually impenetrable abstraction barrier (a partition) is necessary. It is that simple - the same language but the different kinds of code – an abstraction barrier must be established.\nIt is way better to let the compiler to reinforce this abstraction barrier, insted of trying to always keep it in the mind.\nThis approach solves the problem of how you accessing the async code – you don’t. You just write declaratively what has to be done (eventually) behind this abstraction barrier (at runtime), and thus naturally “push it onto the outer edges”. This is the right way.\nWhy this is so difficult to grasp? Because there are two confusing views – from inside of a cell membrane and from outside of a cell membrane, and one has to clearly understand which is which.\nThe underlying abstractions, such as Functor, do not have such a distinction (crated only by the mind of an external observer).\nAgain, we just have to systematically compose declarative maps (via implicit nesting) to be eventually evaluated behind an abstraction barrier (which will never be actually “seen” from the level of the code).\nTo realize this is to analytically solve the most of the hardest problems in so-called “structured system design” – the things the babble about on YouTube.\n",
  "wordCount" : "1385",
  "inLanguage": "en",
  "datePublished": "2024-06-19T00:00:00+05:45",
  "dateModified": "2024-06-19T10:24:40+05:45",
  "author":[{
    "@type": "Person",
    "name": "\u0026lt;lngnmn2@yahoo.com\u0026gt;"
  }],
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://lngnmn2.github.io/articles/before-breakfast/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Notes from the digital underground by Lngnmn",
    "logo": {
      "@type": "ImageObject",
      "url": "https://lngnmn2.github.io/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://lngnmn2.github.io/" accesskey="h" title="Notes from the digital underground by Lngnmn (Alt + H)">Notes from the digital underground by Lngnmn</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://lngnmn2.github.io/about/" title="About me.">
                    <span>About me.</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title entry-hint-parent">
      A puke from too many bullshit YouTube videos.
    </h1>
    <div class="post-meta"><span title='2024-06-19 00:00:00 +0545 +0545'>June 19, 2024</span>&nbsp;·&nbsp;&amp;lt;lngnmn2@yahoo.com&amp;gt;

</div>
  </header> 
  <div class="post-content"><p>Recently I have poisoned myself by watching some talking heads on YouTube. The topic was &ldquo;something something structural system design&rdquo;.</p>
<p>There is a &ldquo;correspondence&rdquo; (not a true isomorphism, but still) between the structural patterns in molecular and cell biology and patterns in a pure functional code &ndash; an augmented Lambda Calculus.</p>
<p>Both &ldquo;systems&rdquo; are heavily constrained by the execution environment (molecular structures of cell biology is the code and the data, the Universe (in a particular locality) is the <em>runtime</em>).</p>
<p>Lots of the &ldquo;ancient tradition&rdquo; programmers (in the 70s) have similar obvious <em>intuitions</em>. Here is how to see this &ldquo;correspondence&rdquo; more clearly.</p>
<h2 id="the-async-cancer">The async cancer<a hidden class="anchor" aria-hidden="true" href="#the-async-cancer">#</a></h2>
<p>The reason I mentioned it here is that it lead to a profound insight (or rather a late discovery).</p>
<p>The problem with async is that idiots put it literally everywhere, while the actual use-cases are <em>very</em> limited and always <em>specialized</em>. Yes, this generalizes to the statement that async, in principle, is not general-enough and should never be thought as &ldquo;the right way to program&rdquo;.</p>
<p>Lets &ldquo;unpack&rdquo; (it is so funny to mock some narcissistic degens). There is only one &ldquo;kind&rdquo; of &ldquo;activities&rdquo; which are suitable for async &ndash; it is when you wait for something completely decoupled (independent) from what you do.</p>
<p>The best example is an ordering of a delivery of some food. Once order has been placed, one could (continue to) do whetever one wants (except, perhaps, going out for a long time). This is the principal point &ndash; there is no coupling between (expected arrival of) food and what one could do.</p>
<p>The example of the another kind of activities is when one is about to hit some nails and is waiting for a hammer to be delivered. Contrary to what &ldquo;popular bullhitters (writers)&rdquo; would say, there is nothing much to do, so one is essentially ruining an idle loop, waiting for an async task to be completed, which semantically is not different from just &ldquo;blocking&rdquo; on it.</p>
<p>This is a crucial distinction &ndash; when a function cannot do anything meaningful before an async operation is completed, it should not be used.</p>
<p>This rule is similar to the rule about exceptions (which is a weak form of async) &ndash; if you would catch it in the same block of code, do not throw it at all, just use an option type.</p>
<p>These are not some &ldquo;opinions&rdquo; &ndash; these are rules to reduce (to not to introduce) an unnecessary and redundant complexity, which is the main principle of non-bullshit prigramming.</p>
<p>One more observation. The classic use case for async has been outlined in &ldquo;classic&rdquo; <em>Chess Grossmaster</em> architectural pattern, popularized back then by the <code>nginx</code> authors.</p>
<p>Yes, when you have &ldquo;actually nothing to do&rdquo; before this opponent &ldquo;completes&rdquo;, you may &ldquo;play with another opponents&rdquo;. This implies some <em>queue</em> (of opponents) and just processing the next &ldquo;item&rdquo; in it, unless it is empty. If all the &ldquo;opponents&rdquo; are &ldquo;not completed&rdquo;, you have to &ldquo;do nothing&rdquo; anyway.</p>
<p>Unlike human chess players, a procedure (or a block of code) usually has noting to do until the data it would use is &ldquo;incomplete&rdquo;. This means very <em>scope</em> and &ldquo;granularity&rdquo; at the level of code. There is no &ldquo;grossmaster&rdquo; in here, except for a rare exception, when one explicitly implements processing of &ldquo;scheduled&rdquo; (expected) events or tasks.</p>
<p>One more time, you almost never actually need any asynchrony, because the actual nature of the most computations are synchronous and blocking.</p>
<p>This reflects the generalized notion that a process <em>busy-waits</em> (if not blocks) on an <em>empty</em> channel (queue, whatever).</p>
<p>The specialization of the fundamental notion of an &ldquo;empty&rdquo; as of &ldquo;not being available yet&rdquo; is still fundamental &ndash; one cannot avoid it or pretend that it isn&rsquo;t Out There. <em>Busy-waiting</em> (do-nothing loop) instead of &ldquo;honest&rdquo; blocking is much worse, due to all the added unnecessary complexity.</p>
<h2 id="the-async-monad">The async monad<a hidden class="anchor" aria-hidden="true" href="#the-async-monad">#</a></h2>
<p>The guys at Microsoft Research (I guess) <em>discovered</em> (not invented) the way to put a necessary (required) <em>proper abstraction barrier (a Monad type)</em> between two fundamentally different kinds of code &ndash; pure functions and async &ldquo;tasks&rdquo;.</p>
<p>There is a subtle but crucial point about the pure-functional code and of using Monads with it.</p>
<p>Any pure functional code is by definition (in principle) <em>declarative</em> &ndash; it only defines (declares, literally describes) <em>what has to (ought to) be done (eventually)</em> without the ability (again, in principle) to &ldquo;actually see&rdquo; any value. All one could &ldquo;program&rdquo; is what has to be done <em>when</em> the value (or more generally - a pattern) is this, and what has to be done (<em>eventually</em>), when a pattern is that. Very few people realize this.</p>
<p>This is <em>how</em> the functional programming paradigm is different from an imperative one, including OOP. Again, this is not just some &ldquo;popular books&rdquo; bullshit, this is an actual fact.</p>
<p>So, we could define an async tasks using the same language, but actually run them (eventually) only behind an impenetrable, &ldquo;one-way&rdquo; (in principle) abstraction barrier, which is actually <em>necessary</em> and <em>required</em> due to the &ldquo;mechanics&rdquo; of how the code will actually be interpreted (executed).</p>
<p>This is just an explicit abstraction barrier in place of an implicit one &ndash; exactly as between ordinary imperative procedural code and <em>the interrupt-handlers</em>, which is, technically, the same assembly (machine code) procedures. The actual abstraction barrier is implemented (and enforced) at the machine level.</p>
<p>The point is that it is necessary and required, and better to be explicit than implicit.</p>
<p>This principle, of necessary separation (partition) between different kinds of code, in turn, leads to the discovery of an &ldquo;architectural pattern&rdquo; of &ldquo;putting an impure code to the outer edges&rdquo;, which is, of course, corresponds (analogous) to the cell-membranes of biological systems. The &ldquo;pumps&rdquo; and &ldquo;gates&rdquo; on a membrane are, indeed, <em>exported public interfaces</em>.</p>
<p>This is not some abstract bullshit, this is a <em>&ldquo;correspondence&rdquo;</em>, similar in its nature to the <em>Curry-Howard</em> one. It captures the universal notions of <em>nesting</em> and &ldquo;abstraction by parameterization&rdquo; (cell membranes, individual enzymes) and &ldquo;partial application&rdquo;.</p>
<h2 id="the-right-way">the right way<a hidden class="anchor" aria-hidden="true" href="#the-right-way">#</a></h2>
<p>Again, because this is hard to grasp, but is absolutely crucial to realize &ndash; there are always different (specialized) kinds of code, and they must be clearly separated (partitioned). This is a universal principle and &ldquo;architectural pattern&rdquo;.</p>
<p>The Monad type-class, with its &ldquo;lifting&rdquo;, (or <em>Functor</em>) aspect, establishes an &ldquo;one-way&rdquo; abstraction barrier, each <em>concrete instance</em> (of the type-class) being itself an <em>ADT</em>.</p>
<p>This is the proper way to separate the async code, because it is by definition (and implementation) is <em>the code of a different kind</em>.</p>
<p>No &ldquo;frameworks&rdquo; are required, just a type-discipline. In the actually pure language like Haskell there is simply <em>no other way</em> due to the function composition (via nesting) aspect of <em>monadic values</em>.</p>
<p>There are just <em>declarative composition (nesting) of &ldquo;maps&rdquo; (over &ldquo;lifted&rdquo; behind the particular abstraction barrier values)</em>.</p>
<p>And this is a discovered Universal pattern, which corresponds (not an true isomorphism, but still) to the &ldquo;structural patterns&rdquo; discovered and used by a cell biology.</p>
<h2 id="when-do-we-actually-need-all-this">When do we actually need all this?<a hidden class="anchor" aria-hidden="true" href="#when-do-we-actually-need-all-this">#</a></h2>
<p>When the code is necessary of a different kind (IO, async, at least) an explicit and <em>actually impenetrable</em> abstraction barrier (a partition) is necessary. It is that simple - the same language but the different kinds of code &ndash; an abstraction barrier must be established.</p>
<p>It is way better to let the compiler to reinforce this abstraction barrier, insted of trying to always keep it in the mind.</p>
<p>This approach solves the problem of how you accessing the async code &ndash; you don&rsquo;t. You just write declaratively what has to be done (eventually) behind this abstraction barrier (at runtime), and thus naturally &ldquo;push it onto the outer edges&rdquo;. This is the right way.</p>
<p>Why this is so difficult to grasp? Because there are two confusing views &ndash; from inside of a cell membrane and from outside of a cell membrane, and one has to clearly understand which is which.</p>
<p>The underlying abstractions, such as <em>Functor</em>, do not have such a distinction (crated only by the mind of an external observer).</p>
<p>Again, we just have to <em>systematically compose declarative maps (via implicit nesting) to be eventually evaluated behind an abstraction barrier</em> (which will never be actually &ldquo;seen&rdquo; from the level of the code).</p>
<p>To realize this is to analytically solve the most of the hardest problems in so-called &ldquo;structured system design&rdquo; &ndash; the things the babble about on YouTube.</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://lngnmn2.github.io/tags/adt/">ADT</a></li>
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2024 <a href="https://lngnmn2.github.io/">Notes from the digital underground by Lngnmn</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
