<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>DeepMind and OpenAI win Gold | Notes from the digital underground by Lngnmn</title>
<meta name="keywords" content="LLM, AI, emacs, vi">
<meta name="description" content="Look, ma, another day another bullshit.">
<meta name="author" content="lngnmn2@yahoo.com">
<link rel="canonical" href="https://lngnmn2.github.io/articles/deepmind-and-openai-win-gold/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.8fe10233a706bc87f2e08b3cf97b8bd4c0a80f10675a143675d59212121037c0.css" integrity="sha256-j&#43;ECM6cGvIfy4Is8&#43;XuL1MCoDxBnWhQ2ddWSEhIQN8A=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://lngnmn2.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://lngnmn2.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://lngnmn2.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://lngnmn2.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://lngnmn2.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://lngnmn2.github.io/articles/deepmind-and-openai-win-gold/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Source+Code+Pro:wght@300&display=swap" rel="stylesheet">
<link href="https://fonts.googleapis.com/css2?family=Noto+Sans:wght@300&display=swap" rel="stylesheet">
<link href="https://fonts.googleapis.com/css2?family=Noto+Serif:wght@300&display=swap" rel="stylesheet">
<style>
font-family: 'Noto Serif', serif;
font-family: 'Noto Sans', sans-serif;
font-family: 'Source Code Pro', monospace;
</style>
<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script type="text/javascript" id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script><meta property="og:url" content="https://lngnmn2.github.io/articles/deepmind-and-openai-win-gold/">
  <meta property="og:site_name" content="Notes from the digital underground by Lngnmn">
  <meta property="og:title" content="DeepMind and OpenAI win Gold">
  <meta property="og:description" content="Look, ma, another day another bullshit.">
  <meta property="og:locale" content="en-us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="articles">
    <meta property="article:published_time" content="2025-09-18T00:00:00+05:45">
    <meta property="article:modified_time" content="2025-09-18T14:28:53+05:45">
    <meta property="article:tag" content="LLM">
    <meta property="article:tag" content="AI">
    <meta property="article:tag" content="Emacs">
    <meta property="article:tag" content="Vi">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="DeepMind and OpenAI win Gold">
<meta name="twitter:description" content="Look, ma, another day another bullshit.">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Articles",
      "item": "https://lngnmn2.github.io/articles/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "DeepMind and OpenAI win Gold",
      "item": "https://lngnmn2.github.io/articles/deepmind-and-openai-win-gold/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "DeepMind and OpenAI win Gold",
  "name": "DeepMind and OpenAI win Gold",
  "description": "Look, ma, another day another bullshit.",
  "keywords": [
    "LLM", "AI", "emacs", "vi"
  ],
  "articleBody": "Oh, look\nDeepMind and OpenAI win gold at ICPC (codeforces.com)\nSo, a model memorized a lot more of a convoluted stuff and been able to spit out a coherent code.\nWhile this is absolutely amazing considering that it works at the level of syntax, and that its “representation” captures only “possible relations among tokens” and posses no “understanding”, thinking leave alone reasoning capacities whatsoever. It just picks up one of the few next most probable tokens, given the previous “context” (a sequence of tokens “so far”).\nPerhaps they throw a bunch of seemingly relevant tokens in the “context window”, as they do nowadays by loading verbiage from web pages – I do not follow these developments.\nThose results, however, have nothing to do with programming excellency, no mater how it could appear to normies, how it can be framed and presented to them.\nThe very same model will fail miserably at a real programming task (as they fail at some of my “sophisticated” prompts).\nHere is something to consider. We have a very few amazing, wonderful, profound [insert more adjectives here] emerged traditions, usually centered around some deep realization or discovery (LISP, ML, Erlang, and so on).\nThere are another two “great traditions” absolutely worth knowing, understanding, preserving and improving:\nGNU Emacs Vi (Vim/Neovim) The beauty of the original Vi editor and some of its ancestors comes from the “deep realization” that a text and especially structured text, and a programming code, which is just a structured text, has a common underlying structure (which can be reduced to “nested DAGs”, just like almost everything else) and that this common underlying structure can be systematically observed, navigated, extended and modified (transformed).\nIntuitively it has been understood that what we call BNF (a simple formalism), and what we call Regular Expressions (an advanced formal system) capture the same universal notions and that there are a correspondence between these and Vi’s “editing abstractions” over structured text. This is what the corresponding “tradition” centered around.\nThe implementations, however, are messy and crappy, because way to many [good] people throw low effort solutions into them, which then has to be [rightfully] preserved. Some “technical debt” has been adressed, like replacing absolutely crappy vimscript with a decent language, while keeping all the old useful scripts running, by preserving the execution engine.\nThe real task would be to carefully re-design and re-implement very clearly, with a super-human attention to details and reduction to the most essential and properly generalized concepts (which would be, again, just “nested DAGS”) the “base ADTs and Layers of proper abstractions \" for a structured unicode encoded text, and to add the old “engines” on top of them, so the old scripts in both vimscript and Lua would still run.\nThe same retrofit could be done for Emacs – clarifying and debloatig Emacs Lisp DSLs and Layers of abstractions, and rewriting all the UI code (which is already a humanly-impossible task).\nThe key point is that properly done layers of abstractions could reduce the code size and the complexity by an order of magnitude or two, just to the size comparable to the size of a mathematical model, which captures all the structural and functional relations of arbitrary nested structured and implicitly tagged sequences and directed graphs formed from these.\nEvery model in existence will not only fail these tasks, they would not be able to “grasp” what needs to be done and why, simply because no one told them that this can be done.\nAnd yes, there are “just right” representations and implementations for almost everything, because the underlying universal structures are simple and well-understood properly captured abstractions.\nThis is possible because mathematics itself is just a set of such properly captured abstractions (as “informally” defined ADTs) and the corresponding DSLs (particular notations).\nIt has been imperially demonstrated, that when a high-level language can be build around a proper data abstractions (PG’s Ark, MIT Scheme) the language can be small, expressive and high-level at the same time.\nIt has been shown that focusing on proper abstraction barriers can lead to smaller, decomposable, layered complex systems (MIT Scheme implementation, Erlang).\nAnother example of a small high-level language, built around a central abstraction (a table) is Lua, and Luajit, arguably, is an example of how a runtime can be small and less convoluted (while it can be definitely be less cryptic).\nGiven a proper high-level language, without a low-level type clutter, and, ideally, without such clutter at all (typeinference in Haskell), things can be orders of magnitude smaller. Sussman (the great Wizard) wrote Edwin (which is part of MIT Scheme) and it is some few hundred Kilobytes .\nSo, this is how.\nIn general, it was well-understood that having proper abstractions and staying at this level within the language and the DSLs will reduce the code size and complexity (SML/NJ Basis Library). The LIsp Machines and Smalltalk systems demonstrated, that this principle applies to the whole systems.\nIn summary, if there is anything AI could show us, is to rewrite from the ground up what has been discovered and realized to be “just right”, propetly captured. Usually, people who have at least intuitive understanding how this can be done have nether energy not motivation to do it, and most of people who can code simply have no understanding.\nIt has been understood that one should not build crappy imperative VMs, but build graphs out of expressions and use a Graph Reduction Abstract Machine to do computation. Can AI reimplement this part of Haskell cleatly, principle-guided, from the ground up, throwing away all the wrong decisions? No, it can’t.\nCan it re-implement from the ground up, using all the insights and emetgent syntactic and semantic forms and “constructs” of the Vi family of editors, in a proper table-centered highlevel language specially crafted for such partocular set of data structures? No, it can’t.\nHow about a much smaller and cleaner set of modules which export proper layers of ADTs “emergent” after almost 50 years of a “high-level” Lisp-based Emacs, including extraction and generalization of the best parts from org-mode, which is otherwise a mess, why no?\nSo, if they really want to show us something remarkable their “AI” can actually do, show us something like this – something that everyone could say “Ahhh”, something that approaches the pefection (or a fixed point) “when nothing more can be taken away or removed or improved”.\nMathematicians know that such “things” do exist, and that there are actually a lot of them. Good programmers know that “ideal” implementations do exist (early attests of LISP implementations, using universal “tagged values” and whole in-memory structures made out of those). There is a vast literature on interpretens and compilers, which show the limits of what is possible.\nOk, just write a decent Vi, or a better Lua, or a better Arc, or extract the proper ADTs and Layers of abstractions emerged after decades of vi and Emacs traditions and reimplement them in a small high-level languages, crafted around this particular layer of abstraction, just like Math itself.\nYes, yes, I know. But your “AI” is an utter crap then.\n",
  "wordCount" : "1187",
  "inLanguage": "en",
  "datePublished": "2025-09-18T00:00:00+05:45",
  "dateModified": "2025-09-18T14:28:53+05:45",
  "author":[{
    "@type": "Person",
    "name": "lngnmn2@yahoo.com"
  }],
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://lngnmn2.github.io/articles/deepmind-and-openai-win-gold/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Notes from the digital underground by Lngnmn",
    "logo": {
      "@type": "ImageObject",
      "url": "https://lngnmn2.github.io/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://lngnmn2.github.io/" accesskey="h" title="Notes from the digital underground by Lngnmn (Alt + H)">Notes from the digital underground by Lngnmn</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://lngnmn2.github.io/about/" title="About me.">
                    <span>About me.</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title entry-hint-parent">
      DeepMind and OpenAI win Gold
    </h1>
    <div class="post-description">
      Look, ma, another day another bullshit.
    </div>
    <div class="post-meta"><span title='2025-09-18 00:00:00 +0545 +0545'>September 18, 2025</span>&nbsp;·&nbsp;lngnmn2@yahoo.com

</div>
  </header> 
  <div class="post-content"><p>Oh, look</p>
<p><a href="https://codeforces.com/blog/entry/146536">DeepMind and OpenAI win gold at ICPC (codeforces.com)</a></p>
<p>So, a model memorized a lot more of a convoluted stuff and been able to spit out a coherent code.</p>
<p>While this is absolutely amazing considering that it works at the level of syntax, and that its &ldquo;representation&rdquo; captures only &ldquo;possible relations among tokens&rdquo; and posses no &ldquo;understanding&rdquo;, thinking leave alone reasoning capacities whatsoever. It just picks up one of the few next most probable tokens, given the previous &ldquo;context&rdquo; (a sequence of tokens &ldquo;so far&rdquo;).</p>
<p>Perhaps they throw a bunch of seemingly relevant tokens in the &ldquo;context window&rdquo;, as they do nowadays by loading verbiage from web pages &ndash; I do not follow these developments.</p>
<p>Those results, however, have nothing to do with programming excellency, no mater how it could <em>appear</em> to normies, how it can be <em>framed</em> and <em>presented</em> to them.</p>
<p>The very same model will fail miserably at a real programming task (as they fail at some of my &ldquo;sophisticated&rdquo; prompts).</p>
<p>Here is something to consider. We have a very few amazing, wonderful, profound [insert more adjectives here] emerged <em>traditions</em>, usually centered around some deep realization or discovery (LISP, ML, Erlang, and so on).</p>
<p>There are another two &ldquo;great traditions&rdquo; absolutely worth knowing, understanding, preserving and improving:</p>
<ul>
<li>GNU Emacs</li>
<li>Vi (Vim/Neovim)</li>
</ul>
<p>The <em>beauty</em> of the original <code>Vi</code> editor and some of its ancestors comes from the &ldquo;deep realization&rdquo; that a text and especially <em>structured</em> text, and a programming code, which is just a structured text, has a common underlying structure (which can be reduced to &ldquo;nested DAGs&rdquo;,  just like almost everything else) and that this common underlying structure can be <em>systematically</em> observed, navigated, extended and modified (transformed).</p>
<p>Intuitively it has been understood that what we call BNF (a simple formalism), and what we call Regular Expressions (an advanced formal system) capture the same universal notions and that there are a correspondence between these and Vi&rsquo;s &ldquo;editing abstractions&rdquo; over structured text. This is what the corresponding &ldquo;tradition&rdquo; centered around.</p>
<p>The implementations, however, are messy and crappy, because way to many [good] people throw low effort solutions into them, which then has to be [rightfully] preserved. Some &ldquo;technical debt&rdquo; has been adressed, like replacing absolutely crappy vimscript with a decent language, while keeping all the old useful scripts running, by preserving the execution engine.</p>
<p>The real task would be to carefully re-design and re-implement very clearly, with a super-human attention to details and reduction to the most essential and properly generalized concepts (which would be, again, just &ldquo;nested DAGS&rdquo;) the &ldquo;base ADTs and Layers of proper abstractions &quot; for a structured unicode encoded text, and to add the old &ldquo;engines&rdquo; on top of them, so the old scripts in both vimscript and Lua would still run.</p>
<p>The same retrofit could be done for Emacs &ndash; clarifying and debloatig Emacs Lisp DSLs and Layers of abstractions, and rewriting all the UI code (which is already a humanly-impossible task).</p>
<p>The key point is that properly done layers of abstractions could reduce the code size and the complexity by an order of magnitude or two, just to the size comparable to the size of a mathematical model, which captures  all the structural and functional relations of arbitrary nested structured and implicitly tagged sequences and directed graphs formed from these.</p>
<p>Every model in existence will not only fail these tasks, they would not be able to &ldquo;grasp&rdquo; what needs to be done and why, simply because no one told them that this can be done.</p>
<p>And yes, there are &ldquo;just right&rdquo; representations and implementations for almost everything, because the underlying universal structures  are simple and well-understood properly captured abstractions.</p>
<p>This is possible because mathematics itself is just a set of such properly captured abstractions (as &ldquo;informally&rdquo; defined ADTs)  and the corresponding DSLs  (particular notations).</p>
<p>It has been imperially demonstrated, that when a <em>high-level</em> language can be build around a proper data abstractions (PG&rsquo;s Ark, MIT Scheme) the language can be small, expressive and high-level at the same time.</p>
<p>It has been shown that focusing on proper abstraction barriers can lead to smaller, decomposable, layered  complex systems (MIT Scheme implementation, Erlang).</p>
<p>Another example of a small high-level language, built around a central abstraction (a table) is Lua, and Luajit, arguably, is an example of how a <em>runtime</em> can be small and less convoluted (while it can be definitely be less cryptic).</p>
<p>Given a proper high-level language, without a low-level type clutter, and, ideally, without such clutter at all (typeinference in Haskell), things can be orders of magnitude smaller. Sussman (the great Wizard)  wrote <code>Edwin</code> (which is part of MIT Scheme) and it is some few hundred <em>Kilobytes</em> .</p>
<p>So, this is how.</p>
<p>In general, it was well-understood that having  proper abstractions and staying at this level within the language and the DSLs will reduce the code size and complexity (SML/NJ Basis Library). The LIsp Machines and Smalltalk systems demonstrated, that this principle applies to the whole systems.</p>
<p>In summary, if there is anything AI could show us, is to rewrite from the ground up what has been discovered and realized to be &ldquo;just right&rdquo;, propetly captured. Usually, people who have at least intuitive understanding how this can be done have nether energy not motivation to do it, and most of people who can code simply have no understanding.</p>
<p>It has been understood that one should not build crappy imperative VMs, but build graphs out of expressions and use a Graph Reduction Abstract Machine to do computation. Can AI reimplement this part of Haskell cleatly, principle-guided, from the ground up, throwing away all the wrong decisions? No, it can&rsquo;t.</p>
<p>Can it re-implement from the ground up, using all the insights and emetgent syntactic and semantic forms and &ldquo;constructs&rdquo; of the  Vi family of editors, in a proper table-centered highlevel language specially crafted for such partocular set of data structures? No, it can&rsquo;t.</p>
<p>How about a much smaller and cleaner set of modules which export proper layers of ADTs &ldquo;emergent&rdquo; after almost 50 years of a &ldquo;high-level&rdquo; Lisp-based Emacs, including extraction and generalization of the best parts from <code>org-mode</code>, which is otherwise a mess,  why no?</p>
<p>So, if they really want to show us something remarkable their &ldquo;AI&rdquo; can actually do, show us something like this &ndash; something that everyone could say &ldquo;Ahhh&rdquo;, something that approaches the pefection (or a fixed point) &ldquo;when nothing more can be taken away or removed or improved&rdquo;.</p>
<p>Mathematicians know that such &ldquo;things&rdquo; do exist, and that there are actually a lot of them. Good programmers know that &ldquo;ideal&rdquo; implementations do exist (early attests of LISP implementations, using universal &ldquo;tagged values&rdquo; and whole in-memory structures made out of those). There is a vast literature on interpretens and compilers, which show the limits of what is possible.</p>
<p>Ok, just write a decent <code>Vi</code>, or a better <em>Lua</em>, or a better <em>Arc</em>, or extract the proper ADTs and Layers of abstractions emerged after decades of vi and Emacs traditions and reimplement them in a small high-level languages, crafted around this particular layer of abstraction, just like Math itself.</p>
<p>Yes, yes, I know. But your &ldquo;AI&rdquo; is an utter crap then.</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://lngnmn2.github.io/tags/llm/">LLM</a></li>
      <li><a href="https://lngnmn2.github.io/tags/ai/">AI</a></li>
      <li><a href="https://lngnmn2.github.io/tags/emacs/">Emacs</a></li>
      <li><a href="https://lngnmn2.github.io/tags/vi/">Vi</a></li>
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="https://lngnmn2.github.io/">Notes from the digital underground by Lngnmn</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
