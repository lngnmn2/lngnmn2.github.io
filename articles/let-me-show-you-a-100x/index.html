<!DOCTYPE html>
<html lang="en" dir="auto" data-theme="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Let me show you a 100x | Notes from the digital underground by Lngnmn</title>
<meta name="keywords" content="AI, LLM, f-lang">
<meta name="description" content="So, let me show you a 100x for a change. Biological time is running out, so I have to rush out less polished results, but still they are way above average.
What is an intuitive understanding (which can be traced all the way back to the early Upanishads)? It is brain&rsquo;s way to capture (and &ldquo;understand&rdquo;) an observed recurring commonality (a common pattern) without being able to know all the underlying details of how (and exactly why) the pattern emerge.">
<meta name="author" content="lngnmn2@yahoo.com">
<link rel="canonical" href="https://lngnmn2.github.io/articles/let-me-show-you-a-100x/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.a5781257de4197b8e3d54346acdf1dd55a9ba4cb91dcace192fc1baf228c08b5.css" integrity="sha256-pXgSV95Bl7jj1UNGrN8d1VqbpMuR3KzhkvwbryKMCLU=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://lngnmn2.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://lngnmn2.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://lngnmn2.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://lngnmn2.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://lngnmn2.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://lngnmn2.github.io/articles/let-me-show-you-a-100x/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
                color-scheme: dark;
            }

            .list {
                background: var(--theme);
            }

            .toc {
                background: var(--entry);
            }
        }

        @media (prefers-color-scheme: light) {
            .list::-webkit-scrollbar-thumb {
                border-color: var(--code-bg);
            }
        }

    </style>
</noscript>
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.querySelector("html").dataset.theme = 'dark';
    } else if (localStorage.getItem("pref-theme") === "light") {
       document.querySelector("html").dataset.theme = 'light';
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.querySelector("html").dataset.theme = 'dark';
    } else {
        document.querySelector("html").dataset.theme = 'light';
    }

</script><link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Source+Code+Pro:wght@300&display=swap" rel="stylesheet">
<link href="https://fonts.googleapis.com/css2?family=Noto+Sans:wght@300&display=swap" rel="stylesheet">
<link href="https://fonts.googleapis.com/css2?family=Noto+Serif:wght@300&display=swap" rel="stylesheet">
<style>
font-family: 'Noto Serif', serif;
font-family: 'Noto Sans', sans-serif;
font-family: 'Source Code Pro', monospace;
</style>
<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script type="text/javascript" id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script><meta property="og:url" content="https://lngnmn2.github.io/articles/let-me-show-you-a-100x/">
  <meta property="og:site_name" content="Notes from the digital underground by Lngnmn">
  <meta property="og:title" content="Let me show you a 100x">
  <meta property="og:description" content="So, let me show you a 100x for a change. Biological time is running out, so I have to rush out less polished results, but still they are way above average.
What is an intuitive understanding (which can be traced all the way back to the early Upanishads)? It is brain’s way to capture (and “understand”) an observed recurring commonality (a common pattern) without being able to know all the underlying details of how (and exactly why) the pattern emerge.">
  <meta property="og:locale" content="en-us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="articles">
    <meta property="article:published_time" content="2026-02-23T00:00:00+05:45">
    <meta property="article:modified_time" content="2026-02-23T14:44:05+05:45">
    <meta property="article:tag" content="AI">
    <meta property="article:tag" content="LLM">
    <meta property="article:tag" content="F-Lang">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Let me show you a 100x">
<meta name="twitter:description" content="So, let me show you a 100x for a change. Biological time is running out, so I have to rush out less polished results, but still they are way above average.
What is an intuitive understanding (which can be traced all the way back to the early Upanishads)? It is brain&rsquo;s way to capture (and &ldquo;understand&rdquo;) an observed recurring commonality (a common pattern) without being able to know all the underlying details of how (and exactly why) the pattern emerge.">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Articles",
      "item": "https://lngnmn2.github.io/articles/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Let me show you a 100x",
      "item": "https://lngnmn2.github.io/articles/let-me-show-you-a-100x/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Let me show you a 100x",
  "name": "Let me show you a 100x",
  "description": "So, let me show you a 100x for a change. Biological time is running out, so I have to rush out less polished results, but still they are way above average.\nWhat is an intuitive understanding (which can be traced all the way back to the early Upanishads)? It is brain\u0026rsquo;s way to capture (and \u0026ldquo;understand\u0026rdquo;) an observed recurring commonality (a common pattern) without being able to know all the underlying details of how (and exactly why) the pattern emerge.\n",
  "keywords": [
    "AI", "LLM", "f-lang"
  ],
  "articleBody": "So, let me show you a 100x for a change. Biological time is running out, so I have to rush out less polished results, but still they are way above average.\nWhat is an intuitive understanding (which can be traced all the way back to the early Upanishads)? It is brain’s way to capture (and “understand”) an observed recurring commonality (a common pattern) without being able to know all the underlying details of how (and exactly why) the pattern emerge.\nAn intuitive understanding is “cheap” (but very valuable when is correct – precisely why it has been evolved), because reconciling all the relevant details, without introducing abstract bullshit and not missing anything relevant is a daunting task, way beyond human mind capacity.\nSo, the “modern science” is working by just allowing everyone to publish their mostly wrong abstract bullshit, and the other people would select and reconcile the occasional, rare grains of truths. Think of a large flock of chickens running on a bare ground searching for maize seeds which sometimes are hidden in lumps of cow’s poo (I am not even kidding).\nI always wanted to reconcile (or at lest not lose by forgetting) the intuitions (or intuitive insights) I have got by reading a few rare good books on seemingly unrelated subjects. The task, however, was way larger to fit into my tiny, short “attention windows”. This is like running – you have to stop and restart, stop and restart.\nThe first insight was that thee is what is called duality (structural duality, to be precise) between a definition of a sum-type in say SML or Haskell and a function which consumes such type, defined by clauses, as in SML, Erlang or Haskell, and that this is the only right way to define a total functions out of a set of partial functions (which is what each individual clause is).\nAnother insight is that once we have GADTs (“indexed” or parameterised Sum-types) we define somethings that is called an Initial Algebra, and a function, defined by clauses, becomes a natural Interpreter.\nThis pattern is not arbitrary, of course. Natural (evolved or emerged) complexity tends to have a clear layered hierarchical structure (the fact observed by Simon back in the 70s), and each layer (of complexity) shall export its own pure-functional, declarative state-less abstract interface as an embedded DSL, where each layer strictly above it shall have an interpreter for the DLS form the layer strictly below it.\nThere can be different interpreters for the same “Initial Algebra”, and “composing interpreters” is the only way of proper composition (which is, of course, just nesting of function calls or transformations).\nIf you read some “obscure” Lecture notes on Cambridge Advanced Functional Programming course, you will find some such interpreters being actually implemented in Ocaml, but everything is still ugly, because Ocaml researches were not smart enough to keep the definition by clauses syntax, as in SML or Shen or Erlang (and use pattern-matching or the = function syntax instead.\nBut the syntax must be central to a good language,(hi, Dan Grossman) and [syntactic] elegance is not optional, because it gives or reinforces intuitive insights. Uniformity and resulting minimalism are also not optional.\nI had the intuitive understanding that “all we need” [is Lambda] (Brian Harvey, the great) are just a few elements of the traditional (evolved) mathematical notation for years – the | , -\u003e () =, were painted on the wall above my bed, but, of course, knowing something intuitively is not enough.\nI have accumulated a lot more of intuitive insights. That for all a syntax of Haskell is just (an isomorphic to) a definition of an anonymous Trait, and that Trait Bounds are proper such that clauses, which in turn are boolean expressions (or predicates) at a type-level (and that fucking Java or C++ classes are bullshit cmpared to this generality).\nThe untyped lambda calculus at the type-level of simply-typed lambda calculus is another obvious intuition. The System F Omega (+ linear logic) is an intuitive foundation of all programming (due to Curry Howard isomorphism and the uniersal structural patters (of a universal DAG) that it captures). I have a lot,\nSo I’ve unified and reconciled some of my intuitions: https://github.com/lngnmn2/f-lang by creating a language in which the syntax is at the centre, and it captures the underlying semantics with the proper traditional mathematical notation.\nWhat for? Well. there more intuitions, of course. Remember some funny guys who developed the ZIO library for Scala on Youtube (look, ma, I am so smart, I use the M-word!)? They definitely had some intuitive insights, based on frequently observed commonalities (or recurring patterns in the code and internet memes). Know what they were missed? The question: from where these reccurent patterns come from?\nThe Category Theory (and the wonderful Bartosz in his blog) had some answers for this question, but even he didn’t traced these patterns all the way back to the basic structural elements of a Universal DAG (which can structurally encode any computation). I did.\nEvery DAG is “just composition of forks, joins and steps”, so is every Algebraic Data Type (which is, of course, a direct consequence). The composition of morphsms in terms of a Category Theory is just composition of “steps”, and those compositions (of steps) sometimes form a commuting diagram, which tell one something about the properties these compositions have.\nAgain, none of these are arbitrary coincidences – they all capture the “parts of the very same Elephant” (poor, blind philosophers, and I am one of them, realizing that at least the Elephan is indeed one and the same, from which everything follows).\nThere is more. The basic structural elements are the only possible ones – they are the Universal building blocks of every form of complexity in the Universe, and the only universal way of capturing this is “arrows between dots”. Ok ok.\nSo, my F-lang is a language where the syntax (and the underlying semantics) directly capture the notion of “just dots between [directed] arrows” (to write composed “interpreters” over GADTs ,constrained by Traits and trait bounds).\nAs for languages, the theoretical block-chain clowns (hi, vitaliks), are still missing the fact that David Turner’s KRC language (and compilation to SKI combinators) is literally all they need. Just add gas to SKI. Okay, nevermind.\nLet’s get serious for a while.\nThere is the way to program, and it is, indeed, declarative, pure-functional over persistent (structural-sharing) immutable data structures (made out of proper Algebraic Data Types).\nThe key is to stay as high-level and as close to declarative Gentzen’s Natural Deduction (and the Sequent Calculus) as possible.\nOne declares an “Initial Algebras” (which is just a particular abstract structure) and how to interpret them, layer by layer, building up a structurally verified DAG, which has to be eventually executed by the mundane “imperative” language runtime, while we stay pure (and simple, all dressed in a spotless while) behind the monadic abstraction barriers. This is not just a pretentious idealism (as on fucking social media) it is the way to have absolute security of a pen-and-paper calculation by substitution of equals for equals at the Model and Business-Logic layers of abstraction.\nHere, probably, comes the Nested Interpreters and the miniKaren of Scheme (Racket) tradition, but I am not sure.\nWhat I am sure of is that at any abstraction boundary there shall be a pure-functional abstract stateless DSL (as a public interface), just like that Turtle (drawing) language, and a corresponding interpreter (an evaluator for a DSL, which is, ideally, is just a pure function), outputs of which shall be composed.\nTo make composition mathematically sound (not arbitrary) one shall not introduce any abstractions beyond those which are structurally forced (by the structure of the underlying DAG), which means, again, just | , -\u003e () =, (and juxtaposition!) where () stands for nesting, and thus the only way to define precedence (an order of evaluation), = stands for mathematical immutable bindings, and -\u003e stands for a lot of things, but ultimately if R then Q, which is not just Modus Ponens, but a Universal single-clause [partial] function, the notion originally captured by the Lambda application.\nThere is more, of course. Which an expressive enough type-system (as in my F-lang) the ideal of types being theorems and functions on them being proofs (witnesses) becomes a reality, as long as one sticks to the | -\u003e structural duality, which is, arguably, the most fundamental building block (corresponding, not coincidentally, to the Introduction and Eliminations rules).\nEven in Rust, the type-state pattern on a parameterised enum is, surprise! an ad-hoc encoding of proper GADTs, and pattern-matching expressions of those (when such an expression is the whole body of a function) is an interpreted (by definition).\nNow thinks of the individual enum-clauses being pure declarations of possible (and only) “actions”, and an interpreter that executes them, eventually, behind a monadic abstraction barrier, returning a “pure” result, and wallah, the IO Monad, the State Monad, the Reader Monad, and ultimately, Free Monads and Applicatives (one shouldn’t have their theoretical CS classes missed).\nOne more time – one not just build a nested expression, which can be “mechanically” evaluated by substitution, with a pen and a paper, instead one builds a universal DAG, which captures and represents this very process of evaluation (eventually, by someone else), while structurally proving (at the compile time) that this DAG is composed properly and will not fail to be evaluated in principle.\nHow? By composing larger structural elements into the very same “forks, joins and steps”, Introductions, Eliminations and Modus Ponens, by having an Interpreter for a pure DSL of the layer [of abstraction] strictly below.\nOk, let me show you something:\nforAll a where type Expr a = | Lit Int suchThat (a == Int) | Add (Expr Int, Expr Int) suchThat (a == Int) | IsZero (Expr Int) suchThat (a == Bool) | If (Expr Bool, Expr a, Expr a) -- Clause 1: (Lit Int) -\u003e Int let eval_lit = (Lit n) -\u003e n -- Clause 2: (Add) -\u003e Int let eval_add = (Add (l, r)) -\u003e (eval l) + (eval r) -- Clause 3: (IsZero) -\u003e Bool let eval_iszero = (IsZero e) -\u003e (eval e == 0) -- Clause 4: (If) -\u003e a let eval_if = (If (cond, t, f)) -\u003e | eval cond -\u003e eval t | otherwise -\u003e eval f let eval = eval_lit | eval_add | eval_iszero | eval_if -- or even better, as in SML, to capture that very structual duality let eval = | (Lit n) -\u003e n | (Add (l, r)) -\u003e (eval l) + (eval r) | (IsZero e) -\u003e (eval e == 0) | (If (cond, t, f)) -\u003e | eval cond -\u003e eval t | otherwise -\u003e eval f Notice how many (and which ones) structural elements are out there. There are the “emergent properties”:\nGADTs are indexed coproducts (disjoint unions indexed by a type parameter) a DSL is just a sum-type (GADT)m an interpreter is just a pure exhaustive pattern-matching expression Interpreters are the only lawful transformations (they are the unique homomorphisms out of the initial algebra / free structure) You can have many interpreters (pretty-printer, evaluator, optimizer, logger, HyperLiquid executor, simulator, type-checker, etc.) All interpreters automatically commute with each other because they are Natural Transformations Each layer exports a pure, stateless declarative DSL The layer above consumes that DSL exclusively via an interpreter The constructors of the GADT and the pattern-match arms of the interpreter are structural duals (introduction vs elimination) The entire stack forms a commuting diagram that never breaks — the universal DAG remains coherent at every level Nothing of the above is arbitrary or coincidental, due to the fact that the Elephant is, indeed. the one and the same. The Curry-Howard isomorphism is only the beginning.\n",
  "wordCount" : "1967",
  "inLanguage": "en",
  "datePublished": "2026-02-23T00:00:00+05:45",
  "dateModified": "2026-02-23T14:44:05+05:45",
  "author":[{
    "@type": "Person",
    "name": "lngnmn2@yahoo.com"
  }],
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://lngnmn2.github.io/articles/let-me-show-you-a-100x/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Notes from the digital underground by Lngnmn",
    "logo": {
      "@type": "ImageObject",
      "url": "https://lngnmn2.github.io/favicon.ico"
    }
  }
}
</script>
</head>
<body id="top">
    <header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://lngnmn2.github.io/" accesskey="h" title="Notes from the digital underground by Lngnmn (Alt + H)">Notes from the digital underground by Lngnmn</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://lngnmn2.github.io/about/" title="About me.">
                    <span>About me.</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title entry-hint-parent">
      Let me show you a 100x
    </h1>
    <div class="post-meta"><span title='2026-02-23 00:00:00 +0545 +0545'>February 23, 2026</span>&nbsp;·&nbsp;<span>lngnmn2@yahoo.com</span>

</div>
  </header> 
  <div class="post-content"><p>So, let me show you a <code>100x</code> for a change. Biological time is running out, so I have to rush out less polished results, but still they are <em>way</em> above average.</p>
<p>What is an intuitive understanding (which can be traced all the way back to the early Upanishads)? It is brain&rsquo;s way to capture (and &ldquo;understand&rdquo;) an observed recurring commonality (a common pattern) without being able to know all the underlying details of how (and exactly why) the pattern emerge.</p>
<p>An intuitive understanding is &ldquo;cheap&rdquo; (but very valuable when is correct &ndash; precisely why it has been evolved), because reconciling all the relevant details, without introducing abstract bullshit and  not missing anything relevant is a daunting task, <em>way beyond human mind capacity</em>.</p>
<p>So, the &ldquo;modern science&rdquo; is working by just allowing everyone to publish their mostly wrong abstract bullshit, and the other people would select and reconcile the occasional, rare grains of truths. Think of a large flock of chickens running on a bare ground searching for maize seeds which sometimes are hidden in lumps of cow&rsquo;s poo (I am not even kidding).</p>
<p>I always wanted to reconcile (or at lest not lose by forgetting) the intuitions (or intuitive insights) I have got by reading a few rare good books on seemingly unrelated subjects. The task, however, was way larger to fit into my tiny, short &ldquo;attention windows&rdquo;. This is like running &ndash; you have to stop and restart, stop and restart.</p>
<p>The first insight was that thee is what is called <em>duality</em> (structural duality, to be precise) between a definition of a <em>sum-type</em> in say SML or Haskell and a function which consumes such type, defined by clauses, as in SML, Erlang or Haskell, and that <em>this is the only right way</em> to define a total functions out of a set of partial functions (which is what each individual clause is).</p>
<p>Another insight is that once we have GADTs (&ldquo;indexed&rdquo; or parameterised Sum-types) we define somethings that is called an <em>Initial Algebra</em>, and a function, defined by clauses, becomes a natural <em>Interpreter</em>.</p>
<p>This pattern is not arbitrary, of course. Natural (evolved or emerged) complexity tends to have a clear layered hierarchical structure (the fact observed by Simon back in the 70s), and each layer (of complexity) shall export its own pure-functional, declarative state-less abstract interface as an embedded DSL, where each layer strictly above it shall have an <em>interpreter</em> for the DLS form the layer strictly below it.</p>
<p>There can be different interpreters for the same &ldquo;Initial Algebra&rdquo;, and &ldquo;composing interpreters&rdquo; is the only way of proper composition (which is, of course, just nesting of function calls or transformations).</p>
<p>If you read some &ldquo;obscure&rdquo; Lecture notes on Cambridge Advanced Functional Programming course, you will find some such interpreters being actually implemented in Ocaml, but everything is still ugly, because Ocaml researches were not smart enough to keep the definition by clauses syntax, as in SML or Shen or Erlang (and use pattern-matching or the <code>= function</code> syntax instead.</p>
<p>But the syntax must be central to a good language,(hi, Dan Grossman) and <em>[syntactic] elegance is not optional</em>, because it gives or reinforces intuitive insights. Uniformity and resulting minimalism are also not optional.</p>
<p>I had the intuitive understanding that &ldquo;all we need&rdquo; [is Lambda] (Brian Harvey, the great) are just a few elements of the traditional (evolved) mathematical notation for years &ndash; the <code>| , -&gt; () =</code>,  were painted on the wall above my bed, but, of course, knowing something intuitively is not enough.</p>
<p>I have accumulated a lot more of  intuitive insights. That <code>for all a</code> syntax of Haskell is just (an isomorphic to) a definition of an <em>anonymous Trait</em>, and that <em>Trait Bounds</em> are proper  <code>such that</code> clauses, which in turn are boolean expressions (or predicates) at a type-level (and that fucking Java or C++ classes are bullshit cmpared to this generality).</p>
<p>The untyped lambda calculus at the type-level of simply-typed lambda calculus is another obvious intuition. The System F Omega (+ linear logic) is an intuitive foundation of all programming (due to Curry Howard isomorphism and the uniersal structural patters (of a universal DAG) that <em>it captures</em>). I have a lot,</p>
<p>So I&rsquo;ve unified and reconciled some of my intuitions: <a href="https://github.com/lngnmn2/f-lang">https://github.com/lngnmn2/f-lang</a>  by creating a language in which the syntax is at the centre, and it captures the underlying semantics with the proper traditional mathematical notation.</p>
<p>What for? Well. there more intuitions, of course. Remember some funny guys who developed the ZIO library for Scala on Youtube (look, ma, I am so smart, I use the M-word!)? They definitely had some intuitive insights, based on frequently observed commonalities (or recurring patterns in the code and internet memes). Know what they were missed? The question: <em>from where these reccurent patterns come from</em>?</p>
<p>The Category Theory (and the wonderful Bartosz in his blog) had some answers for this question, but even he didn&rsquo;t traced these patterns all the way back to the basic structural elements of a Universal DAG (which can structurally encode any computation). I did.</p>
<p>Every DAG is &ldquo;just composition of forks, joins and steps&rdquo;, so is every Algebraic Data Type (which is, of course, a direct consequence). The composition of morphsms in terms of a Category Theory is just composition of &ldquo;steps&rdquo;, and those compositions (of steps) sometimes form a commuting diagram, which tell one something about the <em>properties</em> these compositions have.</p>
<p>Again, none of these are arbitrary coincidences &ndash; they all capture the &ldquo;parts of the very same Elephant&rdquo; (poor, blind philosophers, and I am one of them, realizing that at least the Elephan is indeed one and the same, from which everything follows).</p>
<p>There is more. The basic structural elements are <em>the only possible ones</em> &ndash; they are the Universal building blocks of every form of complexity in the Universe, and the only universal way of capturing this is &ldquo;arrows between dots&rdquo;. Ok ok.</p>
<p>So, my F-lang is a language where the syntax (and the underlying semantics) directly capture the notion of &ldquo;just dots between [directed] arrows&rdquo; (to write composed &ldquo;interpreters&rdquo; over GADTs ,constrained by Traits and trait bounds).</p>
<p>As for languages, the theoretical block-chain clowns (hi, vitaliks), are still missing the fact that David Turner&rsquo;s KRC language (and compilation to SKI combinators) is literally all they need. Just add gas to SKI. Okay, nevermind.</p>
<p>Let&rsquo;s get serious for a while.</p>
<p>There is <em>the</em> way to program, and it is, indeed, declarative, pure-functional over persistent (structural-sharing) immutable data structures (made out of proper Algebraic Data Types).</p>
<p>The key is to stay as high-level and as close to declarative Gentzen&rsquo;s Natural Deduction (and the Sequent Calculus) as possible.</p>
<p>One <em>declares</em> an &ldquo;Initial Algebras&rdquo; (which is just a particular abstract structure) and <em>how to interpret them</em>, layer by layer, building up a structurally verified DAG, which has to be <em>eventually</em> executed by the mundane &ldquo;imperative&rdquo; language runtime, while we stay pure (and simple, all dressed in a spotless while) behind the monadic abstraction barriers. This is not just a pretentious idealism (as on fucking social media) it is the way to have absolute security of a pen-and-paper calculation by substitution of equals for equals <em>at the Model and Business-Logic layers of abstraction</em>.</p>
<p>Here, probably, comes the Nested Interpreters and the miniKaren of Scheme (Racket) tradition, but I am not sure.</p>
<p>What I am sure of is that at any abstraction boundary there shall be a pure-functional abstract stateless DSL (as a public interface), just like that Turtle (drawing) language, and a corresponding interpreter (an evaluator for a DSL, which is, ideally, is just a pure function), outputs of which shall be composed.</p>
<p>To make composition mathematically sound (not arbitrary) one <em>shall not introduce any abstractions beyond those which are structurally forced (by the structure of the underlying DAG)</em>, which means, again, just <code>| , -&gt; () =</code>,  (and juxtaposition!) where <code>()</code> stands for nesting, and thus the only way to define precedence (an order of evaluation), <code>=</code> stands for mathematical immutable bindings, and <code>-&gt;</code> stands for a lot of things, but ultimately <strong>if R then Q</strong>, which is not just Modus Ponens, but a Universal single-clause [partial] function, the notion originally captured by the Lambda application.</p>
<p>There is more, of course. Which an expressive enough type-system (as in my F-lang) the ideal of types being theorems and functions on them being proofs (witnesses) becomes a reality, as long as one sticks to the <code>| -&gt;</code> structural duality, which is, arguably, <em>the</em> most fundamental building block (corresponding, not coincidentally, to the Introduction and Eliminations rules).</p>
<p>Even in Rust, the type-state pattern on a parameterised <code>enum</code> is, surprise! an ad-hoc encoding of proper GADTs, and pattern-matching expressions of those (when such an expression is the whole body of a function) is an interpreted (by definition).</p>
<p>Now thinks of the individual enum-clauses being <em>pure declarations of</em> possible (and only) &ldquo;actions&rdquo;, and an interpreter that executes them, eventually, behind a monadic abstraction barrier, returning a &ldquo;pure&rdquo; result, and wallah, the IO Monad, the State Monad, the Reader Monad, and ultimately, Free Monads and Applicatives (one shouldn&rsquo;t have their theoretical CS classes missed).</p>
<p>One more time &ndash; one not just build a nested expression, which can be &ldquo;mechanically&rdquo; evaluated by substitution, with a pen and a paper, instead one builds a universal DAG, which captures and represents this very process of evaluation (eventually, by someone else), while structurally proving (at the compile time) that this DAG is composed properly and will not fail to be evaluated in principle.</p>
<p>How? By composing larger structural elements into the very same &ldquo;forks, joins and steps&rdquo;, Introductions, Eliminations and Modus Ponens, by having an Interpreter for a pure DSL of the layer [of abstraction] strictly below.</p>
<p>Ok, let me show you something:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-haskell" data-lang="haskell"><span style="display:flex;"><span><span style="color:#a6e22e">forAll</span> a <span style="color:#66d9ef">where</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#66d9ef">Expr</span> a <span style="color:#f92672">=</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">|</span> <span style="color:#66d9ef">Lit</span> <span style="color:#66d9ef">Int</span>                      suchThat (a <span style="color:#f92672">==</span> <span style="color:#66d9ef">Int</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">|</span> <span style="color:#66d9ef">Add</span> (<span style="color:#66d9ef">Expr</span> <span style="color:#66d9ef">Int</span>, <span style="color:#66d9ef">Expr</span> <span style="color:#66d9ef">Int</span>)     suchThat (a <span style="color:#f92672">==</span> <span style="color:#66d9ef">Int</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">|</span> <span style="color:#66d9ef">IsZero</span> (<span style="color:#66d9ef">Expr</span> <span style="color:#66d9ef">Int</span>)            suchThat (a <span style="color:#f92672">==</span> <span style="color:#66d9ef">Bool</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">|</span> <span style="color:#66d9ef">If</span> (<span style="color:#66d9ef">Expr</span> <span style="color:#66d9ef">Bool</span>, <span style="color:#66d9ef">Expr</span> a, <span style="color:#66d9ef">Expr</span> a)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">-- Clause 1: (Lit Int) -&gt; Int</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> eval_lit <span style="color:#f92672">=</span> (<span style="color:#66d9ef">Lit</span> n) <span style="color:#f92672">-&gt;</span> n
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">-- Clause 2: (Add) -&gt; Int</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> eval_add <span style="color:#f92672">=</span> (<span style="color:#66d9ef">Add</span> (l, r)) <span style="color:#f92672">-&gt;</span> (eval l) <span style="color:#f92672">+</span> (eval r)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">-- Clause 3: (IsZero) -&gt; Bool</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> eval_iszero <span style="color:#f92672">=</span> (<span style="color:#66d9ef">IsZero</span> e) <span style="color:#f92672">-&gt;</span> (eval e <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">-- Clause 4: (If) -&gt; a</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> eval_if <span style="color:#f92672">=</span> (<span style="color:#66d9ef">If</span> (cond, t, f)) <span style="color:#f92672">-&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">|</span> eval cond <span style="color:#f92672">-&gt;</span> eval t
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">|</span> otherwise <span style="color:#f92672">-&gt;</span> eval f
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> eval <span style="color:#f92672">=</span> eval_lit <span style="color:#f92672">|</span> eval_add <span style="color:#f92672">|</span> eval_iszero <span style="color:#f92672">|</span> eval_if
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">-- or even better, as in SML, to capture that very structual duality</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> eval <span style="color:#f92672">=</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">|</span> (<span style="color:#66d9ef">Lit</span> n) <span style="color:#f92672">-&gt;</span> n
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">|</span> (<span style="color:#66d9ef">Add</span> (l, r)) <span style="color:#f92672">-&gt;</span> (eval l) <span style="color:#f92672">+</span> (eval r)
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">|</span> (<span style="color:#66d9ef">IsZero</span> e) <span style="color:#f92672">-&gt;</span> (eval e <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">|</span> (<span style="color:#66d9ef">If</span> (cond, t, f)) <span style="color:#f92672">-&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">|</span> eval cond <span style="color:#f92672">-&gt;</span> eval t
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">|</span> otherwise <span style="color:#f92672">-&gt;</span> eval f
</span></span></code></pre></div><p>Notice how many (and which ones) structural elements are out there. There are the &ldquo;emergent properties&rdquo;:</p>
<ul>
<li>GADTs are indexed coproducts (disjoint unions indexed by a type parameter)</li>
<li>a DSL is just a sum-type (GADT)m an interpreter is just a pure exhaustive pattern-matching expression</li>
<li>Interpreters are the only lawful transformations (they are the unique homomorphisms out of the initial algebra / free structure)</li>
<li>You can have many interpreters (pretty-printer, evaluator, optimizer, logger, HyperLiquid executor, simulator, type-checker, etc.)</li>
<li>All interpreters automatically commute with each other because they are Natural Transformations</li>
<li>Each layer exports a pure, stateless declarative DSL</li>
<li>The layer above consumes that DSL exclusively via an interpreter</li>
<li>The constructors of the GADT and the pattern-match arms of the interpreter are structural duals (introduction vs elimination)</li>
<li>The entire stack forms a commuting diagram that never breaks — the universal DAG remains coherent at every level</li>
</ul>
<p>Nothing of the above is arbitrary or coincidental, due to the fact that the Elephant is, indeed. the one and the same. The Curry-Howard isomorphism is only the beginning.</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://lngnmn2.github.io/tags/ai/">AI</a></li>
      <li><a href="https://lngnmn2.github.io/tags/llm/">LLM</a></li>
      <li><a href="https://lngnmn2.github.io/tags/f-lang/">F-Lang</a></li>
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2026 <a href="https://lngnmn2.github.io/">Notes from the digital underground by Lngnmn</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu');
    if (menu) {
        
        const scrollPosition = localStorage.getItem("menu-scroll-position");
        if (scrollPosition) {
            menu.scrollLeft = parseInt(scrollPosition, 10);
        }
        
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        const html = document.querySelector("html");
        if (html.dataset.theme === "dark") {
            html.dataset.theme = 'light';
            localStorage.setItem("pref-theme", 'light');
        } else {
            html.dataset.theme = 'dark';
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
