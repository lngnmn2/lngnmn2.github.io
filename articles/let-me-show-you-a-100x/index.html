<!DOCTYPE html>
<html lang="en" dir="auto" data-theme="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Let me show you a 100x | Notes from the digital underground by Lngnmn</title>
<meta name="keywords" content="AI, LLM, f-lang">
<meta name="description" content="So, let me show you a 100x for a change. Biological time is running out, so I have to rush out less polished results, but still they are way above average.
What is an intuitive understanding (which can be traced all the way back to the early Upanishads)? It is brain&rsquo;s way to capture (and &ldquo;understand&rdquo;) an observed recurring commonality (a common pattern) without being able to know all the underlying details of how (and exactly why) the pattern emerge.">
<meta name="author" content="lngnmn2@yahoo.com">
<link rel="canonical" href="https://lngnmn2.github.io/articles/let-me-show-you-a-100x/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.a5781257de4197b8e3d54346acdf1dd55a9ba4cb91dcace192fc1baf228c08b5.css" integrity="sha256-pXgSV95Bl7jj1UNGrN8d1VqbpMuR3KzhkvwbryKMCLU=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://lngnmn2.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://lngnmn2.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://lngnmn2.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://lngnmn2.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://lngnmn2.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://lngnmn2.github.io/articles/let-me-show-you-a-100x/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
                color-scheme: dark;
            }

            .list {
                background: var(--theme);
            }

            .toc {
                background: var(--entry);
            }
        }

        @media (prefers-color-scheme: light) {
            .list::-webkit-scrollbar-thumb {
                border-color: var(--code-bg);
            }
        }

    </style>
</noscript>
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.querySelector("html").dataset.theme = 'dark';
    } else if (localStorage.getItem("pref-theme") === "light") {
       document.querySelector("html").dataset.theme = 'light';
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.querySelector("html").dataset.theme = 'dark';
    } else {
        document.querySelector("html").dataset.theme = 'light';
    }

</script><link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Source+Code+Pro:wght@300&display=swap" rel="stylesheet">
<link href="https://fonts.googleapis.com/css2?family=Noto+Sans:wght@300&display=swap" rel="stylesheet">
<link href="https://fonts.googleapis.com/css2?family=Noto+Serif:wght@300&display=swap" rel="stylesheet">
<style>
font-family: 'Noto Serif', serif;
font-family: 'Noto Sans', sans-serif;
font-family: 'Source Code Pro', monospace;
</style>
<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script type="text/javascript" id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script><meta property="og:url" content="https://lngnmn2.github.io/articles/let-me-show-you-a-100x/">
  <meta property="og:site_name" content="Notes from the digital underground by Lngnmn">
  <meta property="og:title" content="Let me show you a 100x">
  <meta property="og:description" content="So, let me show you a 100x for a change. Biological time is running out, so I have to rush out less polished results, but still they are way above average.
What is an intuitive understanding (which can be traced all the way back to the early Upanishads)? It is brain’s way to capture (and “understand”) an observed recurring commonality (a common pattern) without being able to know all the underlying details of how (and exactly why) the pattern emerge.">
  <meta property="og:locale" content="en-us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="articles">
    <meta property="article:published_time" content="2026-02-23T00:00:00+05:45">
    <meta property="article:modified_time" content="2026-02-23T13:34:50+05:45">
    <meta property="article:tag" content="AI">
    <meta property="article:tag" content="LLM">
    <meta property="article:tag" content="F-Lang">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Let me show you a 100x">
<meta name="twitter:description" content="So, let me show you a 100x for a change. Biological time is running out, so I have to rush out less polished results, but still they are way above average.
What is an intuitive understanding (which can be traced all the way back to the early Upanishads)? It is brain&rsquo;s way to capture (and &ldquo;understand&rdquo;) an observed recurring commonality (a common pattern) without being able to know all the underlying details of how (and exactly why) the pattern emerge.">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Articles",
      "item": "https://lngnmn2.github.io/articles/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Let me show you a 100x",
      "item": "https://lngnmn2.github.io/articles/let-me-show-you-a-100x/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Let me show you a 100x",
  "name": "Let me show you a 100x",
  "description": "So, let me show you a 100x for a change. Biological time is running out, so I have to rush out less polished results, but still they are way above average.\nWhat is an intuitive understanding (which can be traced all the way back to the early Upanishads)? It is brain\u0026rsquo;s way to capture (and \u0026ldquo;understand\u0026rdquo;) an observed recurring commonality (a common pattern) without being able to know all the underlying details of how (and exactly why) the pattern emerge.\n",
  "keywords": [
    "AI", "LLM", "f-lang"
  ],
  "articleBody": "So, let me show you a 100x for a change. Biological time is running out, so I have to rush out less polished results, but still they are way above average.\nWhat is an intuitive understanding (which can be traced all the way back to the early Upanishads)? It is brain’s way to capture (and “understand”) an observed recurring commonality (a common pattern) without being able to know all the underlying details of how (and exactly why) the pattern emerge.\nAn intuitive understanding is “cheap” (but very valuable when is correct – precisely why it has been evolved), because reconciling all the relevant details, without introducing abstract bullshit and not missing anything relevant is a daunting task, way beyond human mind capacity.\nSo, the “modern science” is working by just allowing everyone to publish their mostly wrong abstract bullshit, and the other people would select and reconcile the occasional, rare grains of truths. Think of a large flock of chickens running on a bare ground searching for maize seeds which sometimes are hidden in lumps of cow’s poo (I am not even kidding).\nI always wanted to reconcile (or at lest not lose by forgetting) the intuitions (or intuitive insights) I have got by reading a few rare good books on seemingly unrelated subjects. The task, however, was way larger to fit into my tiny, short “attention windows”. This is like running – you have to stop and restart, stop and restart.\nThe first insight was that thee is what is called duality (structural duality, to be precise) between a definition of a sum-type in say SML or Haskell and a function which consumes such type, defined by clauses, as in SML, Erlang or Haskell, and that this is the only right way to define a total functions out of a set of partial functions (which is what each individual clause is).\nAnother insight is that once we have GADTs (“indexed” or parameterised Sum-types) we define somethings that is called an Initial Algebra, and a function, defined by clauses, becomes a natural Interpreter.\nThis pattern is not arbitrary, of course. Natural (evolved or emerged) complexity tends to have a clear layered hierarchical structure (the fact observed by Simon back in the 70s), and each layer (of complexity) shall export its own pure-functional, declarative state-less abstract interface as an embedded DSL, where each layer strictly above it shall have an interpreter for the DLS form the layer strictly below it.\nThere can be different interpreters for the same “Initial Algebra”, and “composing interpreters” is the only way of proper composition (which is, of course, just nesting of function calls or transformations).\nIf you read some “obscure” Lecture notes on Cambridge Advanced Functional Programming course, you will find some such interpreters being actually implemented in Ocaml, but everything is still ugly, because Ocaml researches were not smart enough to keep the definition by clauses syntax, as in SML or Shen or Erlang (and use pattern-matching or the = function syntax instead.\nBut the syntax must be central to a good language,(hi, Dan Grossman) and [syntactic] elegance is not optional, because it gives or reinforces intuitive insights. Uniformity and resulting minimalism are also not optional.\nI had the intuitive understanding that “all we need” [is Lambda] (Brian Harvey, the great) are just a few elements of the traditional (evolved) mathematical notation for years – the | , -\u003e () =, were painted on the wall above my bed, but, of course, knowing something intuitively is not enough.\nI have accumulated a lot more of intuitive insights. That for all a syntax of Haskell is just (an isomorphic to) a definition of an anonymous Trait, and that Trait Bounds are proper such that clauses, which in turn are boolean expressions (or predicates) at a type-level (and that fucking Java or C++ classes are bullshit cmpared to this generality).\nThe untyped lambda calculus at the type-level of simply-typed lambda calculus is another obvious intuition. The System F Omega (+ linear logic) is an intuitive foundation of all programming (due to Curry Howard isomorphism and the uniersal structural patters (of a universal DAG) that it captures). I have a lot,\nSo I’ve unified and reconciled some of my intuitions: https://github.com/lngnmn2/f-lang by creating a language in which the syntax is at the centre, and it captures the underlying semantics with the proper traditional mathematical notation.\nWhat for? Well. there more intuitions, of course. Remember some funny guys who developed the ZIO library for Scala on Youtube (look, ma, I am so smart, I use the M-word!)? They definitely had some intuitive insights, based on frequently observed commonalities (or recurring patterns in the code and internet memes). Know what they were missed? The question: from where these reccurent patterns come from?\nThe Category Theory (and the wonderful Bartosz in his blog) had some answers for this question, but even he didn’t traced these patterns all the way back to the basic structural elements of a Universal DAG (which can structurally encode any computation). I did.\nEvery DAG is “just composition of forks, joins and steps”, so is every Algebraic Data Type (which is, of course, a direct consequence). The composition of morphsms in terms of a Category Theory is just composition of “steps”, and those compositions (of steps) sometimes form a commuting diagram, which tell one something about the properties these compositions have.\nAgain, none of these are arbitrary coincidences – they all capture the “parts of the very same Elephant” (poor, blind philosophers, and I am one of them, realizing that at least the Elephan is indeed one and the same, from which everything follows).\nThere is more. The basic structural elements are the only possible ones – they are the Universal building blocks of every form of complexity in the Universe, and the only universal way of capturing this is “arrows between dots”. Ok ok.\n",
  "wordCount" : "979",
  "inLanguage": "en",
  "datePublished": "2026-02-23T00:00:00+05:45",
  "dateModified": "2026-02-23T13:34:50+05:45",
  "author":[{
    "@type": "Person",
    "name": "lngnmn2@yahoo.com"
  }],
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://lngnmn2.github.io/articles/let-me-show-you-a-100x/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Notes from the digital underground by Lngnmn",
    "logo": {
      "@type": "ImageObject",
      "url": "https://lngnmn2.github.io/favicon.ico"
    }
  }
}
</script>
</head>
<body id="top">
    <header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://lngnmn2.github.io/" accesskey="h" title="Notes from the digital underground by Lngnmn (Alt + H)">Notes from the digital underground by Lngnmn</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://lngnmn2.github.io/about/" title="About me.">
                    <span>About me.</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title entry-hint-parent">
      Let me show you a 100x
    </h1>
    <div class="post-meta"><span title='2026-02-23 00:00:00 +0545 +0545'>February 23, 2026</span>&nbsp;·&nbsp;<span>lngnmn2@yahoo.com</span>

</div>
  </header> 
  <div class="post-content"><p>So, let me show you a <code>100x</code> for a change. Biological time is running out, so I have to rush out less polished results, but still they are <em>way</em> above average.</p>
<p>What is an intuitive understanding (which can be traced all the way back to the early Upanishads)? It is brain&rsquo;s way to capture (and &ldquo;understand&rdquo;) an observed recurring commonality (a common pattern) without being able to know all the underlying details of how (and exactly why) the pattern emerge.</p>
<p>An intuitive understanding is &ldquo;cheap&rdquo; (but very valuable when is correct &ndash; precisely why it has been evolved), because reconciling all the relevant details, without introducing abstract bullshit and  not missing anything relevant is a daunting task, <em>way beyond human mind capacity</em>.</p>
<p>So, the &ldquo;modern science&rdquo; is working by just allowing everyone to publish their mostly wrong abstract bullshit, and the other people would select and reconcile the occasional, rare grains of truths. Think of a large flock of chickens running on a bare ground searching for maize seeds which sometimes are hidden in lumps of cow&rsquo;s poo (I am not even kidding).</p>
<p>I always wanted to reconcile (or at lest not lose by forgetting) the intuitions (or intuitive insights) I have got by reading a few rare good books on seemingly unrelated subjects. The task, however, was way larger to fit into my tiny, short &ldquo;attention windows&rdquo;. This is like running &ndash; you have to stop and restart, stop and restart.</p>
<p>The first insight was that thee is what is called <em>duality</em> (structural duality, to be precise) between a definition of a <em>sum-type</em> in say SML or Haskell and a function which consumes such type, defined by clauses, as in SML, Erlang or Haskell, and that <em>this is the only right way</em> to define a total functions out of a set of partial functions (which is what each individual clause is).</p>
<p>Another insight is that once we have GADTs (&ldquo;indexed&rdquo; or parameterised Sum-types) we define somethings that is called an <em>Initial Algebra</em>, and a function, defined by clauses, becomes a natural <em>Interpreter</em>.</p>
<p>This pattern is not arbitrary, of course. Natural (evolved or emerged) complexity tends to have a clear layered hierarchical structure (the fact observed by Simon back in the 70s), and each layer (of complexity) shall export its own pure-functional, declarative state-less abstract interface as an embedded DSL, where each layer strictly above it shall have an <em>interpreter</em> for the DLS form the layer strictly below it.</p>
<p>There can be different interpreters for the same &ldquo;Initial Algebra&rdquo;, and &ldquo;composing interpreters&rdquo; is the only way of proper composition (which is, of course, just nesting of function calls or transformations).</p>
<p>If you read some &ldquo;obscure&rdquo; Lecture notes on Cambridge Advanced Functional Programming course, you will find some such interpreters being actually implemented in Ocaml, but everything is still ugly, because Ocaml researches were not smart enough to keep the definition by clauses syntax, as in SML or Shen or Erlang (and use pattern-matching or the <code>= function</code> syntax instead.</p>
<p>But the syntax must be central to a good language,(hi, Dan Grossman) and <em>[syntactic] elegance is not optional</em>, because it gives or reinforces intuitive insights. Uniformity and resulting minimalism are also not optional.</p>
<p>I had the intuitive understanding that &ldquo;all we need&rdquo; [is Lambda] (Brian Harvey, the great) are just a few elements of the traditional (evolved) mathematical notation for years &ndash; the <code>| , -&gt; () =</code>,  were painted on the wall above my bed, but, of course, knowing something intuitively is not enough.</p>
<p>I have accumulated a lot more of  intuitive insights. That <code>for all a</code> syntax of Haskell is just (an isomorphic to) a definition of an <em>anonymous Trait</em>, and that <em>Trait Bounds</em> are proper  <code>such that</code> clauses, which in turn are boolean expressions (or predicates) at a type-level (and that fucking Java or C++ classes are bullshit cmpared to this generality).</p>
<p>The untyped lambda calculus at the type-level of simply-typed lambda calculus is another obvious intuition. The System F Omega (+ linear logic) is an intuitive foundation of all programming (due to Curry Howard isomorphism and the uniersal structural patters (of a universal DAG) that <em>it captures</em>). I have a lot,</p>
<p>So I&rsquo;ve unified and reconciled some of my intuitions: <a href="https://github.com/lngnmn2/f-lang">https://github.com/lngnmn2/f-lang</a>  by creating a language in which the syntax is at the centre, and it captures the underlying semantics with the proper traditional mathematical notation.</p>
<p>What for? Well. there more intuitions, of course. Remember some funny guys who developed the ZIO library for Scala on Youtube (look, ma, I am so smart, I use the M-word!)? They definitely had some intuitive insights, based on frequently observed commonalities (or recurring patterns in the code and internet memes). Know what they were missed? The question: <em>from where these reccurent patterns come from</em>?</p>
<p>The Category Theory (and the wonderful Bartosz in his blog) had some answers for this question, but even he didn&rsquo;t traced these patterns all the way back to the basic structural elements of a Universal DAG (which can structurally encode any computation). I did.</p>
<p>Every DAG is &ldquo;just composition of forks, joins and steps&rdquo;, so is every Algebraic Data Type (which is, of course, a direct consequence). The composition of morphsms in terms of a Category Theory is just composition of &ldquo;steps&rdquo;, and those compositions (of steps) sometimes form a commuting diagram, which tell one something about the <em>properties</em> these compositions have.</p>
<p>Again, none of these are arbitrary coincidences &ndash; they all capture the &ldquo;parts of the very same Elephant&rdquo; (poor, blind philosophers, and I am one of them, realizing that at least the Elephan is indeed one and the same, from which everything follows).</p>
<p>There is more. The basic structural elements are <em>the only possible ones</em> &ndash; they are the Universal building blocks of every form of complexity in the Universe, and the only universal way of capturing this is &ldquo;arrows between dots&rdquo;. Ok ok.</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://lngnmn2.github.io/tags/ai/">AI</a></li>
      <li><a href="https://lngnmn2.github.io/tags/llm/">LLM</a></li>
      <li><a href="https://lngnmn2.github.io/tags/f-lang/">F-Lang</a></li>
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2026 <a href="https://lngnmn2.github.io/">Notes from the digital underground by Lngnmn</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu');
    if (menu) {
        
        const scrollPosition = localStorage.getItem("menu-scroll-position");
        if (scrollPosition) {
            menu.scrollLeft = parseInt(scrollPosition, 10);
        }
        
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        const html = document.querySelector("html");
        if (html.dataset.theme === "dark") {
            html.dataset.theme = 'light';
            localStorage.setItem("pref-theme", 'light');
        } else {
            html.dataset.theme = 'dark';
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
