<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Why S and K are enough. | Notes from the digital underground by Lngnmn</title>
<meta name="keywords" content="foundations, combinators, semigroup, monoid">
<meta name="description" content="DESCRIPTION: Oops, I did it again.
The hack The word &ldquo;implies&rdquo; and corresponding arrows are grossly overloaded and have more than one subtle but distinct meanings.
We will read and interpret the &ldquo;arrows&rdquo; (and the word &ldquo;implies&rdquo;) from different formalisms differently (as an implication in terms of necessity and sufficiency and as a single discrete step of causality).
We will put the universal notion of an environment (and the corresponding Γ abstraction) from obscurity to the center.">
<meta name="author" content="&amp;lt;lngnmn2@yahoo.com&amp;gt;">
<link rel="canonical" href="https://lngnmn2.github.io/articles/sk/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.b609c58d5c11bb90b1a54e04005d74ad1ddf22165eb79f5533967e57df9c3b50.css" integrity="sha256-tgnFjVwRu5CxpU4EAF10rR3fIhZet59VM5Z&#43;V9&#43;cO1A=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://lngnmn2.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://lngnmn2.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://lngnmn2.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://lngnmn2.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://lngnmn2.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://lngnmn2.github.io/articles/sk/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Source+Code+Pro:wght@300&display=swap" rel="stylesheet">
<link href="https://fonts.googleapis.com/css2?family=Noto+Sans:wght@300&display=swap" rel="stylesheet">
<link href="https://fonts.googleapis.com/css2?family=Noto+Serif:wght@300&display=swap" rel="stylesheet">
<style>
font-family: 'Noto Serif', serif;
font-family: 'Noto Sans', sans-serif;
font-family: 'Source Code Pro', monospace;
</style>
<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script type="text/javascript" id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
  

<meta property="og:title" content="Why S and K are enough." />
<meta property="og:description" content="DESCRIPTION: Oops, I did it again.
The hack The word &ldquo;implies&rdquo; and corresponding arrows are grossly overloaded and have more than one subtle but distinct meanings.
We will read and interpret the &ldquo;arrows&rdquo; (and the word &ldquo;implies&rdquo;) from different formalisms differently (as an implication in terms of necessity and sufficiency and as a single discrete step of causality).
We will put the universal notion of an environment (and the corresponding Γ abstraction) from obscurity to the center." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://lngnmn2.github.io/articles/sk/" /><meta property="article:section" content="articles" />
<meta property="article:published_time" content="2023-08-05T00:00:00+05:45" />
<meta property="article:modified_time" content="2023-08-05T19:58:18+05:45" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Why S and K are enough."/>
<meta name="twitter:description" content="DESCRIPTION: Oops, I did it again.
The hack The word &ldquo;implies&rdquo; and corresponding arrows are grossly overloaded and have more than one subtle but distinct meanings.
We will read and interpret the &ldquo;arrows&rdquo; (and the word &ldquo;implies&rdquo;) from different formalisms differently (as an implication in terms of necessity and sufficiency and as a single discrete step of causality).
We will put the universal notion of an environment (and the corresponding Γ abstraction) from obscurity to the center."/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Articles",
      "item": "https://lngnmn2.github.io/articles/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Why S and K are enough.",
      "item": "https://lngnmn2.github.io/articles/sk/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Why S and K are enough.",
  "name": "Why S and K are enough.",
  "description": "DESCRIPTION: Oops, I did it again.\nThe hack The word \u0026ldquo;implies\u0026rdquo; and corresponding arrows are grossly overloaded and have more than one subtle but distinct meanings.\nWe will read and interpret the \u0026ldquo;arrows\u0026rdquo; (and the word \u0026ldquo;implies\u0026rdquo;) from different formalisms differently (as an implication in terms of necessity and sufficiency and as a single discrete step of causality).\nWe will put the universal notion of an environment (and the corresponding Γ abstraction) from obscurity to the center.",
  "keywords": [
    "foundations", "combinators", "semigroup", "monoid"
  ],
  "articleBody": "DESCRIPTION: Oops, I did it again.\nThe hack The word “implies” and corresponding arrows are grossly overloaded and have more than one subtle but distinct meanings.\nWe will read and interpret the “arrows” (and the word “implies”) from different formalisms differently (as an implication in terms of necessity and sufficiency and as a single discrete step of causality).\nWe will put the universal notion of an environment (and the corresponding Γ abstraction) from obscurity to the center.\nWe will threat “arrows” as paths of a /single step, and composition of functions (via nesting) as composition of arrows, or steps in longer paths (of causality).\nThe notion of currying corresponds to joins (when multiple arrows come together).\nThe notion of abstraction by parameterization (B. Liskov) is implicit in the notion of currying. We (and molecular biology) parameterize with whole discrete steps (arrows).\nSo, the world “implies” and the notion of an arrow is convoluted and overloaded, which causes a mess and a profound confusion. Once we sort the arrows out everything will “click”.\nIndeed, stating what causes what (necessary and sufficient for a “reaction” or a “transition”) in general is subtly different from describing (stating) individual steps of causality, at least for us - programmers, who are concerned with representations and implementations.\nThe “arrows” looks (are) the same in various related formalisms - different perspectives (views) of the same reality (mountain). They are trying to capture (aspects of) the same universal notions, after all.\nSome arrows out there are due to currying, which is implemented as (is) nesting and thus having an implicit particular ordering “under the hood”.\nCausality (the processes) are ordered, of course. The previous “results” or “stable intermediate forms” (including what is necessary and sufficient) has to be already present “out there” in the environment – in Γ or in the same locality.\nComposition as nesting captures another universal notion of a partitioned compartment - of a closure - of an enzyme or a whole cell.\nClosure is a more general notion, which includes a statement of fact while all the references to the elements of Γ has been “captured” (the meaning is set immutable). The biological parallels are also obvious.\nThe notion of an environment is required (necessary), just as Γ is required for any system of logic (which tries to capture the universal notions of What Is).\nSo, some arrows corresponds to the “mappings” or “transitions” of pure functions - nested “single steps” of causality, while others denote various meanings of an “implication”.\nFirst of all The “famous” (which literally makes me sick) “False implies anything” of the purists has only and only one meaning:\nThe false result (statement) does not affect the whole environment (the contents of Γ) or What Is. So the word implies has this (and only this) meaning in this context.\nLets settle this once and for all.\nS and K combinators (which are closed forms or closures) This is what we have\ns : ((A → (B → C)) → ((A → B) → (A → C)) This reads (in classic logic): A implies B implies C, implies A implies B, implies A implies C.\nThe another (denotatonal) reading is this: give me a function from a to b, and by already having a function from b to c, we will have a function from a to c.\nThis, is, of course, exactly corresponds to a partial application of curried functions, which is, again, a couple of universal notions being captured together.\nPartial application, obviously, corresponds to the universal notion of when not all what is necessary and sufficient is present in the particular locality - a partially filled enzyme, not meet required conditions of a reaction.\nSo, in the notation above we got the currying itself backwards – a function composition via nesting which is what currying is (how it is actually implemented, and this is the only possible way).\nAnd the “forward” reading is this: a presence of A implies presence of (B -\u003e C) (nested in a curried form) implies that, if there is a path (A -\u003e B), there is (already, always) a path from (A -\u003e C).\nThe\"if\" there is not just an artifact of the English language usage, it hints on necessity (and sufficiency) and of that everything must be present in the environment (in the same locality).\nConclusion on this one? We have captured the same universal notion within different formalisms, more than once at different levels (abstraction by parameterization).\nk : A → (B → A) This is a left-identity (for a curried function of arity 2 - a join of two arrows), so will eventually have a Monoid – the why S and K are enough.\nThe notion of a Simigroup captures jet another universal pattern (two arrows coming together and resulting in a “starting point of a the next arrow of the same kind”), and no, there is no identity elements or functions in What Is, but a lot of concatenations and “coming togethe”.\nKleisli arrows, by the way, are another proper “capturing” of the notion of “crossing an abstraction barrier” or just a single step with a structurally kind of a result. Anyway.\nS Lets do familiar (less confusing) renaming of the type-variables and the terms first\ns :: (a -\u003e b -\u003e c) -\u003e (a -\u003e b) -\u003e a -\u003e c s = \\f -\u003e \\g -\u003e \\h -\u003e f h (g h) We have removed the optional parenthesis due to the associativeness.\nWhat we see is a function composition of terms of different arity, which themselves (f) may be curried. So, yes, currying at different levels, or currying of currying.\nf :: a -\u003e b -\u003e c f = \\a -\u003e \\b -\u003e undefined g\ng :: a -\u003e b g = \\a -\u003e undefined h is of arity zero, which corresponds to a binding, so it should be named x\nh :: a h = undefined One more time - what we have there is a function composition. Not just that, but parameterized by a necessary “step”.\nTo see everything clearly we just have to partially apply s and examine the types. Eventually we will have just a -\u003e c, which everything already “present” (captured withing a closure).\nThis is a universal form. Enzymes are like that. Or mathematical or logical statements (intermediate results).\nK A curried function of arity 2.\nk :: a -\u003e b -\u003e a k = \\a -\u003e \\_ -\u003e a which discards its second argument and is an identity on the first (the left-identity)\nAn identity function is the most general in principle, so it takes functions (of any arity) as its arguments.\nIdentity could be seen as a constant term, which is the name k misleadingly suggests.\nThe usual reading of A → (B → A) in logic is: A implies [there is some] (B → A) [which justified it].\nWe could also read: [the presence of] A implies [there was some] (B \\rightarrow A) [which caused it].\nSometimes “implies” may have the meaning “causes”, which is subtly NOT the same as “necessary and sufficient”.\nThe “universal law” (which different formalisms are trying to capture) is that necessary and sufficient requirements must be present in the environment, in the same locality (or in Γ), so the Causality may advance another step (the Universe as a “runtime” evaluate another form).\nThis is the universal notion properly captured in logic. The Modus Ponens is another universal notion (of a single step of Causality).\nHere, however, the implementation of k, which discards b has very different meaning and reading.\nFirst, the type should be written as k :: a -\u003e (_ -\u003e a) and the meaning is: anything implies (or causes) a.\nLooks very much like the False implies everything purist’s bullshit.\nAnother, proper reading is: a is just there, or a just is (there is a) [regardless of ~b~].\nSo the arrow there is from (of) currying, not of an implication or of a single step (mapping).\nAnd the final reading is: given an a and also [any] b there is (still) an a (and b is /unrelated).\nThe notion of being unrelated is, of course, the most fundamental and “the most” universal. Most of events are unrelated (they all, of course, are related only in the unwinding of the causality - being the sub-processes of the same single Universe).\nIn short, the shape of the Universe is a directed /acyclic graph, and the joins are not the cyles (due to one direction “traffic”).\nForks are just abstract notions - they do not exist, only as hyipothetic potentialities - every “step” takes only one path and other “possibilities” do not exist, except for the mind of an external observer.\nThis is exactly why no conditionals are required. Just nesting of steps (composition) and “joins” (currying) are enough.\nThe splits (or forks) on a “graph” (if we “look back”) are caused by actual different outcomes, just exactly as in the Tree of Life every branch is caused by some particular mutation (event, outcome).\nAgain, “possibilities” and “potentials” are abstract notions of the mind and do not exist anywhere in the Universe. Only localities, processes (sequences of “steps”) and “events”.\nNow why is this particular form? Well, g is nested in f, which is the same notion as g is curried within f or that f is implicitly parameterized by g.\nOn the other hand, partial application reveals more general properties.\nJust as partially applied fmap yields a function on a containers, partially applied s (to a binary combinaror) first yields a function on an unary combinator, and then, partially applied again, yields a function on a value.\nk, of course, has to be partially applied to s.\nNotice that any partially applied combinator (a closure) yields another closure (so the whole thing is a Semigroup), which is “as good as s and k themselves”. The arities, of course, has to match up.\nThese stable intermediate forms are present in the local context (of the environment) and can be used freely. So s and k are not the only ones out there. This is why the Lambda Calculus has binding and the implicit environment, just as any formal system of logic.\nSo, the form of s is as it is because it can be partially applied (saturated) to yield intermediate results, which can be used freely.\nWhen s is partially applied to k, which a justification of k’s its existence, the resulting form is a special case – it acts as an left-identity inside of s, discarding the (g h). So, there is a Monoid lurking within.\nNow the whole thing has the same properties as the Natural Numbers under addition and all the other Monoids. What is the operation? The composition of individual steps (of arrows) via nesting, of course.\nNow try to realize what exactly we (actually the guys who have discovered the sufficiency of S and K) have just captured.\n",
  "wordCount" : "1828",
  "inLanguage": "en",
  "datePublished": "2023-08-05T00:00:00+05:45",
  "dateModified": "2023-08-05T19:58:18+05:45",
  "author":[{
    "@type": "Person",
    "name": "\u0026lt;lngnmn2@yahoo.com\u0026gt;"
  }],
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://lngnmn2.github.io/articles/sk/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Notes from the digital underground by Lngnmn",
    "logo": {
      "@type": "ImageObject",
      "url": "https://lngnmn2.github.io/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://lngnmn2.github.io/" accesskey="h" title="Notes from the digital underground by Lngnmn (Alt + H)">Notes from the digital underground by Lngnmn</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://lngnmn2.github.io/about/" title="About me.">
                    <span>About me.</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title entry-hint-parent">
      Why S and K are enough.
    </h1>
    <div class="post-meta"><span title='2023-08-05 00:00:00 +0545 +0545'>August 5, 2023</span>&nbsp;·&nbsp;&amp;lt;lngnmn2@yahoo.com&amp;gt;

</div>
  </header> 
  <div class="post-content"><p>DESCRIPTION: Oops, I did it again.</p>
<h2 id="the-hack">The hack<a hidden class="anchor" aria-hidden="true" href="#the-hack">#</a></h2>
<p>The word &ldquo;implies&rdquo; and corresponding arrows are grossly <em>overloaded</em> and have more than one subtle but distinct meanings.</p>
<p>We will read and interpret the &ldquo;arrows&rdquo; (and the word &ldquo;implies&rdquo;) from different formalisms differently (as an implication in terms of necessity and sufficiency and as a single discrete step of causality).</p>
<p>We will put the universal notion of an environment (and the corresponding Γ abstraction) from obscurity to the center.</p>
<p>We will threat &ldquo;arrows&rdquo; as <em>paths</em> of <em>a /single step</em>, and composition of functions (via <em>nesting</em>) as <em>composition of arrows</em>, or steps in longer paths (of causality).</p>
<p>The notion of currying corresponds to <em>joins</em> (when multiple arrows come together).</p>
<p>The notion of abstraction by parameterization (B. Liskov) is implicit in the notion of currying. We (and molecular biology) parameterize with whole discrete steps (arrows).</p>
<p>So, the world &ldquo;implies&rdquo; and the notion of an arrow is convoluted and overloaded, which causes a mess and a profound confusion. Once we sort the arrows out everything will &ldquo;click&rdquo;.</p>
<p>Indeed, stating what causes what (necessary and sufficient for a &ldquo;reaction&rdquo; or a &ldquo;transition&rdquo;) <em>in general</em> is subtly different from describing (stating) individual steps of causality, at least for us - programmers, who are concerned with representations and implementations.</p>
<p>The &ldquo;arrows&rdquo; looks (are) the same in various related formalisms - different perspectives (views) of the same reality (mountain). They are trying to capture (aspects of) the same universal notions, after all.</p>
<p>Some arrows out there are due to <em>currying</em>, which is implemented as (is) <em>nesting</em> and thus having an implicit particular <em>ordering</em> &ldquo;under the hood&rdquo;.</p>
<p><em>Causality (the processes) are ordered</em>, of course. The previous &ldquo;results&rdquo; or &ldquo;stable intermediate forms&rdquo; (including what is <em>necessary and sufficient</em>) has to be already present &ldquo;out there&rdquo; in the environment &ndash; in Γ or in the same <em>locality</em>.</p>
<p>Composition as nesting captures another universal notion of a partitioned compartment - of a closure - of an enzyme or a whole cell.</p>
<p>Closure is a more general notion, which includes a <em>statement of fact</em> while all the references to the elements of Γ has been &ldquo;captured&rdquo; (the meaning is set immutable). The biological parallels are also obvious.</p>
<p>The notion of an <em>environment</em> is required (necessary), just as Γ is required for any system of logic (which tries to capture the universal notions of <em>What Is</em>).</p>
<p>So, some arrows corresponds to the &ldquo;mappings&rdquo; or &ldquo;transitions&rdquo; of pure functions - <em>nested</em> &ldquo;single steps&rdquo; of causality, while others denote various meanings of an &ldquo;implication&rdquo;.</p>
<h2 id="first-of-all">First of all<a hidden class="anchor" aria-hidden="true" href="#first-of-all">#</a></h2>
<p>The &ldquo;famous&rdquo; (which literally makes me sick) &ldquo;False implies anything&rdquo; of the purists has only and only one meaning:</p>
<p>The false result (statement) does not affect the whole environment (the contents of Γ) or <em>What Is</em>. So the word <em>implies</em> has this (and only this) meaning in this context.</p>
<p>Lets settle this once and for all.</p>
<h2 id="s-and-k-combinators--which-are-closed-forms-or-closures">S and K combinators (which are closed forms or closures)<a hidden class="anchor" aria-hidden="true" href="#s-and-k-combinators--which-are-closed-forms-or-closures">#</a></h2>
<p>This is what we have</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>s : ((A → (B → C)) → ((A → B) → (A → C))
</span></span></code></pre></div><p>This reads (in classic logic): <em>A implies B implies C, implies A implies B, implies A implies C.</em></p>
<p>The another (denotatonal) reading is this: <em>give me a function from <code>a</code> to <code>b</code>, and by already having a function from <code>b</code> to <code>c</code>, we will have a function from <code>a</code> to <code>c</code>.</em></p>
<p>This, is, of course, exactly corresponds to a <em>partial application of curried functions</em>, which is, again, a couple of <em>universal notions</em> being captured together.</p>
<p>Partial application, obviously, corresponds to the universal notion of when not all what is <em>necessary and sufficient is present in the particular locality</em> - a partially filled enzyme, not meet required conditions of a reaction.</p>
<p>So, in the notation above we got the <em>currying</em> itself backwards &ndash; a function composition via nesting which is what currying <em>is</em> (how it is actually implemented, and this is the only possible way).</p>
<p>And the &ldquo;forward&rdquo; reading is this: a <em>presence of A implies presence of (B -&gt; C) (nested in a curried form)</em> implies that, if there is a path (A -&gt; B), there is (already, always) a <em>path</em> from (A -&gt; C).</p>
<p>The&quot;if&quot; there is not just an artifact of the English language usage, it hints on <em>necessity</em> (and sufficiency) and of that everything must be present in the environment (in the same locality).</p>
<p>Conclusion on this one? We have captured the same universal notion within different formalisms, more than once at different levels (abstraction by parameterization).</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>k : A → (B → A)
</span></span></code></pre></div><p>This is a <em>left-identity</em> (for a <em>curried function of arity 2 - a join of two arrows)</em>, so will eventually have a Monoid &ndash; <em>the why</em> <code>S</code> and <code>K</code> are enough.</p>
<p>The notion of a <em>Simigroup</em> captures jet another universal pattern (two arrows coming together and resulting in a &ldquo;starting point of a the next arrow of the same kind&rdquo;), and no, there is no identity elements or functions in <em>What Is</em>, but a lot of concatenations and &ldquo;coming togethe&rdquo;.</p>
<p>Kleisli arrows, by the way, are another proper &ldquo;capturing&rdquo; of the notion of &ldquo;crossing an abstraction barrier&rdquo; or just a single step with a structurally kind of a result. Anyway.</p>
<h2 id="s">S<a hidden class="anchor" aria-hidden="true" href="#s">#</a></h2>
<p>Lets do familiar (less confusing) renaming of the type-variables and the terms first</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-haskell" data-lang="haskell"><span style="display:flex;"><span><span style="color:#a6e22e">s</span> <span style="color:#f92672">::</span> (a <span style="color:#f92672">-&gt;</span> b <span style="color:#f92672">-&gt;</span> c) <span style="color:#f92672">-&gt;</span> (a <span style="color:#f92672">-&gt;</span> b) <span style="color:#f92672">-&gt;</span> a <span style="color:#f92672">-&gt;</span> c
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">s</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">\</span>f <span style="color:#f92672">-&gt;</span> <span style="color:#a6e22e">\</span>g <span style="color:#f92672">-&gt;</span> <span style="color:#a6e22e">\</span>h <span style="color:#f92672">-&gt;</span> f h (g h)
</span></span></code></pre></div><p>We have removed the optional parenthesis due to the <em>associativeness</em>.</p>
<p>What we see is a <em>function composition</em> of terms of different arity, which themselves (<code>f</code>) may be <em>curried</em>. So, yes, currying at different levels, or currying of currying.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-haskell" data-lang="haskell"><span style="display:flex;"><span><span style="color:#a6e22e">f</span> <span style="color:#f92672">::</span> a <span style="color:#f92672">-&gt;</span> b <span style="color:#f92672">-&gt;</span> c
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">f</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">\</span>a <span style="color:#f92672">-&gt;</span> <span style="color:#a6e22e">\</span>b <span style="color:#f92672">-&gt;</span> undefined
</span></span></code></pre></div><p><code>g</code></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-haskell" data-lang="haskell"><span style="display:flex;"><span><span style="color:#a6e22e">g</span> <span style="color:#f92672">::</span> a <span style="color:#f92672">-&gt;</span> b
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">g</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">\</span>a <span style="color:#f92672">-&gt;</span> undefined
</span></span></code></pre></div><p><code>h</code> is of arity zero, which corresponds to a <em>binding</em>, so it should be named <code>x</code></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-haskell" data-lang="haskell"><span style="display:flex;"><span><span style="color:#a6e22e">h</span> <span style="color:#f92672">::</span> a
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">h</span> <span style="color:#f92672">=</span> undefined
</span></span></code></pre></div><p>One more time - what we have there is a <em>function composition</em>. Not just that, but <em>parameterized</em> by a necessary &ldquo;step&rdquo;.</p>
<p>To see everything clearly we just have to partially apply <code>s</code> and examine the types. Eventually we will have just <code>a -&gt; c</code>, which everything already &ldquo;present&rdquo; (captured withing a <em>closure</em>).</p>
<p>This is a universal <em>form</em>. Enzymes are like that. Or mathematical or logical statements (intermediate results).</p>
<h2 id="k">K<a hidden class="anchor" aria-hidden="true" href="#k">#</a></h2>
<p>A <em>curried</em> function of arity 2.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-haskell" data-lang="haskell"><span style="display:flex;"><span><span style="color:#a6e22e">k</span> <span style="color:#f92672">::</span> a <span style="color:#f92672">-&gt;</span> b <span style="color:#f92672">-&gt;</span> a
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">k</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">\</span>a <span style="color:#f92672">-&gt;</span> <span style="color:#a6e22e">\</span><span style="color:#66d9ef">_</span> <span style="color:#f92672">-&gt;</span> a
</span></span></code></pre></div><p>which discards its second argument and is an <em>identity</em> on the first (the left-identity)</p>
<p>An identity function is the most general in principle, so it takes functions (of any arity) as its arguments.</p>
<p><em>Identity</em> could be seen as a <em>constant</em> term, which is the name <code>k</code> <em>misleadingly</em> suggests.</p>
<p>The usual reading of <code>A → (B → A)</code> in logic is:
<em>A implies [there is some] (B → A) [which justified it]</em>.</p>
<p>We could also read:
<em>[the presence of] <code>A</code> implies [there was some] <code>(B \rightarrow A)</code> [which caused it].</em></p>
<p>Sometimes &ldquo;implies&rdquo; may have the meaning &ldquo;causes&rdquo;, which is subtly NOT the same as &ldquo;necessary and sufficient&rdquo;.</p>
<p>The &ldquo;universal law&rdquo; (which different formalisms are trying to capture) is that necessary and sufficient <em>requirements</em> must be present in the environment, in the same locality (or in Γ), so the Causality may advance another step (the Universe as a &ldquo;runtime&rdquo; evaluate another form).</p>
<p>This is the <em>universal</em> notion properly captured in logic. The <em>Modus Ponens</em>
is another universal notion (of a single step of Causality).</p>
<p>Here, however, the implementation of <code>k</code>, which discards <code>b</code> has very different meaning and reading.</p>
<p>First, the type should be written as <code>k :: a -&gt; (_ -&gt; a)</code> and the meaning is:
<em>anything implies (or causes) <code>a</code>.</em></p>
<p>Looks very much like the <em>False implies everything</em> purist&rsquo;s bullshit.</p>
<p>Another, proper reading is: <code>a</code> is just there, or <code>a</code> just is (there is <code>a</code>) [regardless of ~b~].</p>
<p>So the arrow there is from (of) <em>currying</em>, not of an implication or of a single step (mapping).</p>
<p>And the final reading is:
<em>given an <code>a</code> and also [any] <code>b</code> there is (still) an <code>a</code> (and <code>b</code> is /unrelated)</em>.</p>
<p>The notion of being unrelated is, of course, the most fundamental and &ldquo;the most&rdquo; universal. Most of <em>events</em> are unrelated (they <em>all</em>, of course, are related only in the <em>unwinding</em> of the causality - being the sub-processes of the same single Universe).</p>
<p>In short, the shape of the Universe is a <em>directed /acyclic graph</em>, and the joins are not the cyles (due to one direction &ldquo;traffic&rdquo;).</p>
<p>Forks are just abstract notions - they do not exist, only as hyipothetic potentialities - every &ldquo;step&rdquo; takes only one <em>path</em> and other &ldquo;possibilities&rdquo; do not exist, except for the mind of an external observer.</p>
<p>This is exactly why no <em>conditionals</em> are required. Just nesting of steps (composition) and &ldquo;joins&rdquo; (currying) are enough.</p>
<p>The splits (or forks) on a &ldquo;graph&rdquo; (if we &ldquo;look back&rdquo;) are caused by actual different outcomes, just exactly as in the <em>Tree of Life</em> every branch is caused by some particular mutation (event, outcome).</p>
<p>Again, &ldquo;possibilities&rdquo; and &ldquo;potentials&rdquo; are abstract notions of the mind and do not exist anywhere in the Universe. Only localities, processes (sequences of &ldquo;steps&rdquo;) and &ldquo;events&rdquo;.</p>
<h2 id="now-why-is-this-particular-form">Now why is <em>this particular form</em>?<a hidden class="anchor" aria-hidden="true" href="#now-why-is-this-particular-form">#</a></h2>
<p>Well, <code>g</code> is nested in <code>f</code>, which is the same notion as <code>g</code> is curried within <code>f</code> or that <code>f</code> is implicitly parameterized by <code>g</code>.</p>
<p>On the other hand, <em>partial application</em> reveals more general <em>properties</em>.</p>
<p>Just as partially applied <code>fmap</code> yields a function on a containers, partially applied <code>s</code> (to a binary combinaror) first yields a function on an unary combinator, and then, partially applied again, yields a function on a <em>value</em>.</p>
<p><code>k</code>, of course, has to be partially applied to <code>s</code>.</p>
<p>Notice that any partially applied combinator (a closure) yields another <em>closure</em> (so the whole thing is a <em>Semigroup</em>), which is &ldquo;as good as <code>s</code> and <code>k</code> themselves&rdquo;. The arities, of course, has to match up.</p>
<p>These <em>stable intermediate forms</em> are present in the local context (of the environment) and can be used freely. So  <code>s</code> and <code>k</code> are <em>not the only ones</em> out there. This is why the <em>Lambda Calculus</em> has <em>binding</em> and <em>the implicit environment</em>, just as any formal system of logic.</p>
<p>So, the form of <code>s</code> is as it is because it can be <em>partially applied</em> (saturated) to yield intermediate results, which can be used freely.</p>
<p>When <code>s</code> is partially applied to <code>k</code>, which a justification of <code>k</code>&rsquo;s its existence, the <em>resulting form</em> is a special case &ndash; it acts as an <em>left-identity</em> inside of <code>s</code>, <em>discarding</em> the <code>(g h)</code>. So, there is a <em>Monoid</em> lurking within.</p>
<p>Now the whole thing has the same properties as the Natural Numbers under addition and all the other Monoids. What is the <em>operation</em>? The composition of individual steps (of arrows) via nesting, of course.</p>
<p>Now try to realize what exactly we (actually the guys who have discovered the sufficiency of <code>S</code> and <code>K</code>)  have just captured.</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://lngnmn2.github.io/tags/foundations/">Foundations</a></li>
      <li><a href="https://lngnmn2.github.io/tags/combinators/">Combinators</a></li>
      <li><a href="https://lngnmn2.github.io/tags/semigroup/">Semigroup</a></li>
      <li><a href="https://lngnmn2.github.io/tags/monoid/">Monoid</a></li>
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2024 <a href="https://lngnmn2.github.io/">Notes from the digital underground by Lngnmn</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
