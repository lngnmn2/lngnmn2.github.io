<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Foundations | Notes from the digital underground by Lngnmn</title>
<meta name="keywords" content="foundations, esoteric views">
<meta name="description" content="Stupid people would usually ask &ldquo;why do we need all this theoretical bullshit and abstracted theories&rdquo;?
The answer is, to have &ldquo;the right understanding&rdquo; and because of that to be able to do things &ldquo;just right&rdquo;.
&ldquo;Just right&rdquo; has many meanings and implications. Among other things it is that what has been &ldquo;done right&rdquo; (ideally &ndash; a local optimum) does not require any further modifications.
It was indeed &ldquo;done&rdquo; (right). There is nothing more to remove (or alter).">
<meta name="author" content="&lt;lngnmn2@yahoo.com&gt;">
<link rel="canonical" href="https://lngnmn2.github.io/articles/foundations/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.3613efbd0b1772781e8f49935e973cae632a7f61471c05b17be155505ccf87b5.css" integrity="sha256-NhPvvQsXcngej0mTXpc8rmMqf2FHHAWxe&#43;FVUFzPh7U=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js" integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG&#43;9vmJ0cTS&#43;ovo0FeA="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://lngnmn2.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://lngnmn2.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://lngnmn2.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://lngnmn2.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://lngnmn2.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:title" content="Foundations" />
<meta property="og:description" content="Stupid people would usually ask &ldquo;why do we need all this theoretical bullshit and abstracted theories&rdquo;?
The answer is, to have &ldquo;the right understanding&rdquo; and because of that to be able to do things &ldquo;just right&rdquo;.
&ldquo;Just right&rdquo; has many meanings and implications. Among other things it is that what has been &ldquo;done right&rdquo; (ideally &ndash; a local optimum) does not require any further modifications.
It was indeed &ldquo;done&rdquo; (right). There is nothing more to remove (or alter)." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://lngnmn2.github.io/articles/foundations/" /><meta property="article:section" content="articles" />
<meta property="article:published_time" content="2023-07-18T00:00:00+05:45" />
<meta property="article:modified_time" content="2023-07-18T19:28:08+05:45" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Foundations"/>
<meta name="twitter:description" content="Stupid people would usually ask &ldquo;why do we need all this theoretical bullshit and abstracted theories&rdquo;?
The answer is, to have &ldquo;the right understanding&rdquo; and because of that to be able to do things &ldquo;just right&rdquo;.
&ldquo;Just right&rdquo; has many meanings and implications. Among other things it is that what has been &ldquo;done right&rdquo; (ideally &ndash; a local optimum) does not require any further modifications.
It was indeed &ldquo;done&rdquo; (right). There is nothing more to remove (or alter)."/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Articles",
      "item": "https://lngnmn2.github.io/articles/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Foundations",
      "item": "https://lngnmn2.github.io/articles/foundations/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Foundations",
  "name": "Foundations",
  "description": "Stupid people would usually ask \u0026ldquo;why do we need all this theoretical bullshit and abstracted theories\u0026rdquo;?\nThe answer is, to have \u0026ldquo;the right understanding\u0026rdquo; and because of that to be able to do things \u0026ldquo;just right\u0026rdquo;.\n\u0026ldquo;Just right\u0026rdquo; has many meanings and implications. Among other things it is that what has been \u0026ldquo;done right\u0026rdquo; (ideally \u0026ndash; a local optimum) does not require any further modifications.\nIt was indeed \u0026ldquo;done\u0026rdquo; (right). There is nothing more to remove (or alter).",
  "keywords": [
    "foundations", "esoteric views"
  ],
  "articleBody": "Stupid people would usually ask “why do we need all this theoretical bullshit and abstracted theories”?\nThe answer is, to have “the right understanding” and because of that to be able to do things “just right”.\n“Just right” has many meanings and implications. Among other things it is that what has been “done right” (ideally – a local optimum) does not require any further modifications.\nIt was indeed “done” (right). There is nothing more to remove (or alter).\nTo do “the right” thing one has to understand the meaning, significance and all the implications of each and every step. Justification (reasons) for every single decision.\nThis is difficult, challening, time-consuming, costly and partially tedious and boring, but his is what a true craftmanship is, and craftmanship is part of an Art.\nWhat is not a craftmanship is just cheap, low-effort crap.\nJust a few properly generalzed abstractions The good news is that (it seems, at lest) there are just a few fundamental notions which underely everything.\nThere are ques for this. We have an infomed intuition, that there are just a few fundamental notions. There are some capured universal notions:\nthe universal notion of an environment (the Universe and its localities) the universal notion of a “distinct process” (a closure) the universal notion of AND also (being present in the same locality) the universal notion of OR else (possible distinct outcomes) the universal notion of -\u003e a single distinct step (of a /process) the universal notion of an abstraction barrier (atoms, cells) the universal notion of a partition or a “cell membrane” (an interface) the universal notion of nesting (which gives us structure and composition) The ques are:\nthe Lambda Calculus has just 3 terms (and an implicit environment) the Algorithm Charting Technique captured just 3 universal patterns there are just 3 Algebraic Data Types (corrsponds to captured universal notions) the “building blocks” of the BNF meta-syntax notation. etc. Notice that thre are only 3 universal /notions for any /two values, which we usually denote as:\n, | -\u003e and suddenly the logical conjunction, disjunction and implication fell into its “proper” places and everything “clicked”. These notions, of course, also have been captured as Algebraic Data Types at a “higher level”. The notion of “and” as “putting together” with addition – 2 and 2 is 4, “or” as a disjoint union, etc.\nAn arrow stands for an anonymous function or a mapping (the “maps to” notation).\nAt the level of types it is, no surprise, a type-level “function”, an infix type-constructor which takes other types and produces a specialized function type (for a whole family of functions).\nMathematicians also captured recurrent pattens that emerge at the level of mathematical abstractions with some so-called “higer level abstractions”:\nSemigroup Monoid Functor Monad It is not a coincedence that Monad is a Monoid which is a Semigroup and that the Functor aspect is also present.\nThe Functor and the Monad aspects is how the universal notion of an absraction barrier has been parially captured.\nThe esoteric views Techincally, the pure lambda expression, when evaluatred, produce an applicable (or callable) lexical closure.\nThis is a direct analogy of how an “enzyme” is being built as a chain of folded proteins. Nothing is arbitrary here.\nThe pure lambda expression is the “genetic code” according to which a particular “enzyme” – an actual machine, a “mechanical molecular procedure” – is being built.\nThis is also not a coincedence that currying and a function composition (in a non-strict language) are “realized” through nesting of lambdas – a new closure – which nests the previous step and captures the parameter for it – is returned.\nNotice that a “loop” is just a conditional, of which one branch “returns” and another “loops” (or calls itself).\nMathematics, Logic and the Classic programming language have captured and generalized some of these universal notions and reccurent patterns, somethines without understanding of the significance.\nThe discovery of the Curry-Howard isomorphism was the “revelation” that, perhaps, we all are looking at the same “mountain” from differnt points of view (perspectives), which has been known since Upanishads.\nZooming through There is a profound implications of the fact that a “blind”, distributed, “macro-level” process of a biological evolution (in a particular locality which we call a planet) at the level of what we would call Molecular Biology “uses” or “acts according to” some universal notions, which result in a recurring (re-emerging) patterns.\nBoth the DNA and mRNA are an ordered sequences. So are aminacids and proteins. Both DNA and mRNA are particualar encodings, which are being read and interpreted (acted upon) by particular “physical enzymes”, which are just particularly folded chains of proteins with emergent unique electo-chemical properties.\n“Translations” from DNA to mRNA are pure /transformations (ideally, there should be no entropy, decay, cosmic rays or mutations, but paradoxically, it is only because of these Life Itself is possible and is out there). Procedures which implement pure functions (mappings between two Sets).\nThe pieces of mRNA are passed around “as an (ideally) immutable strucured values”, without any encapsulated state. All Molecular Biology, it seems, is stateless and non-strict (reactions happen at energy thresholds).\nBoth the “code” (enzymes) and the “data” are of the same linear strucure/. The early LISP guys have noticed, captured this and even paritally implemented this universal notion.\nThus, the “Same Input - Same Output. Always.” is a universal “meme” and this property (of a stable environment) is necessary (but not suffieient) for Life Itself.\nMathematics itsef (and functional programming) captured within (is based on) the universal notions of (idealized) immutability and persistence, pure transformations or mappings, Functions and Sets. It is not random coincidence that Functions and Sets are at the foundation of everything.\nLast but not least, the emergent “intellect of an external observer” has been able to observe, capture, properly generalize and abstract out commonalities and recurrent patterns which are “out there from the very beginning”.\nThere are the “causes” for these recurring pattenrs and commonalites to emerge, and these causes we would say are the properties of the Universe (a single unfolding process), which “runs” all the sub-processes within it.\nIt is absolutely required for a good programmer to be able to zoom throigh the layers of abstractions, from micro to macro to the universal and back.\nAll you need is Lambda There is a major singificance of the facts that “Lamda is the ultimate xxxx”\na “cell” of a function abstraction a “template of a process” an “enzyme” withing a “cell” (which at this level is a module that implements an ADT) has a “membrane” of its interface (its parameter and its return value) a closure (captures a “frame” of its environment) a thunk (a delayed evaluation and memoization) Lambda abstracts out (hides) the implementation and provides what we call a “black box abstraction”. The better way would be an “enzyme” abstraction.\nA lambda expression creates a manifestation (or incarnation) of a function, defined by a pure expression, which desctribes to an intepreter how to evaluate (or implement) the relation, which eventually can be applied to some actual value.\nThe use (of a lambda) – an application – is separated from creation of what will eventually be applied to a value. Appliation is a distinct term.\nAt a higer lavel\nADTs and corresponding modules are indeed univeral partitions (“horizontal”). Layered DSLs (which “communicate” only with the layer below) are “vertial” partitions. Abstraction by parameterization This is how one defines or implements a function.\nA function is a mathematical abstraction, which can be though as a mapping or a table between all the values from the Set calles domain to the Set called range. It could be the same Set.\nSo at a higher level we say \\[f: A \\rightarrow B\\].\nArrows This is a curried infix function.\n(+) :: a -\u003e a -\u003e a At this level we have implicit nested lambdas, because currying (in pseudocode) is this.\nlet (+) = \\x -\u003e \\y -\u003e (x + y) -- the second plus is a \"primitive\" and more generally, currying a function which takes a tuple of arguments is\ncurry :: ((a, b) -\u003e c) -\u003e a -\u003e b -\u003e c curry f = \\x -\u003e \\y -\u003e f (x, y) Here, in the code an arrow -\u003e stands for maps to lambda syntax. In the type signature it stands for nested lambdas. This is anothe curried infix function\n(.) :: (b -\u003e c) -\u003e (a -\u003e b) -\u003e a -\u003e c g (.) f = \\x -\u003e g (f x) Notice, again, that -\u003e at a type-level is realized through nesting of lambdas, and the arguments are also lamdas (are “arrows” themselves).\nAn interpreter Just as computer would mean a human being performig computations, an interpreter originally was also a human being. In order to perfom arithmetic or algerbraic computation a computer must also be an interpter of the mathematical notation.\nIntepretation, in turn, involves what we call evaluation (simplification or reduction), which is application of a fixed Set of well-defined rules.\nThe rules usually are defined as equations and the application of rules is a substitution of equal for equal, untill no more rules could be applied.\nWhen a person performing simple arithmetic or algebraic calculations “observes” (using what we call introspection) what he is actually doing, some “recurring patterns” will emerge.\nThis is where the substitution model of calculation or evaluation came from. It was generalized (discovered) not invented (as something which has no basis in actual reality).\nAn intepreter, thus, is a Universal Abstract Machine. Every electronic computer is an intepreter of its own “machine code”.\nThe Classic Languages The so-called Classic Languages has been based on and built upon the Simple Typed Lambda Calculus, by augmenting it with types, advanced type-systems and related syntactic sugar.\nThe Classic Languages are:\nCLU (unfortunately, an imperative language) Scheme ML Ocaml Miranda Haskell Coq Scala 3 CLU systematized and popularized the Abstract Data Types as the most fundamental building block of any software system, independent of a particular language being used.\nADTs are so fundamental that they can be traced to the mathematical definition of the most fundamental Set abstraction in terms of a set of operations. CLU emphasized ADTs and specifications.\nThe major fundamental result was the R5RS Standard, which is a culmination of evolution of Scheme. All the fundamental building blocks for a program for a (strong, dynamic-typed, strict language) has been well-understood and implemented. The MIT Scheme is the monument (the most famous landmark) of this tradition.\nAnother major tradition produced its own landmark monument – SML/NJ – an implementation of the statically-typed, mostly-functional strict programming language Standard ML.\nOcaml could be considered as a dialect (and a considerable refinement) of Standard ML.\nThese languages eventually “gave up” (so to speak) and introdiced mutation with special syntax, which broke the fundamental referential transparency property, from which everything good follows. Programmers usually write a pure functional “core” and then a layer which calls imperative procedures.\nHaskell managed to retain the crucial referential transparency property for all its code, so technically it is an advanced system of logic of its own. When one writes Haskell one writes a declarative pure logic.\nHaskell, thus, is the most pragmatic language. When one could formalize and define one’s problem domain in Haskell, the result will be not a running program, but an evolved mathematical formalism which describes the problem domain.\nThe conclusion is that all these languages have been built upon the same fundamental notions, which can be traced back to the Sample-Typed Lambda Calculus as the “core language” (or even the intermediate representation of the compiler, as in GHC), and even beyond.\nIt takes some education and knowledge to fully appreciate what Haskell and GHC really are.\n",
  "wordCount" : "1958",
  "inLanguage": "en",
  "datePublished": "2023-07-18T00:00:00+05:45",
  "dateModified": "2023-07-18T19:28:08+05:45",
  "author":[{
    "@type": "Person",
    "name": "\u0026lt;lngnmn2@yahoo.com\u0026gt;"
  }],
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://lngnmn2.github.io/articles/foundations/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Notes from the digital underground by Lngnmn",
    "logo": {
      "@type": "ImageObject",
      "url": "https://lngnmn2.github.io/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://lngnmn2.github.io/" accesskey="h" title="Notes from the digital underground by Lngnmn (Alt + H)">Notes from the digital underground by Lngnmn</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://lngnmn2.github.io/about/" title="About me.">
                    <span>About me.</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title">
      Foundations
    </h1>
    <div class="post-meta"><span title='2023-07-18 00:00:00 +0545 +0545'>July 18, 2023</span>&nbsp;·&nbsp;&lt;lngnmn2@yahoo.com&gt;

</div>
  </header> 
  <div class="post-content"><p>Stupid people would usually ask &ldquo;why do we need all this theoretical bullshit and abstracted theories&rdquo;?</p>
<p>The answer is, to have &ldquo;the right understanding&rdquo; and because of that to be able to do things &ldquo;just right&rdquo;.</p>
<p>&ldquo;Just right&rdquo; has many meanings and implications. Among other things it is that what has been &ldquo;done right&rdquo; (<em>ideally</em> &ndash; a local optimum) does not require any further modifications.</p>
<p>It was indeed &ldquo;done&rdquo; (right). There is nothing more to <em>remove</em> (or alter).</p>
<p>To do &ldquo;the right&rdquo; thing one has to understand the meaning, significance and <em>all the implications</em> of each and every step. Justification (reasons) for every single <em>decision</em>.</p>
<p>This is difficult, challening, time-consuming, costly and partially tedious and boring, but his is what a true <em>craftmanship</em> is, and <em>craftmanship is part of an Art</em>.</p>
<p>What is not a craftmanship is just cheap, low-effort crap.</p>
<h2 id="just-a-few-properly-generalzed-abstractions">Just a few properly generalzed abstractions<a hidden class="anchor" aria-hidden="true" href="#just-a-few-properly-generalzed-abstractions">#</a></h2>
<p>The good news is that (it seems, at lest) there are <em>just a few</em> fundamental notions which underely everything.</p>
<p>There are <em>ques</em> for this. We have an infomed <em>intuition</em>, that there are just a few fundamental notions.
There are some capured <em>universal notions</em>:</p>
<ul>
<li>the universal notion of an <em>environment</em> (the <em>Universe</em> and its <em>localities</em>)</li>
<li>the universal notion of a <em>&ldquo;distinct process&rdquo;</em> (a <em>closure</em>)</li>
<li>the universal notion of <code>AND also</code> (being <em>present</em> in the same <em>locality</em>)</li>
<li>the universal notion of <code>OR else</code> (<em>possible</em> distinct <em>outcomes</em>)</li>
<li>the universal notion of <code>-&gt;</code> a <em>single distinct step (of a /process</em>)</li>
<li>the universal notion of an <em>abstraction barrier</em> (atoms, cells)</li>
<li>the universal notion of a <em>partition</em> or a &ldquo;cell membrane&rdquo; (an <em>interface</em>)</li>
<li>the universal notion of <em>nesting</em> (which gives us structure and <em>composition</em>)</li>
</ul>
<p>The <em>ques</em> are:</p>
<ul>
<li>the Lambda Calculus has just 3 <em>terms</em> (and an implicit <em>environment</em>)</li>
<li>the Algorithm Charting Technique <em>captured</em> just 3 <em>universal patterns</em></li>
<li>there are just 3 <em>Algebraic Data Types</em> (corrsponds to captured universal notions)</li>
<li>the &ldquo;building blocks&rdquo; of the BNF <em>meta-syntax notation</em>.</li>
<li>etc.</li>
</ul>
<p>Notice that thre are <em>only <code>3</code> universal /notions for any /two</em> values, which we usually <em>denote</em> as:</p>
<ul>
<li><code>,</code></li>
<li><code>|</code></li>
<li><code>-&gt;</code></li>
</ul>
<p>and suddenly the logical <em>conjunction</em>, <em>disjunction</em> and <em>implication</em> fell into its &ldquo;proper&rdquo; places and everything &ldquo;clicked&rdquo;. These notions, of course, also have been captured as <em>Algebraic Data Types</em> at a &ldquo;higher level&rdquo;.
The notion of &ldquo;and&rdquo; as &ldquo;putting together&rdquo; with addition &ndash; <em>2 and 2 is 4</em>, &ldquo;or&rdquo; as a <em>disjoint union</em>, etc.</p>
<p>An <em>arrow</em> stands for an <em>anonymous function</em> or a <em>mapping</em> (the &ldquo;maps to&rdquo; notation).</p>
<p>At the level of types it is, no surprise, a type-level &ldquo;function&rdquo;, an <em>infix type-constructor</em> which takes other <em>types</em> and produces a <em>specialized function type (for a whole family of functions)</em>.</p>
<p>Mathematicians also captured <em>recurrent pattens that emerge at the level of mathematical abstractions</em> with  some so-called &ldquo;higer level abstractions&rdquo;:</p>
<ul>
<li>Semigroup</li>
<li>Monoid</li>
<li>Functor</li>
<li>Monad</li>
</ul>
<p>It is not a coincedence that <em>Monad is a Monoid which is a Semigroup</em> and that the <em>Functor aspect is also present</em>.</p>
<p>The <em>Functor</em> and the <em>Monad</em> aspects is how the <em>universal notion of an absraction barrier</em> has been <em>parially</em> captured.</p>
<h2 id="the-esoteric-views">The esoteric views<a hidden class="anchor" aria-hidden="true" href="#the-esoteric-views">#</a></h2>
<p>Techincally, the pure <em>lambda expression</em>, when evaluatred, produce an applicable (or callable) <em>lexical closure</em>.</p>
<p>This is a direct analogy of how an &ldquo;enzyme&rdquo; is being built as a chain of folded proteins. Nothing is arbitrary here.</p>
<p>The <em>pure lambda expression</em> is the &ldquo;genetic code&rdquo; according to which a particular &ldquo;enzyme&rdquo; &ndash; an actual <em>machine</em>, a &ldquo;mechanical molecular procedure&rdquo; &ndash; is being built.</p>
<p>This is also not a coincedence that <em>currying</em> and a function composition (in a non-strict language) are &ldquo;realized&rdquo; through <em>nesting of lambdas</em> &ndash; a new <em>closure</em> &ndash; <em>which nests the previous step and captures the parameter for it</em> &ndash;  is returned.</p>
<p>Notice that a &ldquo;loop&rdquo; is just a <em>conditional</em>, of which one branch &ldquo;returns&rdquo; and another &ldquo;loops&rdquo; (or calls itself).</p>
<p>Mathematics, Logic and the Classic programming language have <em>captured and generalized</em> some of these universal notions and reccurent patterns, somethines without understanding of the significance.</p>
<p>The discovery of the Curry-Howard isomorphism was the &ldquo;revelation&rdquo; that, perhaps, we all are looking at the same &ldquo;mountain&rdquo; from differnt points of view (perspectives), which has been known since <em>Upanishads</em>.</p>
<h3 id="zooming-through">Zooming through<a hidden class="anchor" aria-hidden="true" href="#zooming-through">#</a></h3>
<p>There is a profound implications of the fact that a &ldquo;blind&rdquo;, distributed, &ldquo;macro-level&rdquo; process of a biological evolution (in a particular <em>locality</em> which we call a planet) at the level of what we would call Molecular Biology &ldquo;uses&rdquo; or &ldquo;acts according to&rdquo; some universal notions, which result in a recurring (re-emerging) patterns.</p>
<p>Both the <code>DNA</code> and <code>mRNA</code> are an <em>ordered sequences</em>. So are <em>aminacids</em> and <em>proteins</em>. Both <code>DNA</code> and <code>mRNA</code> are particualar <em>encodings</em>, which are being <em>read</em> and <em>interpreted</em> (acted upon) by particular &ldquo;physical enzymes&rdquo;, which are just particularly folded chains of proteins with emergent unique electo-chemical properties.</p>
<p>&ldquo;<em>Translations&rdquo;</em> from <code>DNA</code> to <code>mRNA</code>  are <em>pure /transformations</em> (ideally, there should be no entropy, decay, cosmic rays or <em>mutations</em>, but paradoxically, it is only because of these Life Itself is possible and is out there). Procedures which implement <em>pure functions</em> (<em>mappings</em> between two Sets).</p>
<p>The pieces of <code>mRNA</code> are passed around &ldquo;as an (ideally) immutable <em>strucured values</em>&rdquo;, without any <em>encapsulated state</em>. All Molecular Biology, it seems, is <em>stateless</em> and <em>non-strict (reactions happen at energy thresholds)</em>.</p>
<p>Both the &ldquo;code&rdquo; (enzymes) and the &ldquo;data&rdquo; are of the same <em>linear strucure/</em>. The early LISP guys have noticed, captured this and even paritally <em>implemented</em> this universal notion.</p>
<p>Thus, the <em>&ldquo;Same Input - Same Output. Always.&rdquo;</em> is a universal &ldquo;<em>meme&rdquo;</em> and this <em>property</em> (of a <em>stable</em> environment) is <em>necessary</em> (but not suffieient) for <em>Life Itself</em>.</p>
<p>Mathematics itsef (and functional programming) captured within (is based on) the <em>universal notions</em> of (idealized) immutability and persistence, <em>pure transformations or mappings</em>, Functions and Sets. It is not random coincidence that <em>Functions</em> and <em>Sets</em> are at the foundation of everything.</p>
<p>Last but not least, the emergent &ldquo;intellect of an external observer&rdquo; has been able to observe, capture, properly generalize and abstract out commonalities and recurrent patterns which are &ldquo;out there from the very beginning&rdquo;.</p>
<p>There are the <em>&ldquo;causes&rdquo;</em> for these recurring pattenrs and commonalites to emerge, and these causes we would say are the properties of the Universe (a single unfolding <em>process</em>), which <em>&ldquo;runs&rdquo;</em> all the <em>sub-processes</em> within it.</p>
<p>It is absolutely <em>required</em> for a good programmer to be able to <em>zoom throigh</em> the layers of abstractions, from <em>micro</em> to <em>macro</em> to the universal and back.</p>
<h2 id="all-you-need-is-lambda">All you need is Lambda<a hidden class="anchor" aria-hidden="true" href="#all-you-need-is-lambda">#</a></h2>
<p>There is a major singificance of the facts that <em>&ldquo;Lamda is the ultimate xxxx&rdquo;</em></p>
<ul>
<li>a &ldquo;cell&rdquo; of a <em>function abstraction</em></li>
<li>a &ldquo;template of a process&rdquo;</li>
<li>an &ldquo;enzyme&rdquo; withing a &ldquo;cell&rdquo; (which at this level is a <em>module</em> that implements an <em>ADT</em>)</li>
<li>has a &ldquo;membrane&rdquo; of its interface (its <em>parameter</em> and its <em>return value</em>)</li>
<li>a closure (captures a &ldquo;frame&rdquo; of its environment)</li>
<li>a thunk (a <em>delayed</em> evaluation and <em>memoization</em>)</li>
</ul>
<p><em>Lambda</em> abstracts out (hides) the <em>implementation</em> and provides what we call a &ldquo;black box abstraction&rdquo;. The better way would be an &ldquo;enzyme&rdquo; abstraction.</p>
<p>A <em>lambda expression</em> creates a <em>manifestation</em> (or <em>incarnation</em>) of a function, <em>defined</em> by a <em>pure expression</em>, which <em>desctribes</em> to an intepreter how to evaluate (or implement) the <em>relation</em>, which <em>eventually</em> can be <em>applied</em> to some actual value.</p>
<p>The <em>use</em> (of a lambda) &ndash; an application &ndash;  is separated from creation of what will <em>eventually</em> be applied to a value. Appliation is a <em>distinct term</em>.</p>
<p>At a higer lavel</p>
<ul>
<li>ADTs and corresponding modules are indeed univeral <em>partitions</em> (&ldquo;horizontal&rdquo;).</li>
<li>Layered DSLs (which &ldquo;communicate&rdquo; <em>only with the layer below</em>) are &ldquo;vertial&rdquo; partitions.</li>
</ul>
<h2 id="abstraction-by-parameterization">Abstraction by parameterization<a hidden class="anchor" aria-hidden="true" href="#abstraction-by-parameterization">#</a></h2>
<p>This is how one <em>defines</em> or <em>implements</em> a function.</p>
<p>A function is a mathematical abstraction, which can be though as a mapping or a table between all the values from the Set calles <em>domain</em> to the Set called <em>range</em>. It could be the same Set.</p>
<p>So at a higher level we say \[f: A \rightarrow B\].</p>
<h2 id="arrows">Arrows<a hidden class="anchor" aria-hidden="true" href="#arrows">#</a></h2>
<p>This is a <em>curried</em> infix function.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-haskell" data-lang="haskell"><span style="display:flex;"><span> (<span style="color:#f92672">+</span>) <span style="color:#f92672">::</span> a <span style="color:#f92672">-&gt;</span> a <span style="color:#f92672">-&gt;</span> a
</span></span></code></pre></div><p>At this level we have <em>implicit</em> nested lambdas, because currying (<em>in pseudocode</em>) is this.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-haskell" data-lang="haskell"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> (<span style="color:#f92672">+</span>) <span style="color:#f92672">=</span> <span style="color:#a6e22e">\</span>x <span style="color:#f92672">-&gt;</span> <span style="color:#a6e22e">\</span>y <span style="color:#f92672">-&gt;</span> (x <span style="color:#f92672">+</span> y)   <span style="color:#75715e">-- the second plus is a &#34;primitive&#34;</span>
</span></span></code></pre></div><p>and more generally, currying a function which takes a <em>tuple</em> of arguments is</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-haskell" data-lang="haskell"><span style="display:flex;"><span><span style="color:#a6e22e">curry</span> <span style="color:#f92672">::</span> ((a, b) <span style="color:#f92672">-&gt;</span> c) <span style="color:#f92672">-&gt;</span> a <span style="color:#f92672">-&gt;</span> b <span style="color:#f92672">-&gt;</span> c
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">curry</span> f <span style="color:#f92672">=</span> <span style="color:#a6e22e">\</span>x <span style="color:#f92672">-&gt;</span> <span style="color:#a6e22e">\</span>y <span style="color:#f92672">-&gt;</span> f (x, y)
</span></span></code></pre></div><p>Here, in the code an arrow <code>-&gt;</code> stands for <em>maps to lambda syntax</em>. In the <em>type signature</em> it stands for <em>nested lambdas</em>.
This is anothe <em>curried</em> infix function</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-haskell" data-lang="haskell"><span style="display:flex;"><span>(<span style="color:#f92672">.</span>) <span style="color:#f92672">::</span> (b <span style="color:#f92672">-&gt;</span> c) <span style="color:#f92672">-&gt;</span> (a <span style="color:#f92672">-&gt;</span> b) <span style="color:#f92672">-&gt;</span> a <span style="color:#f92672">-&gt;</span> c
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">g</span> (<span style="color:#f92672">.</span>) f <span style="color:#f92672">=</span> <span style="color:#a6e22e">\</span>x <span style="color:#f92672">-&gt;</span> g (f x)
</span></span></code></pre></div><p>Notice, again, that <code>-&gt;</code> at a type-level is <em>realized</em> through <em>nesting of lambdas</em>, and the <em>arguments</em> are also <em>lamdas</em> (are &ldquo;arrows&rdquo; themselves).</p>
<h2 id="an-interpreter">An interpreter<a hidden class="anchor" aria-hidden="true" href="#an-interpreter">#</a></h2>
<p>Just as <em>computer</em> would mean a <em>human being performig computations</em>, an interpreter originally was also a <em>human being</em>.
In order to perfom <em>arithmetic or algerbraic computation</em> a <em>computer</em> must also be an <em>interpter</em> of the mathematical <em>notation</em>.</p>
<p>Intepretation, in turn, involves what we call <em>evaluation (simplification or reduction)</em>, which is application of a fixed Set of well-defined <em>rules</em>.</p>
<p>The rules usually are defined as <em>equations</em> and the application of rules is a <em>substitution</em> of equal for equal, untill no more rules could be applied.</p>
<p>When a person performing simple arithmetic or algebraic calculations &ldquo;observes&rdquo; (using what we call introspection) what he is actually doing, some &ldquo;recurring patterns&rdquo; will emerge.</p>
<p>This is where the <em>substitution model</em> of calculation or evaluation came from. It was generalized (discovered) not invented (as something which has no basis in actual reality).</p>
<p>An intepreter, thus, is a <em>Universal Abstract Machine</em>. Every electronic computer is an intepreter of its own &ldquo;machine code&rdquo;.</p>
<h2 id="the-classic-languages">The Classic Languages<a hidden class="anchor" aria-hidden="true" href="#the-classic-languages">#</a></h2>
<p>The so-called Classic Languages has been <em>based on</em> and <em>built upon</em> the Simple Typed Lambda Calculus, by augmenting it with types, advanced <em>type-systems</em> and related <em>syntactic sugar</em>.</p>
<p>The Classic Languages are:</p>
<ul>
<li>CLU (unfortunately, an imperative language)</li>
<li>Scheme</li>
<li>ML</li>
<li>Ocaml</li>
<li>Miranda</li>
<li>Haskell</li>
<li>Coq</li>
<li>Scala 3</li>
</ul>
<p>CLU systematized and popularized the <em>Abstract Data Types</em> as the most fundamental building block of any software system, independent of a particular language being used.</p>
<p>ADTs are so fundamental that they can be traced to the mathematical definition of the most fundamental Set abstraction <em>in terms of a set of operations</em>. CLU emphasized ADTs and <em>specifications</em>.</p>
<p>The major fundamental result was the <em>R5RS</em> Standard, which is a culmination of evolution of <em>Scheme</em>. All the fundamental building blocks for a program for a (strong, dynamic-typed, strict language) has been well-understood and implemented.
<em>The MIT Scheme</em> is the <em>monument (the most famous landmark)</em> of this tradition.</p>
<p>Another major <em>tradition</em> produced its own landmark monument &ndash; <em>SML/NJ</em> &ndash; an implementation of the <em>statically-typed</em>, mostly-functional <em>strict</em> programming language Standard ML.</p>
<p><em>Ocaml</em> could be considered as a <em>dialect (and a considerable refinement) of Standard ML.</em></p>
<p>These languages eventually &ldquo;gave up&rdquo; (so to speak) and introdiced mutation with special syntax, which broke the fundamental <em>referential transparency</em> property, from which everything good follows.
Programmers usually write a <em>pure functional &ldquo;core&rdquo;</em> and then a layer which calls <em>imperative procedures.</em></p>
<p><em>Haskell</em> managed to retain the crucial <em>referential transparency</em> property <em>for all its code</em>, so technically it is <em>an advanced system of logic</em> of its own. When one writes <em>Haskell</em> one writes a declarative <em>pure logic</em>.</p>
<p>Haskell, thus, is the most pragmatic language. When one could formalize and define one&rsquo;s <em>problem domain</em> in Haskell, the result will be not a running program, but an evolved <em>mathematical formalism</em> which describes the problem domain.</p>
<p>The conclusion is that all these languages have been built upon the same fundamental notions, which can be traced back to the Sample-Typed Lambda Calculus as the &ldquo;core language&rdquo; (or even the <em>intermediate representation of the compiler</em>, as in GHC), and even <em>beyond</em>.</p>
<p>It takes some education and knowledge to fully appreciate <em>what</em> Haskell and GHC really are.</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://lngnmn2.github.io/tags/foundations/">foundations</a></li>
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2023 <a href="https://lngnmn2.github.io/">Notes from the digital underground by Lngnmn</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
