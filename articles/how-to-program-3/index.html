<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>How To Program 3 | Notes from the digital underground by Lngnmn</title>
<meta name="keywords" content="ADT, DSL">
<meta name="description" content="I am getting old and keep forgetting things I have found out.">
<meta name="author" content="&amp;lt;lngnmn2@yahoo.com&amp;gt;">
<link rel="canonical" href="https://lngnmn2.github.io/articles/how-to-program-3/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.d0049500090a8b5b522a30f4bc70f815df41595125d25503dff47281216974cb.css" integrity="sha256-0ASVAAkKi1tSKjD0vHD4Fd9BWVEl0lUD3/RygSFpdMs=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://lngnmn2.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://lngnmn2.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://lngnmn2.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://lngnmn2.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://lngnmn2.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://lngnmn2.github.io/articles/how-to-program-3/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Source+Code+Pro:wght@300&display=swap" rel="stylesheet">
<link href="https://fonts.googleapis.com/css2?family=Noto+Sans:wght@300&display=swap" rel="stylesheet">
<link href="https://fonts.googleapis.com/css2?family=Noto+Serif:wght@300&display=swap" rel="stylesheet">
<style>
font-family: 'Noto Serif', serif;
font-family: 'Noto Sans', sans-serif;
font-family: 'Source Code Pro', monospace;
</style>
<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script type="text/javascript" id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script><meta property="og:url" content="https://lngnmn2.github.io/articles/how-to-program-3/">
  <meta property="og:site_name" content="Notes from the digital underground by Lngnmn">
  <meta property="og:title" content="How To Program 3">
  <meta property="og:description" content="I am getting old and keep forgetting things I have found out.">
  <meta property="og:locale" content="en-us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="articles">
    <meta property="article:published_time" content="2025-02-23T00:00:00+05:45">
    <meta property="article:modified_time" content="2025-02-23T17:58:38+05:45">
    <meta property="article:tag" content="ADT">
    <meta property="article:tag" content="DSL">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="How To Program 3">
<meta name="twitter:description" content="I am getting old and keep forgetting things I have found out.">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Articles",
      "item": "https://lngnmn2.github.io/articles/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "How To Program 3",
      "item": "https://lngnmn2.github.io/articles/how-to-program-3/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "How To Program 3",
  "name": "How To Program 3",
  "description": "I am getting old and keep forgetting things I have found out.",
  "keywords": [
    "ADT", "DSL"
  ],
  "articleBody": "Here is the Dan Grossman’s Caml tutorial (refresher) for Ocaml. The cool thing about it is that it shows how little we all need.\nhttps://homes.cs.washington.edu/~djg/teachingMaterials/gpl/lectures/camlTutorial.pdf\nHe is actually a very cool guy, who teaches the principles (and precise semantics) of programming using the classic languages – SML and Ocaml, which were carefully designed by talented math majors to build theorem provers and proof assistants.\nThese languages (and Erlang) ought to be “all you need”, but the world is what it is (Pootin, Trump and what not) so we have Java or C++ or, if unlucky – PHP or Javascript.\nNow there is something profound to realize: “all you need” from a language is “just” functions (lexical closures) and algebraic data types. This has not been “invented”, this has been discovered (look up what the Curry-Howard Isomorphism is about).\nAnother discovery, was that the data-constructors could be used as “type tags”, and any “algebraic structure” could be pattern-matched against them.\nStructural Pattern-matching is a very universal notion, so universal that biological enzymes are using it. Well, technically, ours is a proper generalization of biological.\nThere are very important and overlooked subtleties too. We need an Environment, which corresponds to a set (the notion of an order is irrelevant) of all previous results – \\(\\Gamma\\) – or what is already known in logic.\nEvery evaluation (or simplification of a proof or of logical terms) is done withing some Environment and, in addition, a local context.\nWhat is a context? It is a chain of nested frames of the environment, so shadowing of the symbols (or overloading of the concepts) can occur.\nYou have no idea how deep it goes and what has been [properly] captured as the result of activities in the golden age of Functional Lineages research (which started with ISWIM culminated in Haskell 2010).\nAll you really need are bindings (between symbols and values) in the Environment, and another set of mappings between values (referenced by symbols) and its types. This is an “additional layer” of the environment and this fact is nicely captured by the “above” notation Haskell uses for writing types of functions.\nThere is another fundamental notion – of partitioning, and even more fundamental – of nesting.\nNesting gives you scopes and modules, which are the most important aspects of code organization (structuring), and a proper generalization of nested function calls gives us “Currying”.\nCurried functions is the necessary basis for partial applications (they have to be proper lexical closures too), and partial application allows us to extend the language with out own “control-flow abstractions”.\nAlgebraic types (and GADTs) allow us to extend the language with new kinds of the data [items] in a very systematic, mathematically general way.\nOn a higher level, everything has to be “layers upon layers of DSLs”, each of which, ideally, shall be monoidal (this is what the MATLAB/Octave language evolved into). There is also that “Architecture of Complexity” paper by Herbert A. Simon.\nNotice, noting described so far is redundant or arbitrary. Every “feature” is necessary, is orthogonal to and complements other features, and, it turns out, will be sufficient for everything commutable.\nWell, the Simple Typed Lambda Calculus is sufficient, we are just discussing what has been discovered to augment it properly and to extend it with better, advanced types (and type-classes).\nSo, this is the universal basis. All the great (really) classic languages – Standard ML, Miranda, Ocaml, Haskell, Scala 3, F# – have been built upon this universal basis discovered intuitively by mathematicians, logicians and “applied mathematicians” who program the first computers.\nThere is, however, a problem. A lot of them. Lots and lots of problems.\nThese classic languages has been carefully designed to enable a fast prototyping (among other thins). It is actually very straightforward – one models with well-understood mathematical concepts, and then just tries it in this or that classic language.\nThe basis reflects the basis of mathematics itself. It can be even traced back to the discovery of so-called Curry-Howard isomorphism (which shows that the Elephant is actually out there and it is one and the same).\nBy the way, before talking about the problems… A language for so called “smart contracts” (which no one actually needs or wants, except scammers) shall be built on this universal base. Even KRC not even full Miranda was enough for this use case.\nIt has to be extended with two major innovations: the pattern-matching on receive, from Erlang, so that pure structured values would be introduced to the scope (Erlang did this just right) without breaking referential transparency (structured value is a result of evasion of a corresponding clause of a pattern-matching expression – just like a “partial” function, defined using clauses, which reflects partitions in the domain).\nOne could also lift both send and receive primitives into an IO Monad, which is also the most natural thing to do, but even this is not necessary for a smart contract, which does not have much of error handling logic (they assume send and receive are atomic and always succeeds).\nEither Miranda’s esoteric approach (compiling into the SKI combinators) or what Haskell does (the G-machine) is absolutely secure, because it evaluates stateless “declarative” expressions, as one would do with a pen and paper. And no, you don’t have to have these boxed 256bit values. The early satellites flew on 16bits.\nSo, the problems…\nToday’s de-facto fast (and very productive) prototyping languages of choice is Python. Python is eating the world (thank god the Javascript madness is fading away).\nThere are a few good things about Python. Its truly dynamic nature – whatever hangs out from an object (literally) defines its duck-type, so to speak, and the ability to decorate any value and a “function” with actual types, which can be checked for correctness using specialized packages.\nThis unique kind of typing is arguably the best for prototyping. One starts dynamic and then gradually adds some sanity checks.\nAnother seemingly good thing about Python is that there is a library (or two!) for literally anything on Guthub (PyPI). The problem is that most of these libraries are absolute low-effort crap, ridden with useless, redundant abstractions, fucking useless async and what not – the junk food of programming.\nThe answer to this is very careful nesting at the level of modules, so one wraps crappy interfaces inside wrappers which exports a good interfaces. This approach also keeps the dependency hell manageable, but requires a lot of careful work. This is where the real craftsmanship begins (partitioning of the code with “cell membranes”).\nThe smart mathematical majors of the past have created amazingly powerful module systems (SML in particular) to solve in general exactly this kind of problems, but no one cares or even thinks about such things seriously.\nThe problem with all the classic languages is lack of a library for literally anything somewhere on Github. This is NOT because these languages are worse than Python. On the contrary, they are superior in many aspects, but to understand and appreciate this requires a proper serious education.\nSome cool guys have “ported” some good Python code to modern Scala (this fact proves that Scala 3 is almost as expressive, being properly statically typed), but this is the rarest case of a true intelligence.\nAnother problem is that neither proper sum-types nor product types (so called record types) could be properly (yes, yes) defined in Python – one has to use classes or data-classes, which introduce redundancy and complexity. Having “just values” (not objects) is enough.\nNot just redundancy and added complexity, but it can be shown that a set of values with corresponding set of operations (a public interface exported by a module) is isomorphic to class-based definitions, provided the implicit parameter “self” is just, well, a parameter. But having a “pure values” (without a hidden state) makes everything reverentially transparent, just like math.\nThere is a famous (among learned scholars) presentation by Scott Wlaschin about “domain modeling”:\nhttps://www.youtube.com/watch?v=MlPQ0FsPxPY\nThe absolutely amazing moment, at lest to some, is that “Where is the code?” remark and the subsequent realization that “everything typechecks”.\nThis, however, has nothing to do with mr. Wlaschin, however cool and clever his presentation is, but to the fact that the creators of ML (and Ocaml), of which F# is a dialect, have done the Algebraic types just right, and everyone else did it plain wrong.\nWatch the video, maybe you will hit by some premature enlightenment.\nOne more time. There is the universal basis for programming, which is a smallest possible set of orthogonal (but complementing each other) extensions to the Simply Typed Lambda Calculus. It has been re-discovered by both “strict” and “lazy” traditions (while the “lazy” tradition has discovered even more universality).\nTheoretically, the classic math-based languages of the ML family are simply superior to the current popular imperative crap, and as a consequence of being popular instead of good (yes, yes, Ayn Rand) we have this problem – lack of high-quality libraries for the mundane stuff. Ocaml is slowly accumulating some, thanks to Jane Street.\nBy the way, there is a complete fully functioning blockchain, which has been written in Ocaml by a very small team on almost ramens (just kidding). Its codebase is “agile”, much more clean and easier to understand and maintain – everything that has been promised by the best (applied mathematics) theoreticians can be actually seen within this project.\nhttps://github.com/tezos/tezos-mirror\nTo summarize, the problems are not with the classic languages, they are almost perfect (really), the problem is “the coders”, who are ignorant, uneducated and have been raised on social media bullshit, like /g/ or modern HN, and now on the AI slop.\nAnd yes, there are way better things than Python or Javascript (leave alone C++ or Java) out there (the X-Files music theme is playing in background).\n",
  "wordCount" : "1638",
  "inLanguage": "en",
  "datePublished": "2025-02-23T00:00:00+05:45",
  "dateModified": "2025-02-23T17:58:38+05:45",
  "author":[{
    "@type": "Person",
    "name": "\u0026lt;lngnmn2@yahoo.com\u0026gt;"
  }],
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://lngnmn2.github.io/articles/how-to-program-3/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Notes from the digital underground by Lngnmn",
    "logo": {
      "@type": "ImageObject",
      "url": "https://lngnmn2.github.io/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://lngnmn2.github.io/" accesskey="h" title="Notes from the digital underground by Lngnmn (Alt + H)">Notes from the digital underground by Lngnmn</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://lngnmn2.github.io/about/" title="About me.">
                    <span>About me.</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title entry-hint-parent">
      How To Program 3
    </h1>
    <div class="post-description">
      I am getting old and keep forgetting things I have found out.
    </div>
    <div class="post-meta"><span title='2025-02-23 00:00:00 +0545 +0545'>February 23, 2025</span>&nbsp;·&nbsp;<span>&amp;lt;lngnmn2@yahoo.com&amp;gt;</span>

</div>
  </header> 
  <div class="post-content"><p>Here is the Dan Grossman&rsquo;s Caml tutorial (refresher) for Ocaml. The cool thing about it is that it shows how little we all need.</p>
<p><a href="https://homes.cs.washington.edu/~djg/teachingMaterials/gpl/lectures/camlTutorial.pdf">https://homes.cs.washington.edu/~djg/teachingMaterials/gpl/lectures/camlTutorial.pdf</a></p>
<p>He is actually a very cool guy, who teaches the <em>principles</em> (and <em>precise semantics</em>) of programming using the classic languages &ndash; <em>SML</em> and <em>Ocaml</em>, which were carefully designed by talented math majors to build theorem provers and proof assistants.</p>
<p>These languages (and Erlang) <em>ought</em> to be &ldquo;all you need&rdquo;, but the world is what it is (Pootin, Trump and what not) so we have Java or C++ or, if unlucky &ndash; PHP or Javascript.</p>
<p>Now there is something profound to realize: &ldquo;all you need&rdquo; from a language is &ldquo;just&rdquo; functions (<em>lexical closures</em>) and <em>algebraic data types</em>. This has not been &ldquo;invented&rdquo;, this has been <em>discovered</em> (look up what <em>the Curry-Howard Isomorphism</em> is about).</p>
<p>Another <em>discovery</em>, was that the <em>data-constructors</em> could be used as &ldquo;type tags&rdquo;, and any &ldquo;algebraic structure&rdquo; could be <em>pattern-matched</em> against them.</p>
<p><em>Structural Pattern-matching</em> is a very universal notion, so universal that biological enzymes are using it. Well, technically, ours is a proper generalization of biological.</p>
<p>There are very important and overlooked subtleties too. We need an Environment, which corresponds to a set (the notion of an order is irrelevant) of all previous results &ndash; \(\Gamma\) &ndash; or what <em>is already known</em> in logic.</p>
<p>Every <em>evaluation</em> (or <em>simplification</em> of a proof or of logical terms) is done withing some Environment and, in addition, a local <em>context</em>.</p>
<p>What is a context? It is a chain of nested <em>frames of the environment</em>, so shadowing of the symbols (or <em>overloading</em> of the concepts) can occur.</p>
<p>You have no idea how deep it goes and what has been [properly] captured as the result of activities in the golden age of Functional Lineages research (which started with <em>ISWIM</em> culminated in Haskell 2010).</p>
<p>All you really need are bindings (between symbols and values) in the Environment, and another set of <em>mappings</em> between values (referenced by symbols) and its <em>types</em>. This is an &ldquo;additional layer&rdquo; of the environment and this fact is nicely captured by the &ldquo;above&rdquo; notation Haskell uses for writing types of functions.</p>
<p>There is another fundamental notion &ndash; of <em>partitioning</em>, and even more fundamental &ndash; of <em>nesting</em>.</p>
<p>Nesting gives you <em>scopes</em> and <em>modules</em>, which are the most important aspects of code organization (structuring), and a proper <em>generalization of nested function calls</em> gives us <em>&ldquo;Currying&rdquo;</em>.</p>
<p>Curried functions is the necessary basis for partial applications (they have to be proper <em>lexical closures</em> too), and partial application allows us to extend the language with out own &ldquo;control-flow abstractions&rdquo;.</p>
<p>Algebraic types (and GADTs) allow us to extend the language with new kinds of the data [items] in a very systematic, mathematically general way.</p>
<p>On a higher level, everything has to be &ldquo;layers upon layers of DSLs&rdquo;, each of which, ideally, shall be monoidal (this is what the MATLAB/Octave language <em>evolved</em> into). There is also that &ldquo;Architecture of Complexity&rdquo; paper by Herbert A. Simon.</p>
<p>Notice, noting described so far is redundant or arbitrary. Every &ldquo;feature&rdquo; is necessary, is orthogonal to and complements other features, and, it turns out, will be sufficient for everything commutable.</p>
<p>Well, the Simple Typed Lambda Calculus <em>is sufficient</em>, we are just discussing what has been discovered to <em>augment</em> it properly and to <em>extend</em> it with better, advanced types (and type-classes).</p>
<p>So, this is the universal basis. All the great (really) classic languages &ndash; <em>Standard ML, Miranda, Ocaml, Haskell, Scala 3, F#</em> &ndash; have been built upon this universal basis discovered <em>intuitively</em> by  mathematicians, logicians and &ldquo;applied mathematicians&rdquo; who program the first computers.</p>
<p>There is, however, a problem. A lot of them. Lots and lots of problems.</p>
<p>These classic languages has been carefully designed to <em>enable a fast prototyping</em> (among other thins). It is actually very straightforward &ndash; one models with well-understood mathematical concepts, and then just tries it in this or that classic language.</p>
<p>The basis reflects the basis of mathematics itself. It can be even traced back to the discovery of so-called Curry-Howard isomorphism (which shows that the Elephant is actually out there and it is one and the same).</p>
<p>By the way, before talking about the problems&hellip; A language for so called &ldquo;smart contracts&rdquo; (which no one actually needs or wants, except scammers) shall be built on this universal base. Even <em>KRC</em> not even full Miranda was enough for this use case.</p>
<p>It has to be extended with two major innovations: the pattern-matching on <em>receive</em>, from Erlang, so that <em>pure structured values</em> would be introduced to the scope (Erlang did this just right) without breaking referential transparency (structured value is a result of evasion of a corresponding <em>clause</em> of a pattern-matching expression &ndash; just like a &ldquo;partial&rdquo; function, defined using clauses, which reflects partitions in the domain).</p>
<p>One could also lift both <em>send</em> and <em>receive</em> primitives into an IO Monad, which is also the most natural thing to do, but even this is not necessary for a smart contract, which does not have much of error handling logic (they assume <em>send</em> and <em>receive</em> are atomic and always succeeds).</p>
<p>Either Miranda&rsquo;s esoteric approach (compiling into the SKI combinators) or what Haskell does (the G-machine) is <em>absolutely secure</em>, because it evaluates stateless &ldquo;declarative&rdquo; expressions, as one would do with a pen and paper. And no, you don&rsquo;t have to have these boxed 256bit values. The early satellites flew on 16bits.</p>
<p>So, the problems&hellip;</p>
<p>Today&rsquo;s de-facto fast (and very productive) prototyping languages of choice is <em>Python</em>. Python is eating the world (thank god the Javascript madness is fading away).</p>
<p>There are a few good things about Python. Its <em>truly dynamic</em> nature &ndash; whatever hangs out from an object (literally) defines its <em>duck-type</em>, so to speak, and the ability to <em>decorate any value and a &ldquo;function&rdquo;</em> with actual types, which can be checked for correctness using specialized packages.</p>
<p><em>This unique kind of typing</em> is arguably the best for prototyping. One starts dynamic and then gradually adds some sanity checks.</p>
<p>Another seemingly good thing about Python is that there is a library (or two!) for literally anything on Guthub (PyPI). The problem is that most of these libraries are absolute low-effort crap, ridden with useless, redundant abstractions, fucking useless <em>async</em> and what not &ndash; the junk food of programming.</p>
<p>The answer to this is very careful <em>nesting</em> at the level of modules, so one wraps crappy interfaces inside wrappers which exports a good interfaces. This approach also keeps the dependency hell manageable, but requires a lot of careful work. This is where the real craftsmanship begins (partitioning of the code with &ldquo;cell membranes&rdquo;).</p>
<p>The smart mathematical majors of the past have created amazingly powerful module systems (SML in particular) to solve <em>in general</em> exactly this kind of problems, but no one cares or even thinks about such things seriously.</p>
<p>The problem with all the classic languages is lack of a library for literally anything somewhere on Github. This is NOT because these languages are worse than Python. On the contrary, they are <em>superior in many aspects</em>, but to understand and appreciate this requires a proper serious education.</p>
<p>Some cool guys have &ldquo;ported&rdquo; some good Python code to modern Scala (this fact proves that Scala 3 is almost as expressive, being properly statically typed), but this is the rarest case of a true intelligence.</p>
<p>Another problem is that neither proper <em>sum-types</em> nor product types (<em>so called record types</em>) could be properly (yes, yes) defined in Python &ndash; one has to use <em>classes</em> or <em>data-classes</em>, which introduce redundancy and complexity. Having &ldquo;just values&rdquo; (<em>not objects</em>) is enough.</p>
<p>Not just redundancy and added complexity, but it can be shown that a set of values with corresponding set of operations (a public interface exported by a module) is isomorphic to class-based definitions, provided the implicit parameter &ldquo;self&rdquo; is just, well, a parameter.
But having a &ldquo;pure values&rdquo; (without a hidden state) makes everything reverentially transparent, just like math.</p>
<p>There is a famous (among learned scholars) presentation by <em>Scott Wlaschin</em> about &ldquo;domain modeling&rdquo;:</p>
<p><a href="https://www.youtube.com/watch?v=MlPQ0FsPxPY">https://www.youtube.com/watch?v=MlPQ0FsPxPY</a></p>
<p>The absolutely amazing moment, at lest to some, is that &ldquo;Where is the code?&rdquo; remark and the subsequent realization that &ldquo;everything typechecks&rdquo;.</p>
<p>This, however, has nothing to do with mr. Wlaschin, however cool and clever his presentation is, but to the fact that the creators of <em>ML</em> (and Ocaml), of which <em>F#</em> is a dialect, have done the Algebraic types just right, and <em>everyone else did it plain wrong</em>.</p>
<p>Watch the video, maybe you will hit by some premature enlightenment.</p>
<p>One more time. There is the <em>universal basis</em> for programming, which is a smallest possible set of orthogonal (but complementing each other) extensions to the Simply Typed Lambda Calculus. It has been re-discovered by both &ldquo;strict&rdquo; and &ldquo;lazy&rdquo; traditions (while the &ldquo;lazy&rdquo; tradition has discovered even more universality).</p>
<p>Theoretically, the classic math-based languages of the ML family are simply superior to the current popular imperative crap, and as a consequence of being popular instead of good (yes, yes, Ayn Rand) we have this problem &ndash; lack of high-quality libraries for the mundane stuff. Ocaml is slowly accumulating some, thanks to <em>Jane Street</em>.</p>
<p>By the way, there is a <em>complete fully functioning blockchain</em>, which has been written in Ocaml by a very small team on almost ramens (just kidding). Its codebase is &ldquo;agile&rdquo;, much more clean and easier to understand and maintain &ndash; everything that has been promised by the best (applied mathematics) theoreticians can be actually seen within this project.</p>
<p><a href="https://github.com/tezos/tezos-mirror">https://github.com/tezos/tezos-mirror</a></p>
<p>To summarize, the problems are not with the classic languages, they are almost perfect (really), the problem is &ldquo;the coders&rdquo;, who are ignorant, uneducated and have been raised on social media bullshit, like <code>/g/</code> or modern <code>HN</code>, and now on the AI slop.</p>
<p>And yes, there are <em>way better</em> things than Python or Javascript (leave alone C++ or Java) out there (<em>the X-Files music theme is playing in background</em>).</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://lngnmn2.github.io/tags/adt/">ADT</a></li>
      <li><a href="https://lngnmn2.github.io/tags/dsl/">DSL</a></li>
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="https://lngnmn2.github.io/">Notes from the digital underground by Lngnmn</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
