<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Look ma, 100x engineers | Notes from the digital underground by Lngnmn</title>
<meta name="keywords" content="LLM">
<meta name="description" content="Another day -- another bullshit">
<meta name="author" content="&amp;lt;lngnmn2@yahoo.com&amp;gt;">
<link rel="canonical" href="https://lngnmn2.github.io/articles/100x-engineering/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.8fe10233a706bc87f2e08b3cf97b8bd4c0a80f10675a143675d59212121037c0.css" integrity="sha256-j&#43;ECM6cGvIfy4Is8&#43;XuL1MCoDxBnWhQ2ddWSEhIQN8A=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://lngnmn2.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://lngnmn2.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://lngnmn2.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://lngnmn2.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://lngnmn2.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://lngnmn2.github.io/articles/100x-engineering/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Source+Code+Pro:wght@300&display=swap" rel="stylesheet">
<link href="https://fonts.googleapis.com/css2?family=Noto+Sans:wght@300&display=swap" rel="stylesheet">
<link href="https://fonts.googleapis.com/css2?family=Noto+Serif:wght@300&display=swap" rel="stylesheet">
<style>
font-family: 'Noto Serif', serif;
font-family: 'Noto Sans', sans-serif;
font-family: 'Source Code Pro', monospace;
</style>
<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script type="text/javascript" id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script><meta property="og:url" content="https://lngnmn2.github.io/articles/100x-engineering/">
  <meta property="og:site_name" content="Notes from the digital underground by Lngnmn">
  <meta property="og:title" content="Look ma, 100x engineers">
  <meta property="og:description" content="Another day -- another bullshit">
  <meta property="og:locale" content="en-us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="articles">
    <meta property="article:published_time" content="2024-04-24T00:00:00+05:45">
    <meta property="article:modified_time" content="2025-07-23T08:45:59+05:45">
    <meta property="article:tag" content="LLM">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Look ma, 100x engineers">
<meta name="twitter:description" content="Another day -- another bullshit">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Articles",
      "item": "https://lngnmn2.github.io/articles/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Look ma, 100x engineers",
      "item": "https://lngnmn2.github.io/articles/100x-engineering/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Look ma, 100x engineers",
  "name": "Look ma, 100x engineers",
  "description": "Another day -- another bullshit",
  "keywords": [
    "LLM"
  ],
  "articleBody": "Today’s bullshit was Surge CEO Says ‘100x Engineers’ Are Here. Yesterday it was “Gemini at IMO Gold level”. Again, mere appearances are not the facts of reality, but this realization requires a bit more education and old-fashioned intelligence, similar to that of Hesse or Sartre.\nWhat does it mean nowadays to be an engineer, and to be a 100x? It seems that the meaning is what they call “productivity”, which is time elapsed for putting together some spaghetti webshit .without any understanding whatsoever, from hundreds of lowest quality amateur node_modules in a few minutes. This is what 100x means for them, and this is, of course, bullshit.\nHere is what may be a real 100x:\nfind out an optimal generalized monadic interfaces to clearly separate “effects” from “pure” code, so that a compiler can check and enforce these abstraction barriers, so a much simpler (less complex), safer (via non-overlapping guarantees) language runtimes can be developed. write a close to optimum automatic differentiation engine, in Rust, lets say (because the more compile-time constraints are satisfied – the better), so it can be interfaced in all higher-level scripting languages. Yes, yes, we have PyTorch, but it is a cowboy-coding crap. OK, lets just evolve Octave (which has absolutely amazing “proper” high-level DSL for matrix manipulations) to support modern JIT tech, like Intel SYCL and what not. In general, if the current megacorp-level (a datacenter-sized) models posses any 10x (which they do only in terms of the speed of generation what only appears to be a “good” code), it is kind of an obvious choice to apply it to “perfect” (noting more to simplify or take away) the foundational parts, like standard libraries and compilers, and the underlying mathematical models and representations (expression graphs, IR, etc).\nHave we ever seen any compiler/stdlib ABI improvements due to application of mega AI models? Nope. Zero.\nHere are another meme-benchmarks (tasks) for coding AI, so we all would say “wooooow” in awe and would bow to them as to some gurus and masters, being actually superior in capacities and refinement.\nTake the best results in the most difficult parts of the classic CS and PL theory and make some progress towards reducing unnecessary complexity and removing “the technical debt” of ignorance and over-zeal.\nThe best results, of course, are the math-based, reverentially transparent mostly-functional languages, (and Haskell that did almost everything right). The task is well-defined and well-understood – to add “necessary” minimal imperative features in the only proper way - that the referential transparency property will be retained and that all the imperative features will be clearly separated by the abstraction barriers, which are checked, enforced and even inferred by a compiler. And this is not even “that difficult” – the “what color is your function” is an intuitive step in the right direction. No? Why no?\nIf the models are so good at code generation, and the productivity is that high, why not just rewrite from scratch the best codebases we ever have, to make it “just right” by removing accidental complexity and “stupidity dept”?\nHaskell (effects in the type-system, better set of libraries, removing unnecessary, redundant abstractions), Ocaml (cleaning up all the mess at the level of macros, take the best emergent syntactic sugar in), Scala3 (even more refinement, more removing of the clutter, even more convergence to the local optimums) And above all, lets unify core languages and stdlibs based on useful accidental findings of other, rival “sects”. There is a set of features that is “just right”, orthogonal but complementary to each other. The classic FP/PL world has lots discoveries and the intuitive notion that “all modern imperative languages tend to become more and more similar in its features” is the right intuition and, indeed, an optimum is “Out There”, just like, lets say, how to properly use heat to cook food “just right” .\nBut they just cannot. The models do not posses the required capacities. They cannot come with novel solutions by combining the best parts already “known”. They only can re-create a new slop from the old one. Enough slop – like webshit or amateur Python, which does not even use the most idiomatic and optimal features of the language in the right way – will give rise to more slop of just the same low-effort crap.\nAnd yes, being able to generate a low-effort imperative slop at the 100x speed is exactly what your “100x engineers” really are. This has something to do with enshittification of knowledge in general, of which “pronous” and other “modern progressive social constructs” are mere direct consequence.\n",
  "wordCount" : "765",
  "inLanguage": "en",
  "datePublished": "2024-04-24T00:00:00+05:45",
  "dateModified": "2025-07-23T08:45:59+05:45",
  "author":[{
    "@type": "Person",
    "name": "\u0026lt;lngnmn2@yahoo.com\u0026gt;"
  }],
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://lngnmn2.github.io/articles/100x-engineering/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Notes from the digital underground by Lngnmn",
    "logo": {
      "@type": "ImageObject",
      "url": "https://lngnmn2.github.io/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://lngnmn2.github.io/" accesskey="h" title="Notes from the digital underground by Lngnmn (Alt + H)">Notes from the digital underground by Lngnmn</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://lngnmn2.github.io/about/" title="About me.">
                    <span>About me.</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title entry-hint-parent">
      Look ma, 100x engineers
    </h1>
    <div class="post-description">
      Another day -- another bullshit
    </div>
    <div class="post-meta"><span title='2024-04-24 00:00:00 +0545 +0545'>April 24, 2024</span>&nbsp;·&nbsp;&amp;lt;lngnmn2@yahoo.com&amp;gt;

</div>
  </header> 
  <div class="post-content"><p>Today&rsquo;s bullshit was <a href="https://developers.slashdot.org/story/25/07/22/190242/surge-ceo-says-100x-engineers-are-here">Surge CEO Says &lsquo;100x Engineers&rsquo; Are Here</a>. Yesterday it was &ldquo;Gemini at IMO Gold level&rdquo;. Again, mere appearances are not the facts of reality, but this realization requires a bit more education and old-fashioned intelligence, similar to that of Hesse or Sartre.</p>
<p>What does it mean <em>nowadays</em> to be an engineer, and to be a 100x? It seems that the meaning is what <em>they</em> call &ldquo;productivity&rdquo;, which is time elapsed for putting together some spaghetti <em>webshit</em>  .without any understanding whatsoever, from hundreds of lowest quality amateur  <code>node_modules</code>  in a few minutes.  <em>This</em> is what 100x means <em>for them</em>, and this is, of course, bullshit.</p>
<p>Here is what may be a real 100x:</p>
<ul>
<li>find out an optimal generalized monadic interfaces to clearly separate &ldquo;effects&rdquo; from &ldquo;pure&rdquo; code, so that a compiler can check and enforce these abstraction barriers, so a much simpler (less complex), safer (via non-overlapping guarantees) language runtimes can be developed.</li>
<li>write a close to optimum automatic differentiation engine, in Rust, lets say (because the more compile-time constraints are satisfied &ndash; the better), so it can be interfaced in all higher-level scripting languages. Yes, yes, we have PyTorch, but it is a cowboy-coding crap.</li>
<li>OK, lets just evolve  Octave (which has absolutely amazing &ldquo;proper&rdquo; high-level DSL for matrix manipulations) to support modern JIT tech, like Intel SYCL and what not.</li>
</ul>
<p>In general, if the current megacorp-level (a datacenter-sized) models posses any 10x (which they do only in terms of the speed of generation <em>what only appears to be</em> a &ldquo;good&rdquo; code), it is kind of an obvious choice to apply it to &ldquo;perfect&rdquo; (noting more to simplify or take away) the foundational parts, like standard libraries and compilers, and the underlying mathematical models and representations (expression graphs, IR, etc).</p>
<p>Have we ever seen any compiler/stdlib ABI improvements due to application of mega AI models? Nope. Zero.</p>
<p>Here are another meme-benchmarks (tasks) for coding AI, so we all would say &ldquo;wooooow&rdquo; in awe and would bow to them as to some gurus and masters, being actually superior in capacities and refinement.</p>
<p>Take the best results in the most difficult parts of the classic CS and PL theory and make some progress towards reducing unnecessary complexity and removing &ldquo;the technical debt&rdquo; of ignorance and over-zeal.</p>
<p>The best results, of course, are the math-based, reverentially transparent mostly-functional languages, (and  Haskell that did almost everything right). The task is well-defined and well-understood &ndash; to add &ldquo;necessary&rdquo; minimal imperative features in the only proper way - that the referential transparency property will be retained and that all the imperative features will be clearly separated by the abstraction barriers, which are checked, enforced and even inferred by a compiler. And this is not even  &ldquo;that difficult&rdquo; &ndash; the &ldquo;what color is your function&rdquo; is an intuitive step in the right direction. No? Why no?</p>
<p>If the models are so good at code generation, and the productivity is <em>that high</em>, why not just rewrite from scratch the best codebases we ever have, to make it &ldquo;just right&rdquo; by removing accidental complexity and  &ldquo;stupidity dept&rdquo;?</p>
<ul>
<li>Haskell (effects in the type-system, better set of libraries, removing unnecessary, redundant abstractions),</li>
<li>Ocaml (cleaning up all the mess at the level of macros, take the best emergent syntactic sugar in),</li>
<li>Scala3 (even more refinement, more removing of the clutter, even more convergence to the local optimums)</li>
</ul>
<p>And above all, lets unify core languages and stdlibs based on useful accidental findings of other, rival &ldquo;sects&rdquo;. There <em>is</em> a set of features that is &ldquo;just right&rdquo;, orthogonal but complementary to each other. The classic FP/PL world has lots discoveries and the intuitive notion that &ldquo;all modern imperative languages tend to become more and more similar in its features&rdquo;  is the right intuition and, indeed, an optimum is &ldquo;Out There&rdquo;, just like, lets say, how to properly use heat to cook food &ldquo;just right&rdquo; .</p>
<p>But they just cannot. The models do not posses the required capacities. They cannot come with novel solutions by combining the best parts already &ldquo;known&rdquo;. They only can re-create a new slop from the old one. Enough slop &ndash; like webshit or amateur Python, which does not even use the most idiomatic and optimal features of the language in the right way &ndash; will give rise to more slop of just the same low-effort crap.</p>
<p>And yes, being able to generate a low-effort imperative slop at the 100x speed is exactly what your &ldquo;100x engineers&rdquo; really are. This has something to do with enshittification of knowledge in general, of which &ldquo;pronous&rdquo; and other &ldquo;modern progressive social constructs&rdquo; are mere direct consequence.</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://lngnmn2.github.io/tags/llm/">LLM</a></li>
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="https://lngnmn2.github.io/">Notes from the digital underground by Lngnmn</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
