<!DOCTYPE html>
<html lang="en" dir="auto" data-theme="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>A few steps closer to Vedanta | Notes from the digital underground by Lngnmn</title>
<meta name="keywords" content="esoteric">
<meta name="description" content="Once upon a time I find it difficult to read these lecture notes in https://www.cl.cam.ac.uk/teaching/1718/L28/materials.html because of ESL and math &ldquo;fear&rdquo;. Nowadays I could, probably, explain the fundamentals more clearly in just a few pages.
The &ldquo;End Of Knowledge&rdquo; (of seeking to Understand) can be achieved by just a few simple realizations, which means attaining one&rsquo;s own &ldquo;Right Understanding&rdquo; through direct experience and one&rsquo;s own &ldquo;a-ha moments&rdquo;.
Arguably, the &ldquo;Upanishads&rdquo; of Programming began with this book: Abstraction and Specification in Program Development by Barbara Liskov and John V. Guttag. No, a few years earlier Michael A. Jackson wrote Principles of Program Design, which emphasized the fundamental principle that one&rsquo;s program structure should reflect (actually to be in one-to-one correspondence with) the problem structure (which can be defined as an inherent layered structure of complexity of the domain ). But Liskov and Guttag took it to a whole new level.">
<meta name="author" content="lngnmn2@yahoo.com">
<link rel="canonical" href="https://lngnmn2.github.io/articles/vedanta1/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.a5781257de4197b8e3d54346acdf1dd55a9ba4cb91dcace192fc1baf228c08b5.css" integrity="sha256-pXgSV95Bl7jj1UNGrN8d1VqbpMuR3KzhkvwbryKMCLU=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://lngnmn2.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://lngnmn2.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://lngnmn2.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://lngnmn2.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://lngnmn2.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://lngnmn2.github.io/articles/vedanta1/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
                color-scheme: dark;
            }

            .list {
                background: var(--theme);
            }

            .toc {
                background: var(--entry);
            }
        }

        @media (prefers-color-scheme: light) {
            .list::-webkit-scrollbar-thumb {
                border-color: var(--code-bg);
            }
        }

    </style>
</noscript>
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.querySelector("html").dataset.theme = 'dark';
    } else if (localStorage.getItem("pref-theme") === "light") {
       document.querySelector("html").dataset.theme = 'light';
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.querySelector("html").dataset.theme = 'dark';
    } else {
        document.querySelector("html").dataset.theme = 'light';
    }

</script><link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Source+Code+Pro:wght@300&display=swap" rel="stylesheet">
<link href="https://fonts.googleapis.com/css2?family=Noto+Sans:wght@300&display=swap" rel="stylesheet">
<link href="https://fonts.googleapis.com/css2?family=Noto+Serif:wght@300&display=swap" rel="stylesheet">
<style>
font-family: 'Noto Serif', serif;
font-family: 'Noto Sans', sans-serif;
font-family: 'Source Code Pro', monospace;
</style>
<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script type="text/javascript" id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script><meta property="og:url" content="https://lngnmn2.github.io/articles/vedanta1/">
  <meta property="og:site_name" content="Notes from the digital underground by Lngnmn">
  <meta property="og:title" content="A few steps closer to Vedanta">
  <meta property="og:description" content="Once upon a time I find it difficult to read these lecture notes in https://www.cl.cam.ac.uk/teaching/1718/L28/materials.html because of ESL and math “fear”. Nowadays I could, probably, explain the fundamentals more clearly in just a few pages.
The “End Of Knowledge” (of seeking to Understand) can be achieved by just a few simple realizations, which means attaining one’s own “Right Understanding” through direct experience and one’s own “a-ha moments”.
Arguably, the “Upanishads” of Programming began with this book: Abstraction and Specification in Program Development by Barbara Liskov and John V. Guttag. No, a few years earlier Michael A. Jackson wrote Principles of Program Design, which emphasized the fundamental principle that one’s program structure should reflect (actually to be in one-to-one correspondence with) the problem structure (which can be defined as an inherent layered structure of complexity of the domain ). But Liskov and Guttag took it to a whole new level.">
  <meta property="og:locale" content="en-us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="articles">
    <meta property="article:published_time" content="2025-11-14T00:00:00+05:45">
    <meta property="article:modified_time" content="2025-11-15T14:00:38+05:45">
    <meta property="article:tag" content="Esoteric">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="A few steps closer to Vedanta">
<meta name="twitter:description" content="Once upon a time I find it difficult to read these lecture notes in https://www.cl.cam.ac.uk/teaching/1718/L28/materials.html because of ESL and math &ldquo;fear&rdquo;. Nowadays I could, probably, explain the fundamentals more clearly in just a few pages.
The &ldquo;End Of Knowledge&rdquo; (of seeking to Understand) can be achieved by just a few simple realizations, which means attaining one&rsquo;s own &ldquo;Right Understanding&rdquo; through direct experience and one&rsquo;s own &ldquo;a-ha moments&rdquo;.
Arguably, the &ldquo;Upanishads&rdquo; of Programming began with this book: Abstraction and Specification in Program Development by Barbara Liskov and John V. Guttag. No, a few years earlier Michael A. Jackson wrote Principles of Program Design, which emphasized the fundamental principle that one&rsquo;s program structure should reflect (actually to be in one-to-one correspondence with) the problem structure (which can be defined as an inherent layered structure of complexity of the domain ). But Liskov and Guttag took it to a whole new level.">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Articles",
      "item": "https://lngnmn2.github.io/articles/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "A few steps closer to Vedanta",
      "item": "https://lngnmn2.github.io/articles/vedanta1/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "A few steps closer to Vedanta",
  "name": "A few steps closer to Vedanta",
  "description": "Once upon a time I find it difficult to read these lecture notes in https://www.cl.cam.ac.uk/teaching/1718/L28/materials.html because of ESL and math \u0026ldquo;fear\u0026rdquo;. Nowadays I could, probably, explain the fundamentals more clearly in just a few pages.\nThe \u0026ldquo;End Of Knowledge\u0026rdquo; (of seeking to Understand) can be achieved by just a few simple realizations, which means attaining one\u0026rsquo;s own \u0026ldquo;Right Understanding\u0026rdquo; through direct experience and one\u0026rsquo;s own \u0026ldquo;a-ha moments\u0026rdquo;.\nArguably, the \u0026ldquo;Upanishads\u0026rdquo; of Programming began with this book: Abstraction and Specification in Program Development by Barbara Liskov and John V. Guttag. No, a few years earlier Michael A. Jackson wrote Principles of Program Design, which emphasized the fundamental principle that one\u0026rsquo;s program structure should reflect (actually to be in one-to-one correspondence with) the problem structure (which can be defined as an inherent layered structure of complexity of the domain ). But Liskov and Guttag took it to a whole new level.\n",
  "keywords": [
    "esoteric"
  ],
  "articleBody": "Once upon a time I find it difficult to read these lecture notes in https://www.cl.cam.ac.uk/teaching/1718/L28/materials.html because of ESL and math “fear”. Nowadays I could, probably, explain the fundamentals more clearly in just a few pages.\nThe “End Of Knowledge” (of seeking to Understand) can be achieved by just a few simple realizations, which means attaining one’s own “Right Understanding” through direct experience and one’s own “a-ha moments”.\nArguably, the “Upanishads” of Programming began with this book: Abstraction and Specification in Program Development by Barbara Liskov and John V. Guttag. No, a few years earlier Michael A. Jackson wrote Principles of Program Design, which emphasized the fundamental principle that one’s program structure should reflect (actually to be in one-to-one correspondence with) the problem structure (which can be defined as an inherent layered structure of complexity of the domain ). But Liskov and Guttag took it to a whole new level.\nWhat the heck is the Inherent Structure [of domain’s] complexity? in 1962 Herbert A. Simon wrote a seminal paper The Architecture of Complexity, which shared the observations that almost all Nature’s complexity (at least in Biology) has a hierarchical and layred structure (which is, indeed, “natural”) and introduced the idea of “nearly decomposable systems”.\nIn 1981, in his book The Sciences of the Artificial, Simon further elaborated on this idea, emphasizing that complex systems are often composed of interrelated subsystems that can be understood independently to a significant extent. Again, this “lose coupling” of subsystems is a fundamental principle of complexity in Nature. Close-coupling does not evolve well.\nThe most fundamental principle, however, which is necessary for a good programming and is the major underlying principle of non-bullshit software design is that the code has to be at the same, appropriate (high) level as the concepts of the problem domain, which means no low-level types, generics (they are implementation details of the low-level libraries), no machine types, no low-level imperative looping and indexing syntactic constructs at the highest level of the domain’s model – user-defined Algebraic Data Types, the corresponding mostly-functional DSLs (of associated operations) which has to be used by the “surrounding” level of domain (“business”) logic.\nSo-called Clean Architecture (or that another Hexagonal one) arise “neurally” from the discipline of properly partitioning the code into layers of DSLs (vertically) and modules – one per domain concept – (horizontally) separating them by clear, non-leaking abstraction barriers, which is what a cell-membrane with all its “pumps” and “portals” (or at a higher level – an organ’s outer layer) is. The concepts of a “port” in Scheme, SML or Erlang has been losely modeled on biology by the MIT guys who have lots of top-tier biologists around.\nBy knowing just this much you are already ahead of 90% of “programmers” on YouTube, because these are fundamental principles, while they are bragging about knowing particulars (of some fucking C++ lmao).\nOne more required paper (I could not easily find the original Howard’s paper, so I link this – The Curry-Howard correspondence today by Xavier Leroy).\nThe Curry-Howard correspondence (also known as the Curry-Howard isomorphism) shows that, the logical connectives and quantifiers in logic correspond to type constructors in classic FP languages, and that logical proofs correspond to computer programs.\nBut the real “a-ha moment” is that they have the same [algebraic] structure, and this is not a random coincidence, this is direct consequence of the fact that there is a universal underlying structure Out There .\nWhen one “chops off” a direct acyclic graph (DAG) into its most basic building blocks, one would find “forks, joins and steps”, and these building blocks have the same algebraic structure as logical connectives (AND, OR, IMPLIES, NOT, FOR ALL, THERE EXISTS, etc) and type constructors (product types, sum types, function types, etc).\nHere you have to say “a-ha” again.\nThere is some more. The classic Algorithmic Charting Techniques of the 70s, which can express every possible algorithm (as proven by the famous Structured program theorem), have the same algebraic structure as well. So are the EE schematics of digital circuits.\nOkay, now what? Well, it seems that The Way to Program, which is just another name for the Way of Managing Complexity, is to use mathematical models, which consist of augmented with the Algebraic Types highly syntactically sugared Simple Typed Lambda Calculus, extended with some primitive (machine) types.\nAnd indeed, back in the late 90s, programming has been “solved” by the ML family of languages (Standard ML, OCaml, F#, etc) and Miranda and then Haskell. And yes, Lists, Trees and Tables were enough of data structures (Abstract Data Types) to express any common data structure of complexity in almost any domain.\nHave you noticed that your neurons also have a layered structure and that axons and dendrites form DAGs? The computational graphs of modern Deep Learning frameworks (TensorFlow, PyTorch, JAX, etc) also have the same algebraic structure (of a DAG) and the composable “pieces” are the structurally the same as logical connectives and Algebraic Type-constructors.\nNow you should say “uhhh”.\nSo, it seems that if I package the fundamental [nested and parameterized] Algebraic Data Types inside classic [non-leaking] Abstract Data Types (ADTs) as per Barbara LIskov, and that the resulting abstract structure of the sum-, product- and function types (and the type-classes they “naturally” form) have the one-to-one correspondence with the inherent structure of complexity of the domain (as per Michael Jackson or nowadays Scott Wlaschin), then I can express any algorithm (as nested functions over these ADTs) that solves any problem in that domain.\nIf I would achieve a “perfect” structural match,not just I could say that I have achieved “Right Understanding” of that domain, and that my program is a “Right Program” for that domain, but that I approached a local optimum, or a structural “fixed point”.\nThis shows, among other things, that such “fixed points” do exist and are, actually (not just theoretically) attainable, with only such means as function composition, algebraic data types, nesting and layering (the hierarchy, if properly captured, will emerge naturally), by applying the abstraction by parameterization and abstraction by specification principles (to get proper ADTs).\nHave you ever noticed that one could not tell whether a function has a n arguments or a single n-tuple as a sole argument? A curried function is the “ultimate join”, and it captures The Modus Ponens (Causality itself) as the universal notion of “Necessary And Sufficient”? An pair (or an n-tuple) is the product-type. All the “slots” of an enzyme has to be filled, just as all the necessary and sufficient conditions has to be meet.\nIt is not a random coincidence that a type of a curried function and a corresponding n-tuple are isomorphic to each other – both are “a set of arrows coming in” (the ordering is irrelevant) .\nThe shortcircuiting if (or a cond), is, of course, the “ultimate fork”, and captures the notion Potentiality itself, and the “proper” notion of an exclusive OR (“or both” happens only in pure mathematics). Only one “path” (or an outgoing arrow) could be taken (notice the absence of “at a time”).\nWhat about loop? There aren’t ones. Recursion is a “spiral”, not a “cycle” (even two of them – nested “calls” (chained “arrows”) all the way to the base-case and then actual unfolding of “returns”). Look, ma, no loops. If your language have imperative stateful mutating loops instead…\nHave I told you that the graph-reduction with the same term rewriting rules (based on substitution of an equal for an equal), lust like a human calculators did with a pen and paper, is the ultimate evaluation strategy of “lazy” pure-functional languages? The Lambda Calculus (math and logic are also “by need”). SPJ wrote a whole book about this discovery.\nMaybe this is the right time to say “Om” or something.\nThis is the understanding which the classic FP guys probably had at the peak of the Golden Age of Programming, which culminated with the Haskell 2010. This is what that “advanced” Cambridge Course is about, if you skip all the very cool but mostly irrelevant (compared to this) derivations.\nNow you have some realizations, which lift you above some 95% of the population.\nNow what?\nWell, programming is suddenly can be fun and be simple again. You just model your domain with sets, logic and relations (as functions) and then translate it into abstract data types which encapsulate the algebraic data types, that match the structure of the problem domain.\nThen you can write it down in any decent language – Haskell, Ocaml, Scala3 or even Rust (which is not even mostly-functional but is mimicking some aspects of FP and could have an ad-hoc referential transparency by avoiding mut and \u0026mut in principle, which is what your domain layer absolutely should do anyway).\nOne more time, the particular programming (implementation) languages are almost irrelevant, while some are way better designed (by mathematicians, and you can tell!) than the others. As long as you have enough support of classic algebraic structures in your languages (as Rust is struggling to get) everything will “naturally” falls to its places.\nAgain, this is not just an opinion, man, there is a “path” all the way from the universal notions of Causality and Potentiality (which can be, in principle, captured by a DAG) to your petty domain, be it yet another shopping site or a crapto trading bot.\nThere is no other structure Out There. It is all that one might ever find, just as when you see all possible permutations of something much simpler.\nTo be fair, there is some more structure. There is nesting (as in cells) and abstraction barriers with “pumps” and “posts” (which are just “lamdas” of an exported (public) Abstract Interface associated with an ADT). There are the notions of a “physical locality” and of the “shared environment, with nested frames” (which is what is required even to evaluate some expressions of the lambda calculus by pure substitution of a piece of paper).\nAll this, however, has been captured and intuitively understood by the MIT guys who designed the universal machine – the Metacircular Evaluator for Scheme, which back then was a clean implementation of the stronly typed Lambda Calculus.\nHere I probably should bootstrap all the fundamental algebraic structures from the Lambda Calculus (application, abstraction, binding) all the way up to Monads, which just capture a Monoid (the particular way to compose) of EndoFunctors, but it is rather tedious and has been done by much better qualified people.\nThe meme I will give you is this:\n, | -\u003e = ()\nThis is all you need.\nFor convenience and it is good to have Currying (which is just nesting, which is, in turn, how composition is implemented) which has been discovered, not invented, and type-parameters and thus type-constructors, as well as data-constructors as “type-tags” for strutural pattern-matching.\nIt is also good to have partial functions as a “sum” of individual clauses (arrows), as SML and Haskell have. Everything has already been discovered more than once, and there is a reason why.\n",
  "wordCount" : "1840",
  "inLanguage": "en",
  "datePublished": "2025-11-14T00:00:00+05:45",
  "dateModified": "2025-11-15T14:00:38+05:45",
  "author":[{
    "@type": "Person",
    "name": "lngnmn2@yahoo.com"
  }],
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://lngnmn2.github.io/articles/vedanta1/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Notes from the digital underground by Lngnmn",
    "logo": {
      "@type": "ImageObject",
      "url": "https://lngnmn2.github.io/favicon.ico"
    }
  }
}
</script>
</head>
<body id="top">
    <header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://lngnmn2.github.io/" accesskey="h" title="Notes from the digital underground by Lngnmn (Alt + H)">Notes from the digital underground by Lngnmn</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://lngnmn2.github.io/about/" title="About me.">
                    <span>About me.</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title entry-hint-parent">
      A few steps closer to Vedanta
    </h1>
    <div class="post-meta"><span title='2025-11-14 00:00:00 +0545 +0545'>November 14, 2025</span>&nbsp;·&nbsp;<span>lngnmn2@yahoo.com</span>

</div>
  </header> 
  <div class="post-content"><p>Once upon a time I find it difficult to read these lecture notes in <a href="https://www.cl.cam.ac.uk/teaching/1718/L28/materials.html">https://www.cl.cam.ac.uk/teaching/1718/L28/materials.html</a> because of ESL and math &ldquo;fear&rdquo;. Nowadays I could, probably, explain the fundamentals more clearly in just a few pages.</p>
<p>The &ldquo;End Of Knowledge&rdquo; (of seeking to Understand) can be achieved by just a few simple realizations, which means attaining one&rsquo;s own &ldquo;Right Understanding&rdquo; through direct experience and one&rsquo;s own &ldquo;a-ha moments&rdquo;.</p>
<p>Arguably, the &ldquo;Upanishads&rdquo; of Programming began with this book: <a href="https://mitpress.mit.edu/9780262121125/abstraction-and-specification-in-program-development/">Abstraction and Specification in Program Development by Barbara Liskov and John V. Guttag</a>. No, a few years earlier Michael A. Jackson wrote <a href="https://www.amazon.com/Principles-Program-Design-Michael-Jackson/dp/0138549950">Principles of Program Design</a>, which emphasized the fundamental principle that one&rsquo;s program structure should reflect (actually to be in one-to-one correspondence with) the problem structure (which can be defined as an inherent layered structure of complexity of the domain ). But Liskov and Guttag took it to a whole new level.</p>
<p>What the heck is the Inherent Structure [of domain&rsquo;s] complexity? in 1962 Herbert A. Simon wrote a seminal paper <a href="https://dl.acm.org/doi/10.1145/368119.368126">The Architecture of Complexity</a>, which shared the observations that almost all Nature&rsquo;s complexity (at least in Biology) has a hierarchical and layred structure (which is, indeed, &ldquo;natural&rdquo;) and introduced the idea of &ldquo;nearly decomposable systems&rdquo;.</p>
<p>In 1981, in his book <a href="https://mitpress.mit.edu/9780262132861/the-sciences-of-the-artificial/">The Sciences of the Artificial</a>, Simon further elaborated on this idea, emphasizing that complex systems are often composed of interrelated subsystems that can be understood independently to a significant extent. Again, this &ldquo;lose coupling&rdquo; of subsystems is a fundamental principle of complexity in Nature. Close-coupling does not evolve well.</p>
<p>The most fundamental principle, however, which is necessary for  a  good programming and is the major underlying principle of non-bullshit software design is that the code has to be <em>at the same, appropriate (high) level as the concepts of the problem domain</em>, which means no low-level types, generics (they are <em>implementation details of  the low-level libraries</em>), no machine types, no low-level imperative looping and indexing syntactic  constructs at the highest level of the domain&rsquo;s model &ndash; user-defined Algebraic Data Types, the corresponding mostly-functional DSLs (of associated operations) which has to be used by the  &ldquo;surrounding&rdquo; level of  domain (&ldquo;business&rdquo;) logic.</p>
<p>So-called Clean Architecture (or that another Hexagonal one) arise &ldquo;neurally&rdquo; from the <em>discipline</em> of properly partitioning the code into layers of DSLs (vertically) and modules &ndash; one per domain concept &ndash; (horizontally) separating them by clear, non-leaking abstraction barriers, which is what a <em>cell-membrane</em> with all its &ldquo;pumps&rdquo; and &ldquo;portals&rdquo; (or at a higher level &ndash; an organ&rsquo;s outer layer) is. The concepts of a &ldquo;port&rdquo; in Scheme, SML or Erlang has been losely modeled on biology by the MIT guys who have lots of top-tier biologists around.</p>
<p>By knowing just <em>this much</em> you are already ahead of 90% of &ldquo;programmers&rdquo; on YouTube, because these are fundamental principles, while they are bragging about knowing particulars (of some fucking C++ lmao).</p>
<p>One more required paper (I could not easily find the original Howard&rsquo;s paper, so I link this  &ndash; <a href="https://xavierleroy.org/CdF/2018-2019/1.pdf">The Curry-Howard correspondence today by Xavier Leroy</a>).</p>
<p>The Curry-Howard correspondence (also known as the Curry-Howard isomorphism) shows that, the logical connectives and quantifiers in logic correspond to type constructors in classic FP languages, and that logical proofs correspond to computer programs.</p>
<p>But the real &ldquo;a-ha moment&rdquo; is that they have <em>the same [algebraic] structure</em>, and <em>this</em> is not a random coincidence, this is  direct consequence of the fact that <em>there is a universal underlying structure Out There</em> .</p>
<p>When one &ldquo;chops off&rdquo; a direct acyclic graph (DAG) into its most basic building blocks, one would find &ldquo;forks, joins and steps&rdquo;, and these building blocks have the same algebraic structure as logical connectives (AND, OR, IMPLIES, NOT, FOR ALL, THERE EXISTS, etc) and type constructors (product types, sum types, function types, etc).</p>
<p>Here you have to say &ldquo;a-ha&rdquo; again.</p>
<p>There is some more. The classic <em>Algorithmic Charting Techniques</em> of the 70s, which can express every possible algorithm (as proven by the famous <a href="https://en.wikipedia.org/wiki/Structured_program_theorem">Structured program theorem</a>), have the same algebraic structure as well. So are the EE schematics of digital circuits.</p>
<p>Okay, now what? Well, it seems that The Way to Program, which is just another name for the Way of Managing Complexity, is to use mathematical models, which consist of augmented with the Algebraic Types highly syntactically sugared Simple Typed Lambda Calculus, extended with some primitive (machine) types.</p>
<p>And indeed, back in the late 90s, programming has been &ldquo;solved&rdquo; by the ML family of languages (Standard ML, OCaml, F#, etc) and Miranda and then Haskell. And yes, Lists, Trees and Tables were enough of data structures (Abstract Data Types) to express any common data structure of complexity in almost any domain.</p>
<p>Have you noticed that your neurons also have a layered structure and that axons and dendrites form DAGs?  The computational graphs of modern Deep Learning frameworks (TensorFlow, PyTorch, JAX, etc) also have the same algebraic structure (of a DAG) and the composable  &ldquo;pieces&rdquo; are the structurally the same as logical connectives and Algebraic Type-constructors.</p>
<p>Now you should say &ldquo;uhhh&rdquo;.</p>
<p>So, it seems that if I package the fundamental [nested and parameterized] <em>Algebraic Data Types</em> inside  classic [non-leaking] Abstract Data Types (ADTs) as per Barbara LIskov, and that the resulting abstract structure of the sum-, product- and function types (and the type-classes they &ldquo;naturally&rdquo; form) have the one-to-one correspondence with the inherent structure of complexity of the domain (as per Michael Jackson or nowadays Scott Wlaschin), then I can express any algorithm (as nested functions over these ADTs) that solves any problem in that domain.</p>
<p>If I would achieve  a &ldquo;perfect&rdquo; structural match,not just I could say that I have achieved &ldquo;Right Understanding&rdquo; of that domain, and that my program is a &ldquo;Right Program&rdquo; for that domain, but that I approached a <em>local optimum</em>, or a structural &ldquo;fixed point&rdquo;.</p>
<p>This shows, among other things, that such &ldquo;fixed points&rdquo; do exist and  are, actually (not  just theoretically) attainable, with only such means as function composition, algebraic data types, nesting and layering (the hierarchy, if properly captured, will  emerge naturally), by  applying the abstraction by parameterization and abstraction by specification principles (to get proper ADTs).</p>
<p>Have you ever noticed that one could not tell whether a function has a n arguments or a single n-tuple as a sole argument? A curried function is the &ldquo;ultimate join&rdquo;, and it captures The Modus Ponens (Causality itself)  as the universal notion of &ldquo;Necessary And Sufficient&rdquo;? An pair (or an n-tuple) is  <em>the</em> product-type. All the &ldquo;slots&rdquo; of  an enzyme has to be filled, just as all the necessary and sufficient conditions has to be meet.</p>
<p>It is not a random coincidence that a type of a curried function and a corresponding n-tuple are isomorphic to each other &ndash; both are &ldquo;a set of arrows coming in&rdquo; (the ordering is irrelevant) .</p>
<p>The <em>shortcircuiting</em> <code>if</code> (or a <code>cond</code>), is, of course, the &ldquo;ultimate fork&rdquo;, and captures the notion Potentiality itself, and the &ldquo;proper&rdquo; notion  of an exclusive OR (&ldquo;or both&rdquo; happens only in pure mathematics). Only one &ldquo;path&rdquo; (or an outgoing arrow) could be taken (notice the absence of &ldquo;at a time&rdquo;).</p>
<p>What about loop? There aren&rsquo;t ones. Recursion is a &ldquo;spiral&rdquo;, not a &ldquo;cycle&rdquo; (even two of them &ndash; nested &ldquo;calls&rdquo; (chained &ldquo;arrows&rdquo;) all the way to the <em>base-case</em> and then actual <em>unfolding</em> of &ldquo;returns&rdquo;). Look, ma, no loops. If your language have imperative stateful mutating loops instead&hellip;</p>
<p>Have I told you that the <em>graph-reduction</em> with the same <em>term rewriting rules</em> (based on substitution of an equal for an equal), lust like a human calculators did with a pen and paper, is the ultimate evaluation strategy of &ldquo;lazy&rdquo; pure-functional languages? The Lambda Calculus (math and logic are also &ldquo;by need&rdquo;). SPJ wrote a whole book about this discovery.</p>
<p>Maybe this is the right time to say &ldquo;Om&rdquo; or something.</p>
<p><em>This</em> is the understanding which the classic FP guys probably had at the peak of the <em>Golden Age of Programming</em>, which culminated with the Haskell 2010. This is what that &ldquo;advanced&rdquo; Cambridge Course is about, if you skip all the very cool but mostly irrelevant (compared to this) derivations.</p>
<p>Now you have some realizations, which lift you above some 95% of the population.</p>
<p>Now what?</p>
<p>Well, programming is <em>suddenly</em> can be <em>fun</em> and be <em>simple</em> again.  You just model your domain with sets, logic and relations (as functions) and then translate it into abstract data types which encapsulate the algebraic data types, that match the structure of the problem domain.</p>
<p>Then you can write it down in any decent language &ndash; Haskell, Ocaml, Scala3 or even Rust (which is not even <em>mostly-functional</em> but <em>is mimicking some aspects of FP and could have an ad-hoc referential transparency by avoiding <code>mut</code> and <code>&amp;mut</code> in principle</em>, which is what your <em>domain layer</em> absolutely should do anyway).</p>
<p>One more time, the particular programming (implementation) languages are almost irrelevant, while some are way better designed (by mathematicians, and you can tell!) than the others. As long as you have enough support of classic algebraic structures in your languages (as Rust is struggling to get) everything will &ldquo;naturally&rdquo; falls to its places.</p>
<p>Again, this is not just an opinion, man, there is a &ldquo;path&rdquo; all the way from the universal notions of Causality and Potentiality (which can be, in principle, captured by a DAG) to your petty domain, be it yet another shopping site or a crapto trading bot.</p>
<p>There is no other structure Out There. It is <em>all</em> that one might ever find, just as when you see <em>all</em> possible permutations of something much simpler.</p>
<p>To be fair, there is some more structure. There is nesting (as in cells) and abstraction barriers with &ldquo;pumps&rdquo; and &ldquo;posts&rdquo; (which are just &ldquo;lamdas&rdquo; of an exported (public) Abstract Interface associated with an ADT). There are the notions of a &ldquo;physical locality&rdquo;  and of the &ldquo;shared environment, with nested frames&rdquo; (which is what is required even to evaluate some expressions of the lambda calculus by pure substitution of a piece of paper).</p>
<p>All this, however, has been captured and intuitively understood by the MIT guys who designed the universal machine &ndash; the Metacircular Evaluator for Scheme, which back then was a clean implementation of the stronly typed Lambda Calculus.</p>
<p>Here I probably should bootstrap all the fundamental algebraic structures from the Lambda Calculus (application, abstraction, binding) all the way up to Monads, which just capture a  Monoid (the particular way to compose) of EndoFunctors, but it is rather tedious and has been done by much better qualified people.</p>
<p>The meme I will give you is this:</p>
<blockquote>
<p>, | -&gt; = ()</p></blockquote>
<p>This is all you need.</p>
<p>For convenience and it is good to have <em>Currying</em> (which is just nesting, which is, in turn, how composition is implemented) which has been discovered, not invented, and type-parameters and thus type-constructors, as well as data-constructors as &ldquo;type-tags&rdquo; for strutural pattern-matching.</p>
<p>It is also good to have partial functions as a &ldquo;sum&rdquo; of individual clauses (arrows), as SML and Haskell have. Everything has already been discovered more than once, and there is a reason <em>why</em>.</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://lngnmn2.github.io/tags/esoteric/">Esoteric</a></li>
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2026 <a href="https://lngnmn2.github.io/">Notes from the digital underground by Lngnmn</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu');
    if (menu) {
        
        const scrollPosition = localStorage.getItem("menu-scroll-position");
        if (scrollPosition) {
            menu.scrollLeft = parseInt(scrollPosition, 10);
        }
        
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        const html = document.querySelector("html");
        if (html.dataset.theme === "dark") {
            html.dataset.theme = 'light';
            localStorage.setItem("pref-theme", 'light');
        } else {
            html.dataset.theme = 'dark';
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
